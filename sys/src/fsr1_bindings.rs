/* automatically generated by rust-bindgen 0.72.1 */

pub const FSR1_VERSION_MAJOR: u32 = 1;
pub const FSR1_VERSION_MINOR: u32 = 1;
pub const FSR1_VERSION_PATCH: u32 = 0;
pub const FSR1_CONTEXT_COUNT: u32 = 2;
pub const FSR1_CONTEXT_SIZE: u32 = 16536;
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the passes which constitute the FSR1 algorithm.\n\n FSR1 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr1ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr1Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR1\n reference documentation.\n\n @ingroup ffxFsr1"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Fsr1Pass {
    #[doc = "< A pass which upscales the color buffer using easu."]
    EASU = 0,
    #[doc = "< A pass which upscales the color buffer in preparation for rcas"]
    EASU_RCAS = 1,
    #[doc = "< A pass which performs rcas sharpening on the upscaled image."]
    RCAS = 2,
    #[doc = "< The number of passes performed by FSR2."]
    COUNT = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 1 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR1. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n @ingroup ffxFsr1"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Fsr1QualityMode {
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.3x."]
    ULTRA_QUALITY = 0,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
    QUALITY = 1,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
    BALANCED = 2,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
    PERFORMANCE = 3,
}
impl Fsr1InitializationFlagBits {
    #[doc = "< A bit indicating if we should use rcas."]
    pub const ENABLE_RCAS: Fsr1InitializationFlagBits = Fsr1InitializationFlagBits(1);
    #[doc = "< A bit indicating if we should use passthrough alpha during rcas."]
    pub const RCAS_PASSTHROUGH_ALPHA: Fsr1InitializationFlagBits = Fsr1InitializationFlagBits(2);
    #[doc = "< A bit indicating if denoising is invoked during rcas."]
    pub const RCAS_DENOISE: Fsr1InitializationFlagBits = Fsr1InitializationFlagBits(4);
    #[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
    pub const ENABLE_HIGH_DYNAMIC_RANGE: Fsr1InitializationFlagBits = Fsr1InitializationFlagBits(8);
    #[doc = "< A bit indicating that input/output resources require gamma conversions"]
    pub const ENABLE_SRGB_CONVERSIONS: Fsr1InitializationFlagBits = Fsr1InitializationFlagBits(16);
}
impl ::std::ops::BitOr<Fsr1InitializationFlagBits> for Fsr1InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        Fsr1InitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for Fsr1InitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: Fsr1InitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<Fsr1InitializationFlagBits> for Fsr1InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Fsr1InitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for Fsr1InitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: Fsr1InitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr1Context</i></c>. See <c><i>FfxFsr1ContextDescription</i></c>.\n\n @ingroup ffxFsr1"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Fsr1InitializationFlagBits(pub ::std::os::raw::c_int);
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 1.0\n\n @ingroup ffxFsr1"]
#[repr(C)]
pub struct Fsr1ContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr1InitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< Format of the output target used for creation of the internal upscale resource"]
    pub outputFormat: SurfaceFormat,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub displaySize: Dimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FSR1."]
    pub backendInterface: Interface,
}
impl Default for Fsr1ContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 1.0\n\n @ingroup ffxFsr1"]
#[repr(C)]
pub struct Fsr1DispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR1 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub output: Resource,
    #[doc = "< The resolution that was used for rendering the input resource."]
    pub renderSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
}
impl Default for Fsr1DispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 1.0 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR1.\n\n The <c><i>FfxFsr1Context</i></c> object should have a lifetime matching\n your use of FSR1. Before destroying the FSR1 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR1.\n It is therefore recommended that the GPU is idle before destroying the\n FSR1 context.\n\n @ingroup ffxFsr1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr1Context {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 16536usize],
}
impl Default for Fsr1Context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 1.0 context from the parameters\n programmed to the <c><i>FfxFsr1ContextDescription</i></c> structure.\n\n The context structure is the main object used to interact with the Super\n Resoution 1.0 API, and is responsible for the management of the internal resources\n used by the FSR1 algorithm. When this API is called, multiple calls\n will be made via the pointers contained in the <c><i>callbacks</i></c>\n structure. These callbacks will attempt to retreive the device capabilities,\n and create the internal resources, and pipelines required by FSR1\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr1Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The <c><i>FfxParallelSortContext</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR1\n upscaling is disabled by a user. To destroy the FSR1 context you\n should call <c><i>ffxFsr1ContextDestroy</i></c>.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr1Context</i></c> structure to populate.\n @param [in]  pContextDescription     A pointer to a <c><i>FfxFsr1ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr1ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr1"]
    #[link_name = "\u{1}ffxFsr1ContextCreate"]
    pub fn Fsr1ContextCreate(
        pContext: *mut Fsr1Context,
        pContextDescription: *const Fsr1ContextDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " @param [out] pContext                A pointer to a <c><i>FfxFsr1Context</i></c> structure to populate.\n @param [in]  pDispatchDescription    A pointer to a <c><i>FfxFsr1DispatchDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr1"]
    #[link_name = "\u{1}ffxFsr1ContextDispatch"]
    pub fn Fsr1ContextDispatch(
        pContext: *mut Fsr1Context,
        pDispatchDescription: *const Fsr1DispatchDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Destroy the FidelityFX FSR 1 context.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr1Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup ffxFsr1"]
    #[link_name = "\u{1}ffxFsr1ContextDestroy"]
    pub fn Fsr1ContextDestroy(pContext: *mut Fsr1Context) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR1_QUALITY_MODE_ULTRA_QUALITY</i></c>     | 1.3x\n <c><i>FFX_FSR1_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR1_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR1_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup ffxFsr1"]
    #[link_name = "\u{1}ffxFsr1GetUpscaleRatioFromQualityMode"]
    pub fn Fsr1GetUpscaleRatioFromQualityMode(qualityMode: Fsr1QualityMode) -> f32;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr1GetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] pRenderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] pRenderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR1 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup ffxFsr1"]
    #[link_name = "\u{1}ffxFsr1GetRenderResolutionFromQualityMode"]
    pub fn Fsr1GetRenderResolutionFromQualityMode(
        pRenderWidth: *mut u32,
        pRenderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: Fsr1QualityMode,
    ) -> ErrorCode;
}
