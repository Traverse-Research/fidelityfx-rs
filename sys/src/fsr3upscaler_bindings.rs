/* automatically generated by rust-bindgen 0.72.1 */

pub const FSR3UPSCALER_VERSION_MAJOR: u32 = 3;
pub const FSR3UPSCALER_VERSION_MINOR: u32 = 0;
pub const FSR3UPSCALER_VERSION_PATCH: u32 = 3;
pub const FSR3UPSCALER_CONTEXT_COUNT: u32 = 1;
pub const FSR3UPSCALER_CONTEXT_SIZE: u32 = 131072;
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the passes which constitute the FSR3 algorithm.\n\n FSR3 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr3UpscalerScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr3UpscalerPass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR3\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR3UPSCALER_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR3UPSCALER_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr3UpscalerContext</i></c> is created and the\n precise contents of <c><i>FfxFsr3UpscalerDispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr3UpscalerContextDispatch</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Fsr3UpscalerPass {
    #[doc = "< A pass which performs depth clipping."]
    DEPTH_CLIP = 0,
    #[doc = "< A pass which performs reconstruction of previous frame's depth."]
    RECONSTRUCT_PREVIOUS_DEPTH = 1,
    #[doc = "< A pass which calculates pixel locks."]
    LOCK = 2,
    #[doc = "< A pass which performs upscaling."]
    ACCUMULATE = 3,
    #[doc = "< A pass which performs upscaling when sharpening is used."]
    ACCUMULATE_SHARPEN = 4,
    #[doc = "< A pass which performs sharpening."]
    RCAS = 5,
    #[doc = "< A pass which generates the luminance mipmap chain for the current frame."]
    COMPUTE_LUMINANCE_PYRAMID = 6,
    #[doc = "< An optional pass to generate a reactive mask."]
    GENERATE_REACTIVE = 7,
    #[doc = "< DEPRECATED - NO LONGER SUPPORTED"]
    TCR_AUTOGENERATE = 8,
    #[doc = "< The number of passes performed by FSR3."]
    COUNT = 9,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 3 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR3. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup ffxFsr3Upscaler"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Fsr3UpscalerQualityMode {
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.0x."]
    NATIVEAA = 0,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
    QUALITY = 1,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
    BALANCED = 2,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
    PERFORMANCE = 3,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
    ULTRA_PERFORMANCE = 4,
}
impl Fsr3UpscalerInitializationFlagBits {
    #[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
    pub const ENABLE_HIGH_DYNAMIC_RANGE: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(1);
    #[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
    pub const ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(2);
    #[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
    pub const ENABLE_MOTION_VECTORS_JITTER_CANCELLATION: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(4);
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const ENABLE_DEPTH_INVERTED: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(8);
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const ENABLE_DEPTH_INFINITE: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(16);
    #[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
    pub const ENABLE_AUTO_EXPOSURE: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(32);
    #[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
    pub const ENABLE_DYNAMIC_RESOLUTION: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(64);
    #[doc = "< A bit indicating that the backend should use 1D textures."]
    pub const ENABLE_TEXTURE1D_USAGE: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(128);
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const ENABLE_DEBUG_CHECKING: Fsr3UpscalerInitializationFlagBits =
        Fsr3UpscalerInitializationFlagBits(256);
}
impl ::std::ops::BitOr<Fsr3UpscalerInitializationFlagBits> for Fsr3UpscalerInitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        Fsr3UpscalerInitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for Fsr3UpscalerInitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: Fsr3UpscalerInitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<Fsr3UpscalerInitializationFlagBits> for Fsr3UpscalerInitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Fsr3UpscalerInitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for Fsr3UpscalerInitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: Fsr3UpscalerInitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr3UpscalerContext</i></c>. See <c><i>FfxFsr3UpscalerContextDescription</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Fsr3UpscalerInitializationFlagBits(pub ::std::os::raw::c_int);
#[doc = " Pass a string message\n\n Used for debug messages.\n\n @param [in] type                       The type of message.\n @param [in] message                    A string message to pass.\n\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerMessage =
    ::std::option::Option<unsafe extern "C" fn(type_: MsgType, message: *const u16)>;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 3 upscaling.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
pub struct Fsr3UpscalerContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr3UpscalerInitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub displaySize: Dimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
    #[doc = "< A pointer to a function that can receive messages from the runtime."]
    pub fpMessage: Fsr3UpscalerMessage,
}
impl Default for Fsr3UpscalerContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 3.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
pub struct Fsr3UpscalerDispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR3UPSCALER_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit dilated depth and share with following effects."]
    pub dilatedDepth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit dilated motion vectors and share with following effects."]
    pub dilatedMotionVectors: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit reconstructed previous nearest depth and share with following effects."]
    pub reconstructedPrevNearestDepth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub output: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
}
impl Default for Fsr3UpscalerDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
pub struct Fsr3UpscalerGenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for Fsr3UpscalerGenerateReactiveDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the resource descriptions for shared resources for this effect.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
pub struct Fsr3UpscalerSharedResourceDescriptions {
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>reconstructedPrevNearestDepth</i></c> shared resource."]
    pub reconstructedPrevNearestDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedDepth</i></c> shared resource."]
    pub dilatedDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedMotionVectors</i></c> shared resource."]
    pub dilatedMotionVectors: CreateResourceDescription,
}
impl Default for Fsr3UpscalerSharedResourceDescriptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 3 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3UpscalerContext</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3UpscalerContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for Fsr3UpscalerContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 3 context from the parameters\n programmed to the <c><i>FfxFsr3UpscalerCreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3UpscalerContext</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3UpscalerContext</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3UpscalerDispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3UpscalerContext</i></c> is created, you should use the\n <c><i>ffxFsr3UpscalerContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3UpscalerContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3UpscalerContext</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3UpscalerContextDestroy</i></c>.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure to populate.\n @param [in]  pContextDescription     A pointer to a <c><i>FfxFsr3UpscalerContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3UpscalerContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextCreate"]
    pub fn Fsr3UpscalerContextCreate(
        pContext: *mut Fsr3UpscalerContext,
        pContextDescription: *const Fsr3UpscalerContextDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Provides the descriptions for shared resources that must be allocated for this effect.\n\n @param [in] context\t\t\t\t\tA pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [out] SharedResources\t\tA pointer to a <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> to populate.\n\n @returns\n FFX_OK\t\t\t\t\t\t\t\tThe operation completed successfully.\n @returns\n Anything else\t\t\t\t\t\tThe operation failed.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetSharedResourceDescriptions"]
    pub fn Fsr3UpscalerGetSharedResourceDescriptions(
        context: *mut Fsr3UpscalerContext,
        SharedResources: *mut Fsr3UpscalerSharedResourceDescriptions,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 3.\n\n FSR3 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr3UpscalerContextDispatch</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr3UpscalerContext</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr3UpscalerContext</i></c> correctly\n programming the <c><i>FfxFsr3UpscalerDispatchDescription</i></c> is key to ensuring\n the correct operation of FSR3. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR3 provides the\n <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c> and\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchDescription</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR3.\n\n @param [in] pContext                 A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [in] pDispatchDescription     A pointer to a <c><i>FfxFsr3UpscalerDispatchDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchDescription.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextDispatch"]
    pub fn Fsr3UpscalerContextDispatch(
        pContext: *mut Fsr3UpscalerContext,
        pDispatchDescription: *const Fsr3UpscalerDispatchDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] pContext                 A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [in] pParams                  A pointer to a <c><i>FfxFsr3UpscalerGenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextGenerateReactiveMask"]
    pub fn Fsr3UpscalerContextGenerateReactiveMask(
        pContext: *mut Fsr3UpscalerContext,
        pParams: *const Fsr3UpscalerGenerateReactiveDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextDestroy"]
    pub fn Fsr3UpscalerContextDestroy(pContext: *mut Fsr3UpscalerContext) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetUpscaleRatioFromQualityMode"]
    pub fn Fsr3UpscalerGetUpscaleRatioFromQualityMode(qualityMode: Fsr3UpscalerQualityMode) -> f32;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr3UpscalerGetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] pRenderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] pRenderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetRenderResolutionFromQualityMode"]
    pub fn Fsr3UpscalerGetRenderResolutionFromQualityMode(
        pRenderWidth: *mut u32,
        pRenderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: Fsr3UpscalerQualityMode,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetJitterPhaseCount"]
    pub fn Fsr3UpscalerGetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR3 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR3 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr3UpscalerGetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr3UpscalerGetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr3UpscalerGetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr3UpscalerDispatchParameters</i></c> structure in order to inform FSR3\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] pOutX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] pOutY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetJitterOffset"]
    pub fn Fsr3UpscalerGetJitterOffset(
        pOutX: *mut f32,
        pOutY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerResourceIsNull"]
    pub fn Fsr3UpscalerResourceIsNull(resource: Resource) -> bool;
}
