/* automatically generated by rust-bindgen 0.72.1 */

pub const FRAMEINTERPOLATION_VERSION_MAJOR: u32 = 1;
pub const FRAMEINTERPOLATION_VERSION_MINOR: u32 = 1;
pub const FRAMEINTERPOLATION_VERSION_PATCH: u32 = 3;
pub const FRAMEINTERPOLATION_CONTEXT_COUNT: u32 = 1;
pub const FRAMEINTERPOLATION_CONTEXT_SIZE: u32 = 131072;
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the passes which constitute the FSR3 algorithm.\n\n FSR3 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr3ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr3Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR3\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR3_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR3_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr3Context</i></c> is created and the\n precise contents of <c><i>FfxFsr3DispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr3ContextDispatch</i></c>.\n\n @ingroup FRAMEINTERPOLATIONFRAMEINTERPOLATION"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FrameInterpolationPass {
    RECONSTRUCT_AND_DILATE = 0,
    SETUP = 1,
    RECONSTRUCT_PREV_DEPTH = 2,
    GAME_MOTION_VECTOR_FIELD = 3,
    OPTICAL_FLOW_VECTOR_FIELD = 4,
    DISOCCLUSION_MASK = 5,
    INTERPOLATION = 6,
    INPAINTING_PYRAMID = 7,
    INPAINTING = 8,
    GAME_VECTOR_FIELD_INPAINTING_PYRAMID = 9,
    DEBUG_VIEW = 10,
    #[doc = "< The number of passes performed by FrameInterpolation."]
    COUNT = 11,
}
impl FrameInterpolationInitializationFlagBits {
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const ENABLE_DEPTH_INVERTED: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(1);
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const ENABLE_DEPTH_INFINITE: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(2);
    #[doc = "< A bit indicating that the backend should use 1D textures."]
    pub const ENABLE_TEXTURE1D_USAGE: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(4);
    #[doc = "< A bit indicating that HDR values are present in the imaging pipeline."]
    pub const ENABLE_HDR_COLOR_INPUT: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(8);
    #[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
    pub const ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(16);
    pub const ENABLE_JITTER_MOTION_VECTORS: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(32);
    pub const ENABLE_ASYNC_SUPPORT: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(64);
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const ENABLE_DEBUG_CHECKING: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(128);
}
impl ::std::ops::BitOr<FrameInterpolationInitializationFlagBits>
    for FrameInterpolationInitializationFlagBits
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        FrameInterpolationInitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for FrameInterpolationInitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: FrameInterpolationInitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<FrameInterpolationInitializationFlagBits>
    for FrameInterpolationInitializationFlagBits
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        FrameInterpolationInitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for FrameInterpolationInitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: FrameInterpolationInitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFrameInterpolationContext</i></c>. See <c><i>FfxFrameInterpolationContextDescription</i></c>.\n\n @ingroup FRAMEINTERPOLATIONFRAMEINTERPOLATION"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FrameInterpolationInitializationFlagBits(pub ::std::os::raw::c_int);
#[doc = " A structure encapsulating the parameters required to initialize\n FidelityFX Frameinterpolation.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
pub struct FrameInterpolationContextDescription {
    #[doc = "< A collection of <c><i>FfxFrameInterpolationInitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution"]
    pub displaySize: Dimensions2D,
    #[doc = "< the format of the backbuffer"]
    pub backBufferFormat: SurfaceFormat,
    #[doc = "< the format of the texture that will store the interpolation source for the next frame. Can be different than the backbuffer one, especially when using hudless"]
    pub previousInterpolationSourceFormat: SurfaceFormat,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
}
impl Default for FrameInterpolationContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the resource descriptions for shared resources for this effect.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
pub struct FrameInterpolationSharedResourceDescriptions {
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>reconstructedPrevNearestDepth</i></c> shared resource."]
    pub reconstructedPrevNearestDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedDepth</i></c> shared resource."]
    pub dilatedDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedMotionVectors</i></c> shared resource."]
    pub dilatedMotionVectors: CreateResourceDescription,
}
impl Default for FrameInterpolationSharedResourceDescriptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 2 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3Context</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FrameInterpolationContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for FrameInterpolationContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 2 context from the parameters\n programmed to the <c><i>FfxFsr3CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3Context</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3Context</i></c> is created, you should use the\n <c><i>ffxFsr3ContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr3ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationContextCreate"]
    pub fn FrameInterpolationContextCreate(
        context: *mut FrameInterpolationContext,
        contextDescription: *mut FrameInterpolationContextDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationContextGetGpuMemoryUsage"]
    pub fn FrameInterpolationContextGetGpuMemoryUsage(
        pContext: *mut FrameInterpolationContext,
        vramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationGetSharedResourceDescriptions"]
    pub fn FrameInterpolationGetSharedResourceDescriptions(
        pContext: *mut FrameInterpolationContext,
        SharedResources: *mut FrameInterpolationSharedResourceDescriptions,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxSharedContextGetGpuMemoryUsage"]
    pub fn SharedContextGetGpuMemoryUsage(
        backendInterfaceShared: *mut Interface,
        vramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
#[repr(C)]
pub struct FrameInterpolationPrepareDescription {
    #[doc = "< combination of FfxFrameInterpolationDispatchFlags"]
    pub flags: u32,
    #[doc = "< The <c><i>FfxCommandList</i></c> to record frame interpolation commands into."]
    pub commandList: CommandList,
    #[doc = "< The dimensions used to render game content, dilatedDepth, dilatedMotionVectors are expected to be of ths size."]
    pub renderSize: Dimensions2D,
    #[doc = "< The subpixel jitter offset applied to the camera.     jitter;"]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors.     motionVectorScale;"]
    pub motionVectorScale: FloatCoords2D,
    pub frameTimeDelta: f32,
    pub cameraNear: f32,
    pub cameraFar: f32,
    pub viewSpaceToMetersFactor: f32,
    pub cameraFovAngleVertical: f32,
    #[doc = "< The depth buffer data"]
    pub depth: Resource,
    #[doc = "< The motion vector data"]
    pub motionVectors: Resource,
    pub frameID: u64,
    #[doc = "< The dilated depth buffer data"]
    pub dilatedDepth: Resource,
    #[doc = "< The dilated motion vector data"]
    pub dilatedMotionVectors: Resource,
    #[doc = "< The reconstructed depth buffer data"]
    pub reconstructedPrevDepth: Resource,
    #[doc = "< The camera position in world space"]
    pub cameraPosition: Float32x3,
    #[doc = "< The camera up normalized vector in world space."]
    pub cameraUp: Float32x3,
    #[doc = "< The camera right normalized vector in world space."]
    pub cameraRight: Float32x3,
    #[doc = "< The camera forward normalized vector in world space."]
    pub cameraForward: Float32x3,
}
impl Default for FrameInterpolationPrepareDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationPrepare"]
    pub fn FrameInterpolationPrepare(
        context: *mut FrameInterpolationContext,
        params: *const FrameInterpolationPrepareDescription,
    ) -> ErrorCode;
}
impl FrameInterpolationDispatchFlags {
    #[doc = "< A bit indicating that the debug tear lines will be drawn to the interpolated output."]
    pub const DRAW_DEBUG_TEAR_LINES: FrameInterpolationDispatchFlags =
        FrameInterpolationDispatchFlags(1);
    #[doc = "< A bit indicating that the debug reset indicators will be drawn to the generated output."]
    pub const DRAW_DEBUG_RESET_INDICATORS: FrameInterpolationDispatchFlags =
        FrameInterpolationDispatchFlags(2);
    #[doc = "< A bit indicating that the interpolated output resource will contain debug views with relevant information."]
    pub const DRAW_DEBUG_VIEW: FrameInterpolationDispatchFlags = FrameInterpolationDispatchFlags(4);
    #[doc = "< A bit indicating that the debug pacing lines will be drawn to the generated output."]
    pub const DRAW_DEBUG_PACING_LINES: FrameInterpolationDispatchFlags =
        FrameInterpolationDispatchFlags(8);
    pub const RESERVED_1: FrameInterpolationDispatchFlags = FrameInterpolationDispatchFlags(16);
    pub const RESERVED_2: FrameInterpolationDispatchFlags = FrameInterpolationDispatchFlags(32);
}
impl ::std::ops::BitOr<FrameInterpolationDispatchFlags> for FrameInterpolationDispatchFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        FrameInterpolationDispatchFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for FrameInterpolationDispatchFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: FrameInterpolationDispatchFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<FrameInterpolationDispatchFlags> for FrameInterpolationDispatchFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        FrameInterpolationDispatchFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for FrameInterpolationDispatchFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: FrameInterpolationDispatchFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FrameInterpolationDispatchFlags(pub ::std::os::raw::c_int);
#[repr(C)]
pub struct FrameInterpolationDispatchDescription {
    #[doc = "< combination of FfxFrameInterpolationDispatchFlags"]
    pub flags: u32,
    #[doc = "< The <c><i>FfxCommandList</i></c> to record frame interpolation commands into."]
    pub commandList: CommandList,
    #[doc = "< The destination output dimensions"]
    pub displaySize: Dimensions2D,
    #[doc = "< The dimensions used to render game content, dilatedDepth, dilatedMotionVectors are expected to be of ths size."]
    pub renderSize: Dimensions2D,
    #[doc = "< The current presentation color, if currentBackBuffer_HUDLess is not used, this will be used as interpolation source data."]
    pub currentBackBuffer: Resource,
    #[doc = "< The current presentation color without HUD content, when use it will be used as interpolation source data."]
    pub currentBackBuffer_HUDLess: Resource,
    #[doc = "< The output resource where to store the interpolated result."]
    pub output: Resource,
    #[doc = "< The area of the backbuffer that should be used for interpolation in case only a part of the screen is used e.g. due to movie bars"]
    pub interpolationRect: Rect2D,
    #[doc = "< The optical flow motion vectors (see example computation in the FfxOpticalFlow effect)"]
    pub opticalFlowVector: Resource,
    #[doc = "< The optical flow scene change detection data"]
    pub opticalFlowSceneChangeDetection: Resource,
    #[doc = "< The optical flow motion vector resource dimensions"]
    pub opticalFlowBufferSize: Dimensions2D,
    #[doc = "< The optical flow motion vector scale factor, used to scale resoure values into [0.0,1.0] range."]
    pub opticalFlowScale: FloatCoords2D,
    #[doc = "< The optical flow block dimension size"]
    pub opticalFlowBlockSize: ::std::os::raw::c_int,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The unit to scale view space coordinates to meters."]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The transfer function use to convert interpolation source color data to linear RGB."]
    pub backBufferTransferFunction: BackbufferTransferFunction,
    #[doc = "< Min and max luminance values, used when converting HDR colors to linear RGB"]
    pub minMaxLuminance: [f32; 2usize],
    #[doc = "< Identifier used to select internal resources when async support is enabled. Must increment by exactly one (1) for each frame. Any non-exactly-one difference will reset the frame generation logic."]
    pub frameID: u64,
    #[doc = "< The dilated depth buffer data"]
    pub dilatedDepth: Resource,
    #[doc = "< The dilated motion vector data"]
    pub dilatedMotionVectors: Resource,
    #[doc = "< The reconstructed depth buffer data"]
    pub reconstructedPrevDepth: Resource,
    #[doc = "< A resource containing distortion offset data used when distortion post effects are enabled."]
    pub distortionField: Resource,
}
impl Default for FrameInterpolationDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationDispatch"]
    pub fn FrameInterpolationDispatch(
        context: *mut FrameInterpolationContext,
        params: *const FrameInterpolationDispatchDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationContextDestroy"]
    pub fn FrameInterpolationContextDestroy(context: *mut FrameInterpolationContext) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Queries the effect version number.\n\n @returns\n The SDK version the effect was built with.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationGetEffectVersion"]
    pub fn FrameInterpolationGetEffectVersion() -> VersionNumber;
}
unsafe extern "C" {
    #[doc = " Set global debug message settings\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationSetGlobalDebugMessage"]
    pub fn FrameInterpolationSetGlobalDebugMessage(
        fpMessage: MessageCallback,
        debugLevel: u32,
    ) -> ErrorCode;
}
