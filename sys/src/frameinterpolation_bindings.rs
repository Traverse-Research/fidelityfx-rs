/* automatically generated by rust-bindgen 0.72.1 */

pub const FRAMEINTERPOLATION_VERSION_MAJOR: u32 = 1;
pub const FRAMEINTERPOLATION_VERSION_MINOR: u32 = 0;
pub const FRAMEINTERPOLATION_VERSION_PATCH: u32 = 0;
pub const FRAMEINTERPOLATION_CONTEXT_COUNT: u32 = 1;
pub const FRAMEINTERPOLATION_CONTEXT_SIZE: u32 = 131072;
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the passes which constitute the FSR3 algorithm.\n\n FSR3 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr3ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr3Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR3\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR3_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR3_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr3Context</i></c> is created and the\n precise contents of <c><i>FfxFsr3DispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr3ContextDispatch</i></c>.\n\n @ingroup FRAMEINTERPOLATIONFRAMEINTERPOLATION"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FrameInterpolationPass {
    SETUP = 0,
    RECONSTRUCT_PREV_DEPTH = 1,
    GAME_MOTION_VECTOR_FIELD = 2,
    OPTICAL_FLOW_VECTOR_FIELD = 3,
    DISOCCLUSION_MASK = 4,
    INTERPOLATION = 5,
    INPAINTING_PYRAMID = 6,
    INPAINTING = 7,
    GAME_VECTOR_FIELD_INPAINTING_PYRAMID = 8,
    DEBUG_VIEW = 9,
    #[doc = "< The number of passes performed by FrameInterpolation."]
    COUNT = 10,
}
impl FrameInterpolationInitializationFlagBits {
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const ENABLE_DEPTH_INVERTED: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(1);
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const ENABLE_DEPTH_INFINITE: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(2);
    #[doc = "< A bit indicating that the backend should use 1D textures."]
    pub const ENABLE_TEXTURE1D_USAGE: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(4);
    #[doc = "< A bit indicating that HDR values are present in the imaging pipeline."]
    pub const ENABLE_HDR_COLOR_INPUT: FrameInterpolationInitializationFlagBits =
        FrameInterpolationInitializationFlagBits(8);
}
impl ::std::ops::BitOr<FrameInterpolationInitializationFlagBits>
    for FrameInterpolationInitializationFlagBits
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        FrameInterpolationInitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for FrameInterpolationInitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: FrameInterpolationInitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<FrameInterpolationInitializationFlagBits>
    for FrameInterpolationInitializationFlagBits
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        FrameInterpolationInitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for FrameInterpolationInitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: FrameInterpolationInitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFrameInterpolationContext</i></c>. See <c><i>FfxFrameInterpolationContextDescription</i></c>.\n\n @ingroup FRAMEINTERPOLATIONFRAMEINTERPOLATION"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FrameInterpolationInitializationFlagBits(pub ::std::os::raw::c_int);
#[doc = " A structure encapsulating the parameters required to initialize\n FidelityFX Frameinterpolation upscaling.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
pub struct FrameInterpolationContextDescription {
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
    #[doc = "< A collection of <c><i>FfxFrameInterpolationInitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution"]
    pub displaySize: Dimensions2D,
    pub backBufferFormat: SurfaceFormat,
}
impl Default for FrameInterpolationContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 2 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3Context</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FrameInterpolationContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for FrameInterpolationContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 2 context from the parameters\n programmed to the <c><i>FfxFsr3CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3Context</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3Context</i></c> is created, you should use the\n <c><i>ffxFsr3ContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr3ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationContextCreate"]
    pub fn FrameInterpolationContextCreate(
        context: *mut FrameInterpolationContext,
        contextDescription: *mut FrameInterpolationContextDescription,
    ) -> ErrorCode;
}
impl FrameInterpolationDispatchFlags {
    #[doc = "< A bit indicating that the debug tear lines will be drawn to the interpolated output."]
    pub const DRAW_DEBUG_TEAR_LINES: FrameInterpolationDispatchFlags =
        FrameInterpolationDispatchFlags(1);
    #[doc = "< A bit indicating that the interpolated output resource will contain debug views with relevant information."]
    pub const DRAW_DEBUG_VIEW: FrameInterpolationDispatchFlags = FrameInterpolationDispatchFlags(2);
}
impl ::std::ops::BitOr<FrameInterpolationDispatchFlags> for FrameInterpolationDispatchFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        FrameInterpolationDispatchFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for FrameInterpolationDispatchFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: FrameInterpolationDispatchFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<FrameInterpolationDispatchFlags> for FrameInterpolationDispatchFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        FrameInterpolationDispatchFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for FrameInterpolationDispatchFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: FrameInterpolationDispatchFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FrameInterpolationDispatchFlags(pub ::std::os::raw::c_int);
#[repr(C)]
pub struct FrameInterpolationDispatchDescription {
    #[doc = "< combination of FfxFrameInterpolationDispatchFlags"]
    pub flags: u32,
    #[doc = "< The <c><i>FfxCommandList</i></c> to record frame interpolation commands into."]
    pub commandList: CommandList,
    #[doc = "< The destination output dimensions"]
    pub displaySize: Dimensions2D,
    #[doc = "< The dimensions used to render game content, dilatedDepth, dilatedMotionVectors are expected to be of ths size."]
    pub renderSize: Dimensions2D,
    #[doc = "< The current presentation color, if currentBackBuffer_HUDLess is not used, this will be used as interpolation source data."]
    pub currentBackBuffer: Resource,
    #[doc = "< The current presentation color without HUD content, when use it will be used as interpolation source data."]
    pub currentBackBuffer_HUDLess: Resource,
    #[doc = "< The output resource where to store the interpolated result."]
    pub output: Resource,
    #[doc = "< The dilated depth buffer data (see example computation in the FfxFsr3Upscaler effect)"]
    pub dilatedDepth: Resource,
    #[doc = "< The dilated motion vector data (see example computation in the FfxFsr3Upscaler effect)"]
    pub dilatedMotionVectors: Resource,
    #[doc = "< The estimated previous frame depth buffer (see example computation in the FfxFsr3Upscaler effect)"]
    pub reconstructPrevNearDepth: Resource,
    #[doc = "< The area of the backbuffer that should be used for interpolation in case only a part of the screen is used e.g. due to movie bars"]
    pub interpolationRect: Rect2D,
    #[doc = "< The optical flow motion vectors (see example computation in the FfxOpticalFlow effect)"]
    pub opticalFlowVector: Resource,
    #[doc = "< The optical flow scene change detection data"]
    pub opticalFlowSceneChangeDetection: Resource,
    #[doc = "< The optical flow motion vector resource dimensions"]
    pub opticalFlowBufferSize: Dimensions2D,
    #[doc = "< The optical flow motion vector scale factor, used to scale resoure values into [0.0,1.0] range."]
    pub opticalFlowScale: FloatCoords2D,
    #[doc = "< The optical flow block dimension size"]
    pub opticalFlowBlockSize: ::std::os::raw::c_int,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The unit to scale view space coordinates to meters."]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The transfer function use to convert interpolation source color data to linear RGB."]
    pub backBufferTransferFunction: BackbufferTransferFunction,
    #[doc = "< Min and max luminance values, used when converting HDR colors to linear RGB"]
    pub minMaxLuminance: [f32; 2usize],
}
impl Default for FrameInterpolationDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationDispatch"]
    pub fn FrameInterpolationDispatch(
        context: *mut FrameInterpolationContext,
        params: *const FrameInterpolationDispatchDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationContextDestroy"]
    pub fn FrameInterpolationContextDestroy(context: *mut FrameInterpolationContext) -> ErrorCode;
}
