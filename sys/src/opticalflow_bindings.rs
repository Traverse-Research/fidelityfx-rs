/* automatically generated by rust-bindgen 0.72.1 */

pub const OPTICALFLOW_VERSION_MAJOR: u32 = 1;
pub const OPTICALFLOW_VERSION_MINOR: u32 = 0;
pub const OPTICALFLOW_VERSION_PATCH: u32 = 0;
pub const OPTICALFLOW_CONTEXT_COUNT: u32 = 1;
pub const OPTICALFLOW_CONTEXT_SIZE: u32 = 131072;
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the passes which constitute the OpticalFlow algorithm.\n\n @ingroup ffxOpticalflow"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OpticalflowPass {
    PREPARE_LUMA = 0,
    GENERATE_OPTICAL_FLOW_INPUT_PYRAMID = 1,
    GENERATE_SCD_HISTOGRAM = 2,
    COMPUTE_SCD_DIVERGENCE = 3,
    COMPUTE_OPTICAL_FLOW_ADVANCED_V5 = 4,
    FILTER_OPTICAL_FLOW_V5 = 5,
    SCALE_OPTICAL_FLOW_ADVANCED_V5 = 6,
    COUNT = 7,
}
impl OpticalflowInitializationFlagBits {
    pub const ENABLE_TEXTURE1D_USAGE: OpticalflowInitializationFlagBits =
        OpticalflowInitializationFlagBits(1);
}
impl ::std::ops::BitOr<OpticalflowInitializationFlagBits> for OpticalflowInitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        OpticalflowInitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for OpticalflowInitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: OpticalflowInitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<OpticalflowInitializationFlagBits> for OpticalflowInitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        OpticalflowInitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for OpticalflowInitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: OpticalflowInitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxOpticalflowContext</i></c>. See <c><i>FfxOpticalflowDispatchDescription</i></c>.\n\n @ingroup ffxOpticalflow"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OpticalflowInitializationFlagBits(pub ::std::os::raw::c_int);
#[doc = " A structure encapsulating the parameters required to initialize\n FidelityFX OpticalFlow.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
pub struct OpticalflowContextDescription {
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
    #[doc = "< A collection of <c><i>FfxOpticalflowInitializationFlagBits</i></c>."]
    pub flags: u32,
    pub resolution: Dimensions2D,
}
impl Default for OpticalflowContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Opticalflow.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
pub struct OpticalflowDispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the input color buffer"]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output motion buffer"]
    pub opticalFlowVector: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output scene change detection buffer"]
    pub opticalFlowSCD: Resource,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    pub backbufferTransferFunction: ::std::os::raw::c_int,
    pub minMaxLuminance: FloatCoords2D,
}
impl Default for OpticalflowDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct OpticalflowSharedResourceDescriptions {
    pub opticalFlowVector: CreateResourceDescription,
    pub opticalFlowSCD: CreateResourceDescription,
}
impl Default for OpticalflowSharedResourceDescriptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX OpticalFlow context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by OpticalFlow.\n\n The <c><i>FfxOpticalflowContext</i></c> object should have a lifetime matching\n your use of OpticalFlow. Before destroying the OpticalFlow context care should be taken\n to ensure the GPU is not accessing the resources created or used by OpticalFlow.\n It is therefore recommended that the GPU is idle before destroying OpticalFlow\n OpticalFlow context.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpticalflowContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for OpticalflowContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create a FidelityFX OpticalFlow context from the parameters\n programmed to the <c><i>FfxOpticalflowContextDescription</i></c> structure.\n\n The context structure is the main object used to interact with the OpticalFlow\n API, and is responsible for the management of the internal resources used\n by the OpticalFlow algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by OpticalFlow's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxOpticalflowContext</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxOpticalflowContext</i></c> how match the configuration of your\n application as well as the intended use of OpticalFlow. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxOpticalflowContextDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how OpticalFlow should be integerated into an application.\n\n When the <c><i>FfxOpticalflowContext</i></c> is created, you should use the\n <c><i>ffxOpticalflowContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxOpticalflowContextDispatch</i></c> for more details.\n\n The <c><i>FfxOpticalflowContext</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or OpticalFlow is\n disabled by a user. To destroy the OpticalFlow context you should call\n <c><i>ffxOpticalflowContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxOpticalflowContext</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxOpticalflowContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxOpticalflowContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxOpticalflow"]
    #[link_name = "\u{1}ffxOpticalflowContextCreate"]
    pub fn OpticalflowContextCreate(
        context: *mut OpticalflowContext,
        contextDescription: *mut OpticalflowContextDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxOpticalflowGetSharedResourceDescriptions"]
    pub fn OpticalflowGetSharedResourceDescriptions(
        context: *mut OpticalflowContext,
        SharedResources: *mut OpticalflowSharedResourceDescriptions,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxOpticalflowContextDispatch"]
    pub fn OpticalflowContextDispatch(
        context: *mut OpticalflowContext,
        dispatchDescription: *const OpticalflowDispatchDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Destroy the FidelityFX OpticalFlow context.\n\n @param [out] context                A pointer to a <c><i>FfxOpticalflowContext</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup ffxOpticalflow"]
    #[link_name = "\u{1}ffxOpticalflowContextDestroy"]
    pub fn OpticalflowContextDestroy(context: *mut OpticalflowContext) -> ErrorCode;
}
