/* automatically generated by rust-bindgen 0.72.1 */

#[doc = " FFX specific callback type when submitting a command buffer to a queue."]
pub type PFN_vkQueueSubmitFFX = ::std::option::Option<
    unsafe extern "C" fn(
        submitCount: u32,
        pSubmits: *const VkSubmitInfo,
        fence: VkFence,
    ) -> VkResult,
>;
#[repr(C)]
pub struct VkQueueInfoFFX {
    pub queue: VkQueue,
    pub familyIndex: u32,
    pub submitFunc: PFN_vkQueueSubmitFFX,
}
impl Default for VkQueueInfoFFX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VkCompositonModeFFX {
    VK_COMPOSITION_MODE_NOT_FORCED_FFX = 0,
    VK_COMPOSITION_MODE_GAME_QUEUE_FFX = 1,
    VK_COMPOSITION_MODE_PRESENT_QUEUE_FFX = 2,
}
#[doc = " Structure holding additional information to effectively replace the game swapchain by the frame interpolation one.\n Some notes on the queues:\n   - please pass the queue, its family (for queue family ownership transfer purposes) and an optional function if you want to control concurrent submissions\n   - game queue: the queue where the replacement of vkQueuePresentKHR is called. This queue should have Graphics and Compute capabilities (Transfer is implied as per Vulkan specification).\n                  It can be shared with the engine. No Submit function is necessary.\n                 The code assumes that the UI texture is owned by that queue family when present is called.\n   - async compute queue: optional queue with Compute capability (Transfer is implied as per Vulkan specification). If used by the engine, prefer not to enable the async compute path of FSR3 Frame interpolation.\n   - present queue: queue with Graphics, Compute or Transfer capability, and Present support. This queue cannot be used by the engine. Otherwise, some deadlock can occur.\n   - image acquire queue: this one doesn't need any capability. Strongly prefer a queue not used by the engine. The main graphics queue can work too but it might delay the signaling of the semaphore/fence when acquiring a new image, negatively impacting the performance."]
#[repr(C)]
pub struct VkFrameInterpolationInfoFFX {
    pub physicalDevice: VkPhysicalDevice,
    pub device: VkDevice,
    pub gameQueue: VkQueueInfoFFX,
    pub asyncComputeQueue: VkQueueInfoFFX,
    pub presentQueue: VkQueueInfoFFX,
    pub imageAcquireQueue: VkQueueInfoFFX,
    pub compositionMode: VkCompositonModeFFX,
    pub pAllocator: *const VkAllocationCallbacks,
}
impl Default for VkFrameInterpolationInfoFFX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Query how much memory is required for the Vulkan backend's scratch buffer.\n\n @param [in] physicalDevice              A pointer to the VkPhysicalDevice device.\n @param [in] maxContexts                 The maximum number of simultaneous effect contexts that will share the backend.\n                                         (Note that some effects contain internal contexts which count towards this maximum)\n\n @returns\n The size (in bytes) of the required scratch memory buffer for the VK backend.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetScratchMemorySizeVK"]
    pub fn GetScratchMemorySizeVK(physicalDevice: VkPhysicalDevice, maxContexts: usize) -> usize;
}
#[doc = " Convenience structure to hold all VK-related device information"]
#[repr(C)]
pub struct VkDeviceContext {
    pub vkDevice: VkDevice,
    #[doc = " The Vulkan device"]
    pub vkPhysicalDevice: VkPhysicalDevice,
    #[doc = " The Vulkan physical device"]
    pub vkDeviceProcAddr: PFN_vkGetDeviceProcAddr,
}
impl Default for VkDeviceContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create a <c><i>FfxDevice</i></c> from a <c><i>VkDevice</i></c>.\n\n @param [in] vkDeviceContext             A pointer to a VKDeviceContext that holds all needed information\n\n @returns\n An abstract FidelityFX device.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetDeviceVK"]
    pub fn GetDeviceVK(vkDeviceContext: *mut VkDeviceContext) -> Device;
}
unsafe extern "C" {
    #[doc = " Populate an interface with pointers for the VK backend.\n\n @param [out] backendInterface           A pointer to a <c><i>FfxInterface</i></c> structure to populate with pointers.\n @param [in] device                      A pointer to the VkDevice device.\n @param [in] scratchBuffer               A pointer to a buffer of memory which can be used by the DirectX(R)12 backend.\n @param [in] scratchBufferSize           The size (in bytes) of the buffer pointed to by <c><i>scratchBuffer</i></c>.\n @param [in] maxContexts                 The maximum number of simultaneous effect contexts that will share the backend.\n                                         (Note that some effects contain internal contexts which count towards this maximum)\n\n @retval\n FFX_OK                                  The operation completed successfully.\n @retval\n FFX_ERROR_CODE_INVALID_POINTER          The <c><i>interface</i></c> pointer was <c><i>NULL</i></c>.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetInterfaceVK"]
    pub fn GetInterfaceVK(
        backendInterface: *mut Interface,
        device: Device,
        scratchBuffer: *mut ::std::os::raw::c_void,
        scratchBufferSize: usize,
        maxContexts: usize,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Create a <c><i>FfxCommandList</i></c> from a <c><i>VkCommandBuffer</i></c>.\n\n @param [in] cmdBuf                      A pointer to the Vulkan command buffer.\n\n @returns\n An abstract FidelityFX command list.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetCommandListVK"]
    pub fn GetCommandListVK(cmdBuf: VkCommandBuffer) -> CommandList;
}
unsafe extern "C" {
    #[doc = " Create a <c><i>FfxPipeline</i></c> from a <c><i>VkPipeline</i></c>.\n\n @param [in] pipeline                    A pointer to the Vulkan pipeline.\n\n @returns\n An abstract FidelityFX pipeline.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetPipelineVK"]
    pub fn GetPipelineVK(pipeline: VkPipeline) -> Pipeline;
}
unsafe extern "C" {
    #[doc = " Fetch a <c><i>FfxResource</i></c> from a <c><i>GPUResource</i></c>.\n\n @param [in] vkResource                  A pointer to the (agnostic) VK resource.\n @param [in] ffxResDescription           An <c><i>FfxResourceDescription</i></c> for the resource representation.\n @param [in] ffxResName                  (optional) A name string to identify the resource in debug mode.\n @param [in] state                       The state the resource is currently in.\n\n @returns\n An abstract FidelityFX resources.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetResourceVK"]
    pub fn GetResourceVK(
        vkResource: *mut ::std::os::raw::c_void,
        ffxResDescription: ResourceDescription,
        ffxResName: *const u16,
        state: ResourceStates,
    ) -> Resource;
}
unsafe extern "C" {
    #[doc = " Fetch a <c><i>FfxSurfaceFormat</i></c> from a VkFormat.\n\n @param [in] format              The VkFormat to convert to <c><i>FfxSurfaceFormat</i></c>.\n\n @returns\n An <c><i>FfxSurfaceFormat</i></c>.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetSurfaceFormatVK"]
    pub fn GetSurfaceFormatVK(format: VkFormat) -> SurfaceFormat;
}
unsafe extern "C" {
    #[doc = " Fetch a <c><i>FfxResourceDescription</i></c> from an existing VkBuffer.\n\n @param [in] buffer              The VkBuffer resource to create a <c><i>FfxResourceDescription</i></c> for.\n @param [in] createInfo          The VkBufferCreateInfo of the buffer\n @param [in] additionalUsages    Optional <c><i>FfxResourceUsage</i></c> flags needed for select resource mapping.\n\n @returns\n An <c><i>FfxResourceDescription</i></c>.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetBufferResourceDescriptionVK"]
    pub fn GetBufferResourceDescriptionVK(
        buffer: VkBuffer,
        createInfo: VkBufferCreateInfo,
        additionalUsages: ResourceUsage,
    ) -> ResourceDescription;
}
unsafe extern "C" {
    #[doc = " Fetch a <c><i>FfxResourceDescription</i></c> from an existing VkImage.\n\n @param [in] image               The VkImage resource to create a <c><i>FfxResourceDescription</i></c> for.\n @param [in] createInfo          The VkImageCreateInfo of the buffer\n @param [in] additionalUsages    Optional <c><i>FfxResourceUsage</i></c> flags needed for select resource mapping.\n\n @returns\n An <c><i>FfxResourceDescription</i></c>.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetImageResourceDescriptionVK"]
    pub fn GetImageResourceDescriptionVK(
        image: VkImage,
        createInfo: VkImageCreateInfo,
        additionalUsages: ResourceUsage,
    ) -> ResourceDescription;
}
unsafe extern "C" {
    #[doc = " Fetch a <c><i>FfxCommandQueue</i></c> from an existing VkQueue.\n\n @param [in] commandQueue       The VkQueue to create a <c><i>FfxCommandQueue</i></c> from.\n\n @returns\n An <c><i>FfxCommandQueue</i></c>.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetCommandQueueVK"]
    pub fn GetCommandQueueVK(commandQueue: VkQueue) -> CommandQueue;
}
unsafe extern "C" {
    #[doc = " Fetch a <c><i>FfxSwapchain</i></c> from an existing VkSwapchainKHR.\n\n @param [in] pSwapchain          The VkSwapchainKHR to create a <c><i>FfxSwapchain</i></c> from.\n\n @returns\n An <c><i>FfxSwapchain</i></c>.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetSwapchainVK"]
    pub fn GetSwapchainVK(swapchain: VkSwapchainKHR) -> Swapchain;
}
unsafe extern "C" {
    #[doc = " Fetch a VkSwapchainKHR from an existing <c><i>FfxSwapchain</i></c>.\n\n @param [in] ffxSwapchain          The <c><i>FfxSwapchain</i></c> to fetch an VkSwapchainKHR from.\n\n @returns\n An VkSwapchainKHR object.\n\n @ingroup VKBackend"]
    #[link_name = "\u{1}ffxGetVKSwapchain"]
    pub fn GetVKSwapchain(ffxSwapchain: Swapchain) -> VkSwapchainKHR;
}
unsafe extern "C" {
    #[doc = " Replaces the current swapchain with the provided <c><i>FfxSwapchain</i></c>.\n\n @param [in]     gameQueue               The <c><i>FfxCommandQueue</i></c> presentation will occur on.\n @param [in,out] gameSwapChain           The current <c><i>FfxSwapchain</i></c> to replace, optional. If not NULL, the swapchain will be destroyed. On return, it will hold the <c><i>FfxSwapchain</i></c> to use for frame interpolation presentation.\n @param [in]     swapchainCreateInfo     The <c><i>VkSwapchainCreateInfoKHR</i></c> of the current swapchain. Its oldSwapchain member should be VK_NULL_HANDLE or the same as gameSwapChain.\n @param [in]     frameInterpolationInfo  The <c><i>VkFrameInterpolationInfoFFX</i></c> containing additional information for swapchain replacement.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          One of the parameters is invalid. If the returned <c><i>gameSwapChain</i></c> is NULL, the old swapchain has been destroyed.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         Internal generic error. If the returned <c><i>gameSwapChain</i></c> is NULL, the old swapchain has been destroyed.\n\n @ingroup VKFrameInterpolation"]
    #[link_name = "\u{1}ffxReplaceSwapchainForFrameinterpolationVK"]
    pub fn ReplaceSwapchainForFrameinterpolationVK(
        gameQueue: CommandQueue,
        gameSwapChain: *mut Swapchain,
        swapchainCreateInfo: *const VkSwapchainCreateInfoKHR,
        frameInterpolationInfo: *const VkFrameInterpolationInfoFFX,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Waits for the <c><i>FfxSwapchain</i></c> to complete presentation.\n\n @param [in] gameSwapChain           The <c><i>FfxSwapchain</i></c> to wait on.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Could not query the interface for the frame interpolation swap chain.\n\n @ingroup VKFrameInterpolation"]
    #[link_name = "\u{1}ffxWaitForPresents"]
    pub fn WaitForPresents(gameSwapChain: Swapchain) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Registers a <c><i>FfxResource</i></c> to use for UI with the provided <c><i>FfxSwapchain</i></c>.\n\n @param [in] gameSwapChain           The <c><i>FfxSwapchain</i></c> to to register the UI resource with.\n @param [in] uiResource              The <c><i>FfxResource</i></c> representing the UI resource.\n @param [in] flags                   A set of <c><i>FfxUiCompositionFlags</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Could not query the interface for the frame interpolation swap chain.\n\n @ingroup VKFrameInterpolation"]
    #[link_name = "\u{1}ffxRegisterFrameinterpolationUiResourceVK"]
    pub fn RegisterFrameinterpolationUiResourceVK(
        gameSwapChain: Swapchain,
        uiResource: Resource,
        flags: u32,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Fetches a <c><i>FfxCommandList</i></c> from the <c><i>FfxSwapchain</i></c>.\n\n @param [in] gameSwapChain           The <c><i>FfxSwapchain</i></c> to get a <c><i>FfxCommandList</i></c> from.\n @param [out] gameCommandlist        The <c><i>FfxCommandList</i></c> from the provided <c><i>FfxSwapchain</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Could not query the interface for the frame interpolation swap chain.\n\n @ingroup VKFrameInterpolation"]
    #[link_name = "\u{1}ffxGetFrameinterpolationCommandlistVK"]
    pub fn GetFrameinterpolationCommandlistVK(
        gameSwapChain: Swapchain,
        gameCommandlist: *mut CommandList,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Fetches a <c><i>FfxResource</i></c>  representing the backbuffer from the <c><i>FfxSwapchain</i></c>.\n\n @param [in] gameSwapChain           The <c><i>FfxSwapchain</i></c> to get a <c><i>FfxResource</i></c> backbuffer from.\n\n @returns\n An abstract FidelityFX resources for the swapchain backbuffer.\n\n @ingroup VKFrameInterpolation"]
    #[link_name = "\u{1}ffxGetFrameinterpolationTextureVK"]
    pub fn GetFrameinterpolationTextureVK(gameSwapChain: Swapchain) -> Resource;
}
unsafe extern "C" {
    #[doc = " Sets a <c><i>FfxFrameGenerationConfig</i></c> to the internal FrameInterpolationSwapChain (in the backend).\n\n @param [in] config                  The <c><i>FfxFrameGenerationConfig</i></c> to set.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Could not query the interface for the frame interpolation swap chain.\n\n @ingroup VKFrameInterpolation"]
    #[link_name = "\u{1}ffxSetFrameGenerationConfigToSwapchainVK"]
    pub fn SetFrameGenerationConfigToSwapchainVK(config: *const FrameGenerationConfig)
    -> ErrorCode;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FrameInterpolationSwapchainConfigureKey {
    WAITCALLBACK = 0,
    FRAMEPACINGTUNING = 2,
}
unsafe extern "C" {
    #[doc = " Configures <c><i>FfxSwapchain</i></c> via KeyValue API post <c><i>FfxSwapchain</i></c> context creation\n\n @param [in] gameSwapChain           The <c><i>FfxSwapchain</i></c> to configure via KeyValue API\n @param [in] key                     The <c><i>FfxFrameInterpolationSwapchainConfigureKey</i></c> is key\n @param [in] valuePtr                The <c><i><void *></i></c> pointer to value. What this pointer deference to depends on key.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Could not query the interface for the frame interpolation swap chain.\n\n @ingroup VKFrameInterpolation"]
    #[link_name = "\u{1}ffxConfigureFrameInterpolationSwapchainVK"]
    pub fn ConfigureFrameInterpolationSwapchainVK(
        gameSwapChain: Swapchain,
        key: FrameInterpolationSwapchainConfigureKey,
        valuePtr: *mut ::std::os::raw::c_void,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Query how much GPU memory created by <c><i>FfxSwapchain</i></c>. This excludes GPU memory created by the VkSwapchain (ie. size of backbuffers).\n\n @param [in] gameSwapChain           The <c><i>FfxSwapchain</i></c> to configure via KeyValue API\n @param [in out] vramUsage           The <c><i>FfxEffectMemoryUsage</i></c> is the GPU memory created by FrameInterpolationSwapchain\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Could not query the interface for the frame interpolation swap chain.\n\n @ingroup VKFrameInterpolation"]
    #[link_name = "\u{1}ffxFrameInterpolationSwapchainGetGpuMemoryUsageVK"]
    pub fn FrameInterpolationSwapchainGetGpuMemoryUsageVK(
        gameSwapChain: Swapchain,
        vramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
pub type PFN_vkCreateSwapchainFFX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR,
        pFrameInterpolationInfo: *const VkFrameInterpolationInfoFFX,
    ) -> VkResult,
>;
#[doc = " Function to get he number of presents. This is useful when using frame interpolation"]
pub type PFN_getLastPresentCountFFX =
    ::std::option::Option<unsafe extern "C" fn(arg1: VkSwapchainKHR) -> u64>;
#[doc = " Structure holding the replacement function pointers for frame interpolation to work\n Not all extensions are supported for now\n Regarding specific functions:\n   - queuePresentKHR: when using this one, the presenting image should be in VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL state\n   - getLastPresentCount: this function isn't part of Vulkan but the engine can use it to get the real number of presented frames since the swapchain creation"]
#[repr(C)]
pub struct SwapchainReplacementFunctions {
    pub createSwapchainFFX: PFN_vkCreateSwapchainFFX,
    pub destroySwapchainKHR: PFN_vkDestroySwapchainKHR,
    pub getSwapchainImagesKHR: PFN_vkGetSwapchainImagesKHR,
    pub acquireNextImageKHR: PFN_vkAcquireNextImageKHR,
    pub queuePresentKHR: PFN_vkQueuePresentKHR,
    pub setHdrMetadataEXT: PFN_vkSetHdrMetadataEXT,
    pub getLastPresentCountFFX: PFN_getLastPresentCountFFX,
}
impl Default for SwapchainReplacementFunctions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxGetSwapchainReplacementFunctionsVK"]
    pub fn GetSwapchainReplacementFunctionsVK(
        device: Device,
        functions: *mut SwapchainReplacementFunctions,
    ) -> ErrorCode;
}
