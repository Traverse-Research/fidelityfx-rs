/* automatically generated by rust-bindgen 0.72.1 */

#[doc = " Convenience structure to hold all VK-related device information"]
#[repr(C)]
pub struct VkDeviceContext {
    pub vkDevice: VkDevice,
    #[doc = " The Vulkan device"]
    pub vkPhysicalDevice: VkPhysicalDevice,
    #[doc = " The Vulkan physical device"]
    pub vkDeviceProcAddr: PFN_vkGetDeviceProcAddr,
}
impl Default for VkDeviceContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub struct Functions {
    __library: ::libloading::Library,
    pub GetScratchMemorySizeVK:
        unsafe extern "C" fn(physicalDevice: VkPhysicalDevice, maxContexts: usize) -> usize,
    pub GetDeviceVK: unsafe extern "C" fn(vkDeviceContext: *mut VkDeviceContext) -> Device,
    pub GetInterfaceVK: unsafe extern "C" fn(
        backendInterface: *mut Interface,
        device: Device,
        scratchBuffer: *mut ::std::os::raw::c_void,
        scratchBufferSize: usize,
        maxContexts: usize,
    ) -> ErrorCode,
    pub GetCommandListVK: unsafe extern "C" fn(cmdBuf: VkCommandBuffer) -> CommandList,
    pub GetResourceVK: unsafe extern "C" fn(
        vkResource: *mut ::std::os::raw::c_void,
        ffxResDescription: ResourceDescription,
        ffxResName: *mut u16,
        state: ResourceStates,
    ) -> Resource,
}
impl Functions {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let GetScratchMemorySizeVK = __library
            .get(b"ffxGetScratchMemorySizeVK\0")
            .map(|sym| *sym)?;
        let GetDeviceVK = __library.get(b"ffxGetDeviceVK\0").map(|sym| *sym)?;
        let GetInterfaceVK = __library.get(b"ffxGetInterfaceVK\0").map(|sym| *sym)?;
        let GetCommandListVK = __library.get(b"ffxGetCommandListVK\0").map(|sym| *sym)?;
        let GetResourceVK = __library.get(b"ffxGetResourceVK\0").map(|sym| *sym)?;
        Ok(Functions {
            __library,
            GetScratchMemorySizeVK,
            GetDeviceVK,
            GetInterfaceVK,
            GetCommandListVK,
            GetResourceVK,
        })
    }
    #[doc = " Query how much memory is required for the Vulkan backend's scratch buffer.\n\n @param [in] physicalDevice              A pointer to the VkPhysicalDevice device.\n @param [in] maxContexts                 The maximum number of simultaneous effect contexts that will share the backend.\n                                         (Note that some effects contain internal contexts which count towards this maximum)\n\n @returns\n The size (in bytes) of the required scratch memory buffer for the VK backend.\n\n @ingroup VKBackend"]
    pub unsafe fn GetScratchMemorySizeVK(
        &self,
        physicalDevice: VkPhysicalDevice,
        maxContexts: usize,
    ) -> usize {
        (self.GetScratchMemorySizeVK)(physicalDevice, maxContexts)
    }
    #[doc = " Create a <c><i>FfxDevice</i></c> from a <c><i>VkDevice</i></c>.\n\n @param [in] vkDeviceContext             A pointer to a VKDeviceContext that holds all needed information\n\n @returns\n An abstract FidelityFX device.\n\n @ingroup VKBackend"]
    pub unsafe fn GetDeviceVK(&self, vkDeviceContext: *mut VkDeviceContext) -> Device {
        (self.GetDeviceVK)(vkDeviceContext)
    }
    #[doc = " Populate an interface with pointers for the VK backend.\n\n @param [out] backendInterface           A pointer to a <c><i>FfxInterface</i></c> structure to populate with pointers.\n @param [in] device                      A pointer to the VkDevice device.\n @param [in] scratchBuffer               A pointer to a buffer of memory which can be used by the DirectX(R)12 backend.\n @param [in] scratchBufferSize           The size (in bytes) of the buffer pointed to by <c><i>scratchBuffer</i></c>.\n @param [in] maxContexts                 The maximum number of simultaneous effect contexts that will share the backend.\n                                         (Note that some effects contain internal contexts which count towards this maximum)\n\n @retval\n FFX_OK                                  The operation completed successfully.\n @retval\n FFX_ERROR_CODE_INVALID_POINTER          The <c><i>interface</i></c> pointer was <c><i>NULL</i></c>.\n\n @ingroup VKBackend"]
    pub unsafe fn GetInterfaceVK(
        &self,
        backendInterface: *mut Interface,
        device: Device,
        scratchBuffer: *mut ::std::os::raw::c_void,
        scratchBufferSize: usize,
        maxContexts: usize,
    ) -> ErrorCode {
        (self.GetInterfaceVK)(
            backendInterface,
            device,
            scratchBuffer,
            scratchBufferSize,
            maxContexts,
        )
    }
    #[doc = " Create a <c><i>FfxCommandList</i></c> from a <c><i>VkCommandBuffer</i></c>.\n\n @param [in] cmdBuf                      A pointer to the Vulkan command buffer.\n\n @returns\n An abstract FidelityFX command list.\n\n @ingroup VKBackend"]
    pub unsafe fn GetCommandListVK(&self, cmdBuf: VkCommandBuffer) -> CommandList {
        (self.GetCommandListVK)(cmdBuf)
    }
    #[doc = " Fetch a <c><i>FfxResource</i></c> from a <c><i>GPUResource</i></c>.\n\n @param [in] vkResource                  A pointer to the (agnostic) VK resource.\n @param [in] ffxResDescription           An <c><i>FfxResourceDescription</i></c> for the resource representation.\n @param [in] ffxResName                  (optional) A name string to identify the resource in debug mode.\n @param [in] state                       The state the resource is currently in.\n\n @returns\n An abstract FidelityFX resources.\n\n @ingroup VKBackend"]
    pub unsafe fn GetResourceVK(
        &self,
        vkResource: *mut ::std::os::raw::c_void,
        ffxResDescription: ResourceDescription,
        ffxResName: *mut u16,
        state: ResourceStates,
    ) -> Resource {
        (self.GetResourceVK)(vkResource, ffxResDescription, ffxResName, state)
    }
}
