/* automatically generated by rust-bindgen 0.72.1 */

pub const FSR3_VERSION_MAJOR: u32 = 3;
pub const FSR3_VERSION_MINOR: u32 = 1;
pub const FSR3_VERSION_PATCH: u32 = 4;
pub const FSR3_CONTEXT_COUNT: u32 = 4;
pub const FSR3_CONTEXT_SIZE: u32 = 524288;
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 2 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR3. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup FSR3"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Fsr3QualityMode {
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
    QUALITY = 1,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
    BALANCED = 2,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
    PERFORMANCE = 3,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
    ULTRA_PERFORMANCE = 4,
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating if the input color data provided to all inputs is using a high-dynamic range."]
    pub const ENABLE_HIGH_DYNAMIC_RANGE: Fsr3InitializationFlagBits = Fsr3InitializationFlagBits(1);
    #[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
    pub const ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(2);
    #[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
    pub const ENABLE_MOTION_VECTORS_JITTER_CANCELLATION: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(4);
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const ENABLE_DEPTH_INVERTED: Fsr3InitializationFlagBits = Fsr3InitializationFlagBits(8);
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const ENABLE_DEPTH_INFINITE: Fsr3InitializationFlagBits = Fsr3InitializationFlagBits(16);
    #[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
    pub const ENABLE_AUTO_EXPOSURE: Fsr3InitializationFlagBits = Fsr3InitializationFlagBits(32);
    #[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
    pub const ENABLE_DYNAMIC_RESOLUTION: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(64);
    #[doc = "< This value is deprecated, but remains in order to aid upgrading from older versions of FSR3."]
    pub const ENABLE_TEXTURE1D_USAGE: Fsr3InitializationFlagBits = Fsr3InitializationFlagBits(128);
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const ENABLE_DEBUG_CHECKING: Fsr3InitializationFlagBits = Fsr3InitializationFlagBits(256);
    pub const ENABLE_UPSCALING_ONLY: Fsr3InitializationFlagBits = Fsr3InitializationFlagBits(512);
    #[doc = ", A bit indicating that the context will only be used for upscaling"]
    pub const ENABLE_HDR_UPSCALE_SDR_FINALOUTPUT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(1024);
    #[doc = ", A bit indicating if the input color data provided to UPSCALE is using a high-dynamic range, final output SDR."]
    pub const ENABLE_SDR_UPSCALE_HDR_FINALOUTPUT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(2048);
    #[doc = ", A bit indicating if the input color data provided to UPSCALE is using SDR, final output is high-dynamic range."]
    pub const ENABLE_ASYNC_WORKLOAD_SUPPORT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(4096);
    #[doc = ", A bit indicating if the input color data provided to UPSCALE is using SDR, final output is high-dynamic range."]
    pub const ENABLE_INTERPOLATION_ONLY: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(8192);
}
impl ::std::ops::BitOr<Fsr3InitializationFlagBits> for Fsr3InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        Fsr3InitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for Fsr3InitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: Fsr3InitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<Fsr3InitializationFlagBits> for Fsr3InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Fsr3InitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for Fsr3InitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: Fsr3InitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr3Context</i></c>. See <c><i>FfxFsr3ContextDescription</i></c>.\n\n @ingroup FSR3"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Fsr3InitializationFlagBits(pub ::std::os::raw::c_int);
impl Fsr3FrameGenerationFlags {
    #[doc = "< A bit indicating that the debug tear lines will be drawn to the interpolated output."]
    pub const FLAG_DRAW_DEBUG_TEAR_LINES: Fsr3FrameGenerationFlags = Fsr3FrameGenerationFlags(1);
    #[doc = "< A bit indicating that the interpolated output resource will contain debug views with relevant information."]
    pub const FLAG_DRAW_DEBUG_VIEW: Fsr3FrameGenerationFlags = Fsr3FrameGenerationFlags(4);
    #[doc = "< A bit indicating that the debug pacing lines will be drawn to the generated output."]
    pub const FLAG_DRAW_DEBUG_PACING_LINES: Fsr3FrameGenerationFlags = Fsr3FrameGenerationFlags(8);
}
impl ::std::ops::BitOr<Fsr3FrameGenerationFlags> for Fsr3FrameGenerationFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        Fsr3FrameGenerationFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for Fsr3FrameGenerationFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: Fsr3FrameGenerationFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<Fsr3FrameGenerationFlags> for Fsr3FrameGenerationFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Fsr3FrameGenerationFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for Fsr3FrameGenerationFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: Fsr3FrameGenerationFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Fsr3FrameGenerationFlags(pub ::std::os::raw::c_int);
impl Fsr3UpscalingFlags {
    #[doc = "< A bit indicating that the upscaled output resource will contain debug views with relevant information."]
    pub const DRAW_DEBUG_VIEW: Fsr3UpscalingFlags = Fsr3UpscalingFlags(1);
}
impl ::std::ops::BitOr<Fsr3UpscalingFlags> for Fsr3UpscalingFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        Fsr3UpscalingFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for Fsr3UpscalingFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: Fsr3UpscalingFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<Fsr3UpscalingFlags> for Fsr3UpscalingFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Fsr3UpscalingFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for Fsr3UpscalingFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: Fsr3UpscalingFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Fsr3UpscalingFlags(pub ::std::os::raw::c_int);
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 3 upscaling.\n\n @ingroup FSR3"]
#[repr(C)]
pub struct Fsr3ContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr3InitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub maxUpscaleSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the frame interpolation process."]
    pub displaySize: Dimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceSharedResources: Interface,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceUpscaling: Interface,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceFrameInterpolation: Interface,
    #[doc = "< A pointer to a function that can receive messages from the runtime."]
    pub fpMessage: Fsr3UpscalerMessage,
    #[doc = "< The format of the swapchain surface"]
    pub backBufferFormat: SurfaceFormat,
}
impl Default for Fsr3ContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 3.\n\n @ingroup FSR3"]
#[repr(C)]
pub struct Fsr3DispatchUpscaleDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub upscaleOutput: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< The resolution that the upscaler will output."]
    pub upscaleSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< combination of FfxFsr3UpscalingFlags"]
    pub flags: u32,
    pub frameID: u64,
}
impl Default for Fsr3DispatchUpscaleDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct Fsr3DispatchFrameGenerationPrepareDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    pub frameTimeDelta: f32,
    pub cameraNear: f32,
    pub cameraFar: f32,
    pub viewSpaceToMetersFactor: f32,
    pub cameraFovAngleVertical: f32,
    pub frameID: u64,
}
impl Default for Fsr3DispatchFrameGenerationPrepareDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFsr3DispatchFrameGeneration"]
    pub fn Fsr3DispatchFrameGeneration(
        desc: *const FrameGenerationDispatchDescription,
    ) -> ErrorCode;
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup FSR3"]
#[repr(C)]
pub struct Fsr3GenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for Fsr3GenerateReactiveDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 3 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3Context</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3Context {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 524288usize],
}
impl Default for Fsr3Context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 3 context from the parameters\n programmed to the <c><i>FfxFsr3CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3Context</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3Context</i></c> is created, you should use the\n <c><i>ffxFsr3ContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr3ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextCreate"]
    pub fn Fsr3ContextCreate(
        context: *mut Fsr3Context,
        contextDescription: *mut Fsr3ContextDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFsr3ContextGetGpuMemoryUsage"]
    pub fn Fsr3ContextGetGpuMemoryUsage(
        pContext: *mut Fsr3Context,
        pUpscalerUsage: *mut EffectMemoryUsage,
        pOpticalFlowUsage: *mut EffectMemoryUsage,
        pFrameGenerationUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 3 Upscaling.\n\n FSR3 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr3ContextDispatchUpscale</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr3Context</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr3Context</i></c> correctly\n programming the <c><i>dispatchParams</i></c> is key to ensuring\n the correct operation of FSR3. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR3 provides the\n <c><i>ffxFsr3GetJitterPhaseCount</i></c> and\n <c><i>ffxFsr3GetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchParams</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr3GetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR3.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr3Context</i></c> structure.\n @param [in] dispatchParams     A pointer to a <c><i>FfxFsr3DispatchUpscaleDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchParams</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchParams.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextDispatchUpscale"]
    pub fn Fsr3ContextDispatchUpscale(
        context: *mut Fsr3Context,
        dispatchParams: *const Fsr3DispatchUpscaleDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFsr3ContextDispatchFrameGenerationPrepare"]
    pub fn Fsr3ContextDispatchFrameGenerationPrepare(
        context: *mut Fsr3Context,
        dispatchParams: *const Fsr3DispatchFrameGenerationPrepareDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFsr3SkipPresent"]
    pub fn Fsr3SkipPresent(context: *mut Fsr3Context) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr3Context</i></c> structure.\n @param [in] params                  A pointer to a <c><i>FfxFsr3GenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextGenerateReactiveMask"]
    pub fn Fsr3ContextGenerateReactiveMask(
        context: *mut Fsr3Context,
        params: *const Fsr3GenerateReactiveDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[link_name = "\u{1}ffxFsr3ConfigureFrameGeneration"]
    pub fn Fsr3ConfigureFrameGeneration(
        context: *mut Fsr3Context,
        config: *const FrameGenerationConfig,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextDestroy"]
    pub fn Fsr3ContextDestroy(context: *mut Fsr3Context) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR3_QUALITY_MODE_NATIVEAA</i></c>          | 1.0x\n <c><i>FFX_FSR3_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR3_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR3_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetUpscaleRatioFromQualityMode"]
    pub fn Fsr3GetUpscaleRatioFromQualityMode(qualityMode: Fsr3QualityMode) -> f32;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr3GetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] renderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] renderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetRenderResolutionFromQualityMode"]
    pub fn Fsr3GetRenderResolutionFromQualityMode(
        renderWidth: *mut u32,
        renderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: Fsr3QualityMode,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr3GetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR3_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR3_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR3_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetJitterPhaseCount"]
    pub fn Fsr3GetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR3 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR3 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr3GetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr3GetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr3GetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr3GetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr3GetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr3GetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr3GetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr3GetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr3DispatchParameters</i></c> structure in order to inform FSR3\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr3GetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] outX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] outY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr3GetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetJitterOffset"]
    pub fn Fsr3GetJitterOffset(
        outX: *mut f32,
        outY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ResourceIsNull"]
    pub fn Fsr3ResourceIsNull(resource: Resource) -> bool;
}
unsafe extern "C" {
    #[doc = " Queries the effect version number.\n\n @returns\n The SDK version the effect was built with.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetEffectVersion"]
    pub fn Fsr3GetEffectVersion() -> VersionNumber;
}
