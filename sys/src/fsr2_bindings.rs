/* automatically generated by rust-bindgen 0.72.1 */

pub const FSR2_VERSION_MAJOR: u32 = 2;
pub const FSR2_VERSION_MINOR: u32 = 2;
pub const FSR2_VERSION_PATCH: u32 = 2;
pub const FSR2_CONTEXT_COUNT: u32 = 1;
pub const FSR2_CONTEXT_SIZE: u32 = 131072;
#[doc = "< A pass which performs depth clipping."]
pub const FFX_FSR2_PASS_DEPTH_CLIP: Fsr2Pass = 0;
#[doc = "< A pass which performs reconstruction of previous frame's depth."]
pub const FFX_FSR2_PASS_RECONSTRUCT_PREVIOUS_DEPTH: Fsr2Pass = 1;
#[doc = "< A pass which calculates pixel locks."]
pub const FFX_FSR2_PASS_LOCK: Fsr2Pass = 2;
#[doc = "< A pass which performs upscaling."]
pub const FFX_FSR2_PASS_ACCUMULATE: Fsr2Pass = 3;
#[doc = "< A pass which performs upscaling when sharpening is used."]
pub const FFX_FSR2_PASS_ACCUMULATE_SHARPEN: Fsr2Pass = 4;
#[doc = "< A pass which performs sharpening."]
pub const FFX_FSR2_PASS_RCAS: Fsr2Pass = 5;
#[doc = "< A pass which generates the luminance mipmap chain for the current frame."]
pub const FFX_FSR2_PASS_COMPUTE_LUMINANCE_PYRAMID: Fsr2Pass = 6;
#[doc = "< An optional pass to generate a reactive mask."]
pub const FFX_FSR2_PASS_GENERATE_REACTIVE: Fsr2Pass = 7;
#[doc = "< An optional pass to automatically generate transparency/composition and reactive masks."]
pub const FFX_FSR2_PASS_TCR_AUTOGENERATE: Fsr2Pass = 8;
#[doc = "< The number of passes performed by FSR2."]
pub const FFX_FSR2_PASS_COUNT: Fsr2Pass = 9;
#[doc = " An enumeration of all the passes which constitute the FSR2 algorithm.\n\n FSR2 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr2ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr2Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR2\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR2_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR2_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr2Context</i></c> is created and the\n precise contents of <c><i>FfxFsr2DispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr2ContextDispatch</i></c>.\n\n @ingroup ffxFsr2"]
pub type Fsr2Pass = ::std::os::raw::c_int;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
pub const FFX_FSR2_QUALITY_MODE_QUALITY: Fsr2QualityMode = 1;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
pub const FFX_FSR2_QUALITY_MODE_BALANCED: Fsr2QualityMode = 2;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
pub const FFX_FSR2_QUALITY_MODE_PERFORMANCE: Fsr2QualityMode = 3;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
pub const FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE: Fsr2QualityMode = 4;
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 2 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR2. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup ffxFsr2"]
pub type Fsr2QualityMode = ::std::os::raw::c_int;
impl Fsr2InitializationFlagBits {
    #[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
    pub const FFX_FSR2_ENABLE_HIGH_DYNAMIC_RANGE: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(1);
    #[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
    pub const FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(2);
    #[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
    pub const FFX_FSR2_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(4);
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const FFX_FSR2_ENABLE_DEPTH_INVERTED: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(8);
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const FFX_FSR2_ENABLE_DEPTH_INFINITE: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(16);
    #[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
    pub const FFX_FSR2_ENABLE_AUTO_EXPOSURE: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(32);
    #[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
    pub const FFX_FSR2_ENABLE_DYNAMIC_RESOLUTION: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(64);
    #[doc = "< A bit indicating that the backend should use 1D textures."]
    pub const FFX_FSR2_ENABLE_TEXTURE1D_USAGE: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(128);
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const FFX_FSR2_ENABLE_DEBUG_CHECKING: Fsr2InitializationFlagBits =
        Fsr2InitializationFlagBits(256);
}
impl ::std::ops::BitOr<Fsr2InitializationFlagBits> for Fsr2InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        Fsr2InitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for Fsr2InitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: Fsr2InitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<Fsr2InitializationFlagBits> for Fsr2InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Fsr2InitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for Fsr2InitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: Fsr2InitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr2Context</i></c>. See <c><i>FfxFsr2ContextDescription</i></c>.\n\n @ingroup ffxFsr2"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Fsr2InitializationFlagBits(pub ::std::os::raw::c_int);
#[doc = " Pass a string message\n\n Used for debug messages.\n\n @param [in] type                       The type of message.\n @param [in] message                    A string message to pass.\n\n\n @ingroup ffxFsr2"]
pub type Fsr2Message =
    ::std::option::Option<unsafe extern "C" fn(type_: MsgType, message: *const u16)>;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 2 upscaling.\n\n @ingroup ffxFsr2"]
#[repr(C)]
pub struct Fsr2ContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr2InitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub displaySize: Dimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
    #[doc = "< A pointer to a function that can receive messages from the runtime."]
    pub fpMessage: Fsr2Message,
}
impl Default for Fsr2ContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 2.\n\n @ingroup ffxFsr2"]
#[repr(C)]
pub struct Fsr2DispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub output: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< A boolean value to indicate internal reactive autogeneration should be used"]
    pub enableAutoReactive: bool,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< Cutoff value for TC"]
    pub autoTcThreshold: f32,
    #[doc = "< A value to scale the transparency and composition mask"]
    pub autoTcScale: f32,
    #[doc = "< A value to scale the reactive mask"]
    pub autoReactiveScale: f32,
    #[doc = "< A value to clamp the reactive mask"]
    pub autoReactiveMax: f32,
}
impl Default for Fsr2DispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup ffxFsr2"]
#[repr(C)]
pub struct Fsr2GenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for Fsr2GenerateReactiveDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 2 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR2.\n\n The <c><i>FfxFsr2Context</i></c> object should have a lifetime matching\n your use of FSR2. Before destroying the FSR2 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR2.\n It is therefore recommended that the GPU is idle before destroying the\n FSR2 context.\n\n @ingroup ffxFsr2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr2Context {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for Fsr2Context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 2 context from the parameters\n programmed to the <c><i>FfxFsr2CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR2\n API, and is responsible for the management of the internal resources used\n by the FSR2 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR2's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr2Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr2Context</i></c> how match the configuration of your\n application as well as the intended use of FSR2. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr2DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR2 should be integerated into an application.\n\n When the <c><i>FfxFsr2Context</i></c> is created, you should use the\n <c><i>ffxFsr2ContextDispatch</i></c> function each frame where FSR2\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr2ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr2Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR2 upscaling is\n disabled by a user. To destroy the FSR2 context you should call\n <c><i>ffxFsr2ContextDestroy</i></c>.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr2Context</i></c> structure to populate.\n @param [in]  pContextDescription     A pointer to a <c><i>FfxFsr2ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr2ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2ContextCreate"]
    pub fn Fsr2ContextCreate(
        pContext: *mut Fsr2Context,
        pContextDescription: *const Fsr2ContextDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 2.\n\n FSR2 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr2ContextDispatch</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr2Context</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr2Context</i></c> correctly\n programming the <c><i>FfxFsr2DispatchDescription</i></c> is key to ensuring\n the correct operation of FSR2. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR2 provides the\n <c><i>ffxFsr2GetJitterPhaseCount</i></c> and\n <c><i>ffxFsr2GetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchDescription</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr2GetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR2.\n\n @param [in] pContext                 A pointer to a <c><i>FfxFsr2Context</i></c> structure.\n @param [in] pDispatchDescription     A pointer to a <c><i>FfxFsr2DispatchDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchDescription.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2ContextDispatch"]
    pub fn Fsr2ContextDispatch(
        pContext: *mut Fsr2Context,
        pDispatchDescription: *const Fsr2DispatchDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] pContext                 A pointer to a <c><i>FfxFsr2Context</i></c> structure.\n @param [in] pParams                  A pointer to a <c><i>FfxFsr2GenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2ContextGenerateReactiveMask"]
    pub fn Fsr2ContextGenerateReactiveMask(
        pContext: *mut Fsr2Context,
        pParams: *const Fsr2GenerateReactiveDescription,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr2Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2ContextDestroy"]
    pub fn Fsr2ContextDestroy(pContext: *mut Fsr2Context) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR2_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR2_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR2_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2GetUpscaleRatioFromQualityMode"]
    pub fn Fsr2GetUpscaleRatioFromQualityMode(qualityMode: Fsr2QualityMode) -> f32;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr2GetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] pRenderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] pRenderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2GetRenderResolutionFromQualityMode"]
    pub fn Fsr2GetRenderResolutionFromQualityMode(
        pRenderWidth: *mut u32,
        pRenderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: Fsr2QualityMode,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr2GetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR2_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR2_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR2_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2GetJitterPhaseCount"]
    pub fn Fsr2GetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
unsafe extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR2 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR2 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr2GetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr2GetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr2GetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr2GetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr2GetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr2GetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr2GetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr2GetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr2DispatchParameters</i></c> structure in order to inform FSR2\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr2GetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] pOutX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] pOutY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr2GetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2GetJitterOffset"]
    pub fn Fsr2GetJitterOffset(
        pOutX: *mut f32,
        pOutY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> ErrorCode;
}
unsafe extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup ffxFsr2"]
    #[link_name = "\u{1}ffxFsr2ResourceIsNull"]
    pub fn Fsr2ResourceIsNull(resource: Resource) -> bool;
}
