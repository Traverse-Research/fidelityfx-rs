/* automatically generated by rust-bindgen 0.69.4 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const FFX_SDK_DEFAULT_CONTEXT_SIZE: u32 = 131072;
pub const FFX_MAX_NUM_SRVS: u32 = 16;
pub const FFX_MAX_NUM_UAVS: u32 = 16;
pub const FFX_MAX_NUM_CONST_BUFFERS: u32 = 3;
pub const FFX_MAX_CONST_SIZE: u32 = 256;
pub const FFX_RESOURCE_NAME_SIZE: u32 = 64;
pub const FFX_MAX_QUEUED_FRAMES: u32 = 4;
pub const FFX_MAX_RESOURCE_COUNT: u32 = 128;
pub const FFX_MAX_PASS_COUNT: u32 = 50;
pub const FFX_RING_BUFFER_SIZE: u32 = 25600;
pub const FFX_BUFFER_SIZE: u32 = 768;
pub const FFX_RING_BUFFER_MEM_BLOCK_SIZE: u32 = 19660800;
pub const FFX_MAX_BARRIERS: u32 = 16;
pub const FFX_MAX_GPU_JOBS: u32 = 64;
pub const FFX_MAX_SAMPLERS: u32 = 16;
pub const UPLOAD_JOB_COUNT: u32 = 16;
pub const FFX_UNSPECIFIED_VERSION: u32 = 4294946048;
pub const FFX_MAXIMUM_PATH: u32 = 260;
pub const FFX_SDK_VERSION_MAJOR: u32 = 1;
pub const FFX_SDK_VERSION_MINOR: u32 = 0;
pub const FFX_SDK_VERSION_PATCH: u32 = 1;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL: u32 = 0;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_OPAQUE_ONLY: u32 = 1;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_COLOR: u32 = 2;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS: u32 = 3;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_DEPTH: u32 = 4;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_EXPOSURE: u32 = 5;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_REACTIVE_MASK: u32 = 6;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INPUT_TRANSPARENCY_AND_COMPOSITION_MASK: u32 = 7;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH: u32 = 8;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS: u32 = 9;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_DEPTH: u32 = 10;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR: u32 = 11;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LOCK_STATUS: u32 = 12;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NEW_LOCKS: u32 = 13;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREPARED_INPUT_COLOR: u32 = 14;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY: u32 = 15;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DEBUG_OUTPUT: u32 = 16;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LANCZOS_LUT: u32 = 17;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT: u32 = 18;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT: u32 = 19;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_RCAS_INPUT: u32 = 20;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LOCK_STATUS_1: u32 = 21;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LOCK_STATUS_2: u32 = 22;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_1: u32 = 23;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_2: u32 = 24;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_REACTIVITY: u32 = 25;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_TRANSPARENCY_AND_COMPOSITION: u32 =
    26;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTITIER_UPSAMPLE_MAXIMUM_BIAS_LUT: u32 = 27;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS: u32 = 28;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE: u32 = 29;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_0: u32 = 29;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_1: u32 = 30;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_2: u32 = 31;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_3: u32 = 32;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_4: u32 = 33;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_5: u32 = 34;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_6: u32 = 35;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_7: u32 = 36;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_8: u32 = 37;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_9: u32 = 38;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_10: u32 = 39;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_11: u32 = 40;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_12: u32 = 41;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE: u32 = 42;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_AUTO_EXPOSURE: u32 = 43;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_AUTOREACTIVE: u32 = 44;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_AUTOCOMPOSITION_DEPRECATED: u32 = 45;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR: u32 = 46;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR: u32 = 47;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR_1: u32 = 48;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR_1: u32 = 49;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR_2: u32 = 50;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR_2: u32 = 51;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_PREVIOUS_DILATED_MOTION_VECTORS: u32 = 52;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY_1: u32 = 53;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LUMA_HISTORY_2: u32 = 54;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LOCK_INPUT_LUMA: u32 = 55;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_SHADING_CHANGE: u32 = 33;
pub const FFX_FSR3UPSCALER_SHADING_CHANGE_MIP_LEVEL: u32 = 4;
pub const FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_COUNT: u32 = 56;
pub const FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_FSR3UPSCALER: u32 = 0;
pub const FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_SPD: u32 = 1;
pub const FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_RCAS: u32 = 2;
pub const FFX_FSR3UPSCALER_CONSTANTBUFFER_IDENTIFIER_GENREACTIVE: u32 = 3;
pub const FFX_FSR3UPSCALER_AUTOREACTIVEFLAGS_APPLY_TONEMAP: u32 = 1;
pub const FFX_FSR3UPSCALER_AUTOREACTIVEFLAGS_APPLY_INVERSETONEMAP: u32 = 2;
pub const FFX_FSR3UPSCALER_AUTOREACTIVEFLAGS_APPLY_THRESHOLD: u32 = 4;
pub const FFX_FSR3UPSCALER_AUTOREACTIVEFLAGS_USE_COMPONENTS_MAX: u32 = 8;
pub const FFX_FSR3UPSCALER_VERSION_MAJOR: u32 = 3;
pub const FFX_FSR3UPSCALER_VERSION_MINOR: u32 = 0;
pub const FFX_FSR3UPSCALER_VERSION_PATCH: u32 = 3;
pub const FFX_FSR3UPSCALER_CONTEXT_COUNT: u32 = 1;
pub const FFX_FSR3UPSCALER_CONTEXT_SIZE: u32 = 131072;
pub const FFX_FRAMEINTERPOLATION_VERSION_MAJOR: u32 = 1;
pub const FFX_FRAMEINTERPOLATION_VERSION_MINOR: u32 = 0;
pub const FFX_FRAMEINTERPOLATION_VERSION_PATCH: u32 = 0;
pub const FFX_FRAMEINTERPOLATION_CONTEXT_COUNT: u32 = 1;
pub const FFX_FRAMEINTERPOLATION_CONTEXT_SIZE: u32 = 131072;
pub const FFX_OPTICALFLOW_VERSION_MAJOR: u32 = 1;
pub const FFX_OPTICALFLOW_VERSION_MINOR: u32 = 0;
pub const FFX_OPTICALFLOW_VERSION_PATCH: u32 = 0;
pub const FFX_OPTICALFLOW_CONTEXT_COUNT: u32 = 1;
pub const FFX_OPTICALFLOW_CONTEXT_SIZE: u32 = 131072;
pub const FFX_FSR3_VERSION_MAJOR: u32 = 3;
pub const FFX_FSR3_VERSION_MINOR: u32 = 0;
pub const FFX_FSR3_VERSION_PATCH: u32 = 3;
pub const FFX_FSR3_CONTEXT_COUNT: u32 = 4;
pub const FFX_FSR3_CONTEXT_SIZE: u32 = 16536;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __the_value: __vcrt_va_list_is_reference__bindgen_ty_1 = false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " A typedef for a boolean value.\n\n @ingroup CPUTypes"]
pub type Boolean = bool;
#[doc = " A typedef for a unsigned 8bit integer.\n\n @ingroup CPUTypes"]
pub type UInt8 = u8;
#[doc = " A typedef for a unsigned 16bit integer.\n\n @ingroup CPUTypes"]
pub type UInt16 = u16;
#[doc = " A typedef for a unsigned 32bit integer.\n\n @ingroup CPUTypes"]
pub type UInt32 = u32;
#[doc = " A typedef for a unsigned 64bit integer.\n\n @ingroup CPUTypes"]
pub type UInt64 = u64;
#[doc = " A typedef for a signed 8bit integer.\n\n @ingroup CPUTypes"]
pub type Int8 = i8;
#[doc = " A typedef for a signed 16bit integer.\n\n @ingroup CPUTypes"]
pub type Int16 = i16;
#[doc = " A typedef for a signed 32bit integer.\n\n @ingroup CPUTypes"]
pub type Int32 = i32;
#[doc = " A typedef for a signed 64bit integer.\n\n @ingroup CPUTypes"]
pub type Int64 = i64;
#[doc = " A typedef for a floating point value.\n\n @ingroup CPUTypes"]
pub type Float32 = f32;
#[doc = " A typedef for a 2-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x2 = [f32; 2usize];
#[doc = " A typedef for a 3-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x3 = [f32; 3usize];
#[doc = " A typedef for a 4-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x4 = [f32; 4usize];
#[doc = " A typedef for a 2-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x2 = [u32; 2usize];
#[doc = " A typedef for a 3-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x3 = [u32; 3usize];
#[doc = " A typedef for a 4-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x4 = [u32; 4usize];
#[doc = "< Unknown format"]
pub const FFX_SURFACE_FORMAT_UNKNOWN: SurfaceFormat = 0;
#[doc = "< 32 bit per channel, 4 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R32G32B32A32_TYPELESS: SurfaceFormat = 1;
#[doc = "< 32 bit per channel, 4 channel uint format"]
pub const FFX_SURFACE_FORMAT_R32G32B32A32_UINT: SurfaceFormat = 2;
#[doc = "< 32 bit per channel, 4 channel float format"]
pub const FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT: SurfaceFormat = 3;
#[doc = "< 16 bit per channel, 4 channel float format"]
pub const FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT: SurfaceFormat = 4;
#[doc = "< 32 bit per channel, 2 channel float format"]
pub const FFX_SURFACE_FORMAT_R32G32_FLOAT: SurfaceFormat = 5;
#[doc = "< 8 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R8_UINT: SurfaceFormat = 6;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R32_UINT: SurfaceFormat = 7;
#[doc = "< 10 bit per RGB channel with 2 bit alpha, 4 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R10G10B10A2_UNORM: SurfaceFormat = 8;
#[doc = "<  8 bit per channel, 4 channel float format"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_TYPELESS: SurfaceFormat = 9;
#[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_UNORM: SurfaceFormat = 10;
#[doc = "<  8 bit per channel, 4 channel signed normalized format"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_SNORM: SurfaceFormat = 11;
#[doc = "<  8 bit per channel, 4 channel srgb normalized"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_SRGB: SurfaceFormat = 12;
#[doc = "< 32 bit 3 channel float format"]
pub const FFX_SURFACE_FORMAT_R11G11B10_FLOAT: SurfaceFormat = 13;
#[doc = "< 16 bit per channel, 2 channel float format"]
pub const FFX_SURFACE_FORMAT_R16G16_FLOAT: SurfaceFormat = 14;
#[doc = "< 16 bit per channel, 2 channel unsigned int format"]
pub const FFX_SURFACE_FORMAT_R16G16_UINT: SurfaceFormat = 15;
#[doc = "< 16 bit per channel, 2 channel signed int format"]
pub const FFX_SURFACE_FORMAT_R16G16_SINT: SurfaceFormat = 16;
#[doc = "< 16 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R16_FLOAT: SurfaceFormat = 17;
#[doc = "< 16 bit per channel, 1 channel unsigned int format"]
pub const FFX_SURFACE_FORMAT_R16_UINT: SurfaceFormat = 18;
#[doc = "< 16 bit per channel, 1 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R16_UNORM: SurfaceFormat = 19;
#[doc = "< 16 bit per channel, 1 channel signed normalized format"]
pub const FFX_SURFACE_FORMAT_R16_SNORM: SurfaceFormat = 20;
#[doc = "<  8 bit per channel, 1 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8_UNORM: SurfaceFormat = 21;
#[doc = "<  8 bit per channel, 2 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8G8_UNORM: SurfaceFormat = 22;
#[doc = "<  8 bit per channel, 2 channel unsigned integer format"]
pub const FFX_SURFACE_FORMAT_R8G8_UINT: SurfaceFormat = 23;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R32_FLOAT: SurfaceFormat = 24;
#[doc = " An enumeration of surface formats.\n\n @ingroup SDKTypes"]
pub type SurfaceFormat = ::std::os::raw::c_int;
#[doc = "< No usage flags indicate a resource is read only."]
pub const FFX_RESOURCE_USAGE_READ_ONLY: ResourceUsage = 0;
#[doc = "< Indicates a resource will be used as render target."]
pub const FFX_RESOURCE_USAGE_RENDERTARGET: ResourceUsage = 1;
#[doc = "< Indicates a resource will be used as UAV."]
pub const FFX_RESOURCE_USAGE_UAV: ResourceUsage = 2;
#[doc = "< Indicates a resource will be used as depth target."]
pub const FFX_RESOURCE_USAGE_DEPTHTARGET: ResourceUsage = 4;
#[doc = "< Indicates a resource will be used as indirect argument buffer"]
pub const FFX_RESOURCE_USAGE_INDIRECT: ResourceUsage = 8;
#[doc = "< Indicates a resource that will generate array views. Works on 2D and cubemap textures"]
pub const FFX_RESOURCE_USAGE_ARRAYVIEW: ResourceUsage = 16;
#[doc = " An enumeration of resource usage.\n\n @ingroup SDKTypes"]
pub type ResourceUsage = ::std::os::raw::c_int;
#[repr(i32)]
#[doc = " An enumeration of resource states.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceStates {
    COMMON = 1,
    #[doc = "< Indicates a resource is in the state to be used as UAV."]
    UNORDERED_ACCESS = 2,
    #[doc = "< Indicates a resource is in the state to be read by compute shaders."]
    COMPUTE_READ = 4,
    #[doc = "< Indicates a resource is in the state to be read by pixel shaders."]
    PIXEL_READ = 8,
    #[doc = "< Indicates a resource is in the state to be read by pixel or compute shaders."]
    PIXEL_COMPUTE_READ = 12,
    #[doc = "< Indicates a resource is in the state to be used as source in a copy command."]
    COPY_SRC = 16,
    #[doc = "< Indicates a resource is in the state to be used as destination in a copy command."]
    COPY_DEST = 32,
    #[doc = "< Indicates a resource is in generic (slow) read state."]
    GENERIC_READ = 20,
    #[doc = "< Indicates a resource is in the state to be used as an indirect command argument"]
    INDIRECT_ARGUMENT = 64,
    #[doc = "< Indicates a resource is in the state to be used to present to the swap chain"]
    PRESENT = 128,
    #[doc = "< Indicates a resource is in the state to be used as render target"]
    RENDER_TARGET = 256,
}
#[doc = "< A resource with a single dimension."]
pub const FFX_RESOURCE_DIMENSION_TEXTURE_1D: ResourceDimension = 0;
#[doc = "< A resource with two dimensions."]
pub const FFX_RESOURCE_DIMENSION_TEXTURE_2D: ResourceDimension = 1;
#[doc = " An enumeration of surface dimensions.\n\n @ingroup SDKTypes"]
pub type ResourceDimension = ::std::os::raw::c_int;
#[doc = "< A resource view on a buffer."]
pub const FFX_RESOURCE_VIEW_DIMENSION_BUFFER: ResourceViewDimension = 0;
#[doc = "< A resource view on a single dimension."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_1D: ResourceViewDimension = 1;
#[doc = "< A resource view on a single dimensional array."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_1D_ARRAY: ResourceViewDimension = 2;
#[doc = "< A resource view on two dimensions."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_2D: ResourceViewDimension = 3;
#[doc = "< A resource view on two dimensional array."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_2D_ARRAY: ResourceViewDimension = 4;
#[doc = "< A resource view on three dimensions."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_3D: ResourceViewDimension = 5;
#[doc = " An enumeration of resource view dimensions.\n\n @ingroup SDKTypes"]
pub type ResourceViewDimension = ::std::os::raw::c_int;
#[doc = "< No flags."]
pub const FFX_RESOURCE_FLAGS_NONE: ResourceFlags = 0;
#[doc = "< A bit indicating a resource does not need to persist across frames."]
pub const FFX_RESOURCE_FLAGS_ALIASABLE: ResourceFlags = 1;
#[doc = "< Special case flag used internally when importing resources that require additional setup"]
pub const FFX_RESOURCE_FLAGS_UNDEFINED: ResourceFlags = 2;
#[doc = " An enumeration of surface dimensions.\n\n @ingroup SDKTypes"]
pub type ResourceFlags = ::std::os::raw::c_int;
#[doc = "< The resource view is an unordered access view (UAV)."]
pub const FFX_RESOURCE_VIEW_UNORDERED_ACCESS: ResourceViewType = 0;
#[doc = "< The resource view is a shader resource view (SRV)."]
pub const FFX_RESOURCE_VIEW_SHADER_READ: ResourceViewType = 1;
#[doc = " An enumeration of all resource view types.\n\n @ingroup SDKTypes"]
pub type ResourceViewType = ::std::os::raw::c_int;
#[doc = "< Point sampling."]
pub const FFX_FILTER_TYPE_MINMAGMIP_POINT: FilterType = 0;
#[doc = "< Sampling with interpolation."]
pub const FFX_FILTER_TYPE_MINMAGMIP_LINEAR: FilterType = 1;
#[doc = "< Use linear interpolation for minification and magnification; use point sampling for mip-level sampling."]
pub const FFX_FILTER_TYPE_MINMAGLINEARMIP_POINT: FilterType = 2;
#[doc = " The type of filtering to perform when reading a texture.\n\n @ingroup SDKTypes"]
pub type FilterType = ::std::os::raw::c_int;
#[doc = "< Wrap when reading texture."]
pub const FFX_ADDRESS_MODE_WRAP: AddressMode = 0;
#[doc = "< Mirror when reading texture."]
pub const FFX_ADDRESS_MODE_MIRROR: AddressMode = 1;
#[doc = "< Clamp when reading texture."]
pub const FFX_ADDRESS_MODE_CLAMP: AddressMode = 2;
#[doc = "< Border color when reading texture."]
pub const FFX_ADDRESS_MODE_BORDER: AddressMode = 3;
#[doc = "< Mirror once when reading texture."]
pub const FFX_ADDRESS_MODE_MIRROR_ONCE: AddressMode = 4;
#[doc = " The address mode used when reading a texture.\n\n @ingroup SDKTypes"]
pub type AddressMode = ::std::os::raw::c_int;
#[doc = "< Shader model 5.1."]
pub const FFX_SHADER_MODEL_5_1: ShaderModel = 0;
#[doc = "< Shader model 6.0."]
pub const FFX_SHADER_MODEL_6_0: ShaderModel = 1;
#[doc = "< Shader model 6.1."]
pub const FFX_SHADER_MODEL_6_1: ShaderModel = 2;
#[doc = "< Shader model 6.2."]
pub const FFX_SHADER_MODEL_6_2: ShaderModel = 3;
#[doc = "< Shader model 6.3."]
pub const FFX_SHADER_MODEL_6_3: ShaderModel = 4;
#[doc = "< Shader model 6.4."]
pub const FFX_SHADER_MODEL_6_4: ShaderModel = 5;
#[doc = "< Shader model 6.5."]
pub const FFX_SHADER_MODEL_6_5: ShaderModel = 6;
#[doc = "< Shader model 6.6."]
pub const FFX_SHADER_MODEL_6_6: ShaderModel = 7;
#[doc = "< Shader model 6.7."]
pub const FFX_SHADER_MODEL_6_7: ShaderModel = 8;
#[doc = " An enumeration of all supported shader models.\n\n @ingroup SDKTypes"]
pub type ShaderModel = ::std::os::raw::c_int;
#[doc = "< The resource is a buffer."]
pub const FFX_RESOURCE_TYPE_BUFFER: ResourceType = 0;
#[doc = "< The resource is a 1-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE1D: ResourceType = 1;
#[doc = "< The resource is a 2-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE2D: ResourceType = 2;
#[doc = "< The resource is a cube map."]
pub const FFX_RESOURCE_TYPE_TEXTURE_CUBE: ResourceType = 3;
#[doc = "< The resource is a 3-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE3D: ResourceType = 4;
#[doc = "\n @ingroup SDKTypes"]
pub type ResourceType = ::std::os::raw::c_int;
#[doc = "< Local memory."]
pub const FFX_HEAP_TYPE_DEFAULT: HeapType = 0;
#[doc = "< Heap used for uploading resources."]
pub const FFX_HEAP_TYPE_UPLOAD: HeapType = 1;
#[doc = " An enumeration for different heap types\n\n @ingroup SDKTypes"]
pub type HeapType = ::std::os::raw::c_int;
#[doc = "< The GPU job is performing a floating-point clear."]
pub const FFX_GPU_JOB_CLEAR_FLOAT: GpuJobType = 0;
#[doc = "< The GPU job is performing a copy."]
pub const FFX_GPU_JOB_COPY: GpuJobType = 1;
#[doc = "< The GPU job is performing a compute dispatch."]
pub const FFX_GPU_JOB_COMPUTE: GpuJobType = 2;
#[doc = "< The GPU job is performing a barrier."]
pub const FFX_GPU_JOB_BARRIER: GpuJobType = 3;
#[doc = " An enumeration for different render job types\n\n @ingroup SDKTypes"]
pub type GpuJobType = ::std::os::raw::c_int;
pub const FFX_DESCRIPTOR_TEXTURE_SRV: DescriptorType = 0;
pub const FFX_DESCRIPTOR_BUFFER_SRV: DescriptorType = 1;
pub const FFX_DESCRIPTOR_TEXTURE_UAV: DescriptorType = 2;
pub const FFX_DESCRIPTOR_BUFFER_UAV: DescriptorType = 3;
#[doc = " An enumeration for various descriptor types\n\n @ingroup SDKTypes"]
pub type DescriptorType = ::std::os::raw::c_int;
#[doc = " An enumeration for various descriptor types\n\n @ingroup SDKTypes"]
pub use self::DescriptorType as DescriptiorType;
pub const FFX_BIND_PIXEL_SHADER_STAGE: BindStage = 1;
pub const FFX_BIND_VERTEX_SHADER_STAGE: BindStage = 2;
pub const FFX_BIND_COMPUTE_SHADER_STAGE: BindStage = 4;
#[doc = " An enumeration for view binding stages\n\n @ingroup SDKTypes"]
pub type BindStage = ::std::os::raw::c_int;
pub const FFX_BARRIER_TYPE_TRANSITION: BarrierType = 0;
pub const FFX_BARRIER_TYPE_UAV: BarrierType = 1;
#[doc = " An enumeration for barrier types\n\n @ingroup SDKTypes"]
pub type BarrierType = ::std::os::raw::c_int;
pub const FFX_MESSAGE_TYPE_ERROR: MsgType = 0;
pub const FFX_MESSAGE_TYPE_WARNING: MsgType = 1;
pub const FFX_MESSAGE_TYPE_COUNT: MsgType = 2;
#[doc = " An enumeration for message types that can be passed\n\n @ingroup SDKTypes"]
pub type MsgType = ::std::os::raw::c_int;
#[doc = "< FidelityFX Super Resolution v2"]
pub const FFX_EFFECT_FSR2: Effect = 0;
#[doc = "< FidelityFX Super Resolution"]
pub const FFX_EFFECT_FSR1: Effect = 1;
#[doc = "< FidelityFX Single Pass Downsampler"]
pub const FFX_EFFECT_SPD: Effect = 2;
#[doc = "< FidelityFX Blur"]
pub const FFX_EFFECT_BLUR: Effect = 3;
#[doc = "< FidelityFX Combined Adaptive Compute Ambient Occlusion"]
pub const FFX_EFFECT_CACAO: Effect = 4;
#[doc = "< FidelityFX Contrast Adaptive Sharpening"]
pub const FFX_EFFECT_CAS: Effect = 5;
#[doc = "< FidelityFX Denoiser"]
pub const FFX_EFFECT_DENOISER: Effect = 6;
#[doc = "< FidelityFX Lens"]
pub const FFX_EFFECT_LENS: Effect = 7;
#[doc = "< FidelityFX Parallel Sort"]
pub const FFX_EFFECT_PARALLEL_SORT: Effect = 8;
#[doc = "< FidelityFX Stochastic Screen Space Reflections"]
pub const FFX_EFFECT_SSSR: Effect = 9;
#[doc = "< FidelityFX Variable Shading"]
pub const FFX_EFFECT_VARIABLE_SHADING: Effect = 10;
#[doc = "< FidelityFX Luma Preserving Mapper"]
pub const FFX_EFFECT_LPM: Effect = 11;
#[doc = "< FidelityFX Depth of Field"]
pub const FFX_EFFECT_DOF: Effect = 12;
#[doc = "< FidelityFX Classifier"]
pub const FFX_EFFECT_CLASSIFIER: Effect = 13;
#[doc = "< FidelityFX Super Resolution v3"]
pub const FFX_EFFECT_FSR3UPSCALER: Effect = 14;
#[doc = "< FidelityFX Frame Interpolation, part of FidelityFX Super Resolution v3"]
pub const FFX_EFFECT_FRAMEINTERPOLATION: Effect = 15;
#[doc = "< FidelityFX Optical Flow, part of FidelityFX Super Resolution v3"]
pub const FFX_EFFECT_OPTICALFLOW: Effect = 16;
#[doc = " An enumeration of all the effects which constitute the FidelityFX SDK.\n\n Dictates what effect shader blobs to fetch for pipeline creation\n\n @ingroup FfxInterface"]
pub type Effect = ::std::os::raw::c_int;
pub const FFX_BACKBUFFER_TRANSFER_FUNCTION_SRGB: BackbufferTransferFunction = 0;
pub const FFX_BACKBUFFER_TRANSFER_FUNCTION_PQ: BackbufferTransferFunction = 1;
pub const FFX_BACKBUFFER_TRANSFER_FUNCTION_SCRGB: BackbufferTransferFunction = 2;
pub type BackbufferTransferFunction = ::std::os::raw::c_int;
#[doc = " A typedef representing the graphics device.\n\n @ingroup SDKTypes"]
pub type Device = *mut ::std::os::raw::c_void;
pub type CommandQueue = *mut ::std::os::raw::c_void;
pub type Swapchain = *mut ::std::os::raw::c_void;
#[doc = " A typedef representing a command list or command buffer.\n\n @ingroup SDKTypes"]
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct CommandList(pub *mut ::std::os::raw::c_void);
#[doc = " A typedef for a root signature.\n\n @ingroup SDKTypes"]
pub type RootSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a command signature, used for indirect workloads\n\n @ingroup SDKTypes"]
pub type CommandSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a pipeline state object.\n\n @ingroup SDKTypes"]
pub type Pipeline = *mut ::std::os::raw::c_void;
#[doc = " A structure encapsulating a collection of device capabilities.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceCapabilities {
    #[doc = "< The minimum shader model supported by the device."]
    pub minimumSupportedShaderModel: ShaderModel,
    #[doc = "< The minimum supported wavefront width."]
    pub waveLaneCountMin: u32,
    #[doc = "< The maximum supported wavefront width."]
    pub waveLaneCountMax: u32,
    #[doc = "< The device supports FP16 in hardware."]
    pub fp16Supported: bool,
    #[doc = "< The device supports ray tracing."]
    pub raytracingSupported: bool,
}
impl Default for DeviceCapabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a 2-dimensional point, using 32bit unsigned integers.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Dimensions2D {
    #[doc = "< The width of a 2-dimensional range."]
    pub width: u32,
    #[doc = "< The height of a 2-dimensional range."]
    pub height: u32,
}
#[doc = " A structure encapsulating a 2-dimensional point.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: i32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: i32,
}
#[doc = " A structure encapsulating a 2-dimensional rect.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Rect2D {
    pub left: i32,
    pub top: i32,
    pub width: i32,
    pub height: i32,
}
#[doc = " A structure encapsulating a 2-dimensional set of floating point coordinates.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FloatCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: f32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: f32,
}
#[doc = " A structure describing a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResourceDescription {
    #[doc = "< The type of the resource."]
    pub type_: ResourceType,
    #[doc = "< The surface format."]
    pub format: SurfaceFormat,
    pub __bindgen_anon_1: ResourceDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ResourceDescription__bindgen_ty_2,
    pub __bindgen_anon_3: ResourceDescription__bindgen_ty_3,
    #[doc = "< Number of mips (or 0 for full mipchain)."]
    pub mipCount: u32,
    #[doc = "< A set of <c><i>FfxResourceFlags</i></c> flags."]
    pub flags: ResourceFlags,
    #[doc = "< Resource usage flags."]
    pub usage: ResourceUsage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_1 {
    #[doc = "< The width of the texture resource."]
    pub width: u32,
    #[doc = "< The size of the buffer resource."]
    pub size: u32,
}
impl Default for ResourceDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_2 {
    #[doc = "< The height of the texture resource."]
    pub height: u32,
    #[doc = "< The stride of the buffer resource."]
    pub stride: u32,
}
impl Default for ResourceDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_3 {
    #[doc = "< The depth of the texture resource."]
    pub depth: u32,
    #[doc = "< The alignment of the buffer resource."]
    pub alignment: u32,
}
impl Default for ResourceDescription__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An outward facing structure containing a resource\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Resource {
    #[doc = "< pointer to the resource."]
    pub resource: *mut ::std::os::raw::c_void,
    pub description: ResourceDescription,
    pub state: ResourceStates,
    #[doc = "< (optional) Resource name."]
    pub name: [u16; 64usize],
}
impl Default for Resource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An internal structure containing a handle to a resource and resource views\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResourceInternal {
    #[doc = "< The index of the resource."]
    pub internalIndex: i32,
}
#[doc = " An internal structure housing all that is needed for backend resource descriptions\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InternalResourceDescription {
    pub id: u32,
    pub name: *const u16,
    pub type_: ResourceType,
    pub usage: ResourceUsage,
    pub format: SurfaceFormat,
    pub width: u32,
    pub height: u32,
    pub mipCount: u32,
    pub flags: ResourceFlags,
    pub initDataSize: u32,
    pub initData: *mut ::std::os::raw::c_void,
}
impl Default for InternalResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure defining the view to create\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ViewDescription {
    #[doc = "< Indicates that the view is a UAV."]
    pub uavView: bool,
    #[doc = "< The view dimension to map"]
    pub viewDimension: ResourceViewDimension,
    pub __bindgen_anon_1: ViewDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ViewDescription__bindgen_ty_2,
    #[doc = "< The first slice to map to, (-1) for default first slice"]
    pub firstSlice: i32,
    pub name: [u16; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ViewDescription__bindgen_ty_1 {
    #[doc = "< The mip level of the view, (-1) for default"]
    pub mipLevel: i32,
    #[doc = "< The first element of a buffer view, (-1) for default"]
    pub firstElement: i32,
}
impl Default for ViewDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ViewDescription__bindgen_ty_2 {
    #[doc = "< The array size of the view, (-1) for full depth/array size"]
    pub arraySize: i32,
    #[doc = "< The number of elements in a buffer view, (-1) for full depth/array size"]
    pub elementCount: i32,
}
impl Default for ViewDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ViewDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}s_FfxViewDescInit"]
    pub static mut s_ViewDescInit: ViewDescription;
}
#[doc = " A structure defining a resource bind point\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceBinding {
    pub slotIndex: u32,
    pub resourceIdentifier: u32,
    pub bindCount: u32,
    pub name: [u16; 64usize],
}
impl Default for ResourceBinding {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a single pass of an algorithm.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineState {
    #[doc = "< The pipelines rootSignature"]
    pub rootSignature: RootSignature,
    #[doc = "< The command signature used for indirect workloads"]
    pub cmdSignature: CommandSignature,
    #[doc = "< The pipeline object"]
    pub pipeline: Pipeline,
    #[doc = "< Count of Texture UAVs used in this pipeline"]
    pub uavTextureCount: u32,
    #[doc = "< Count of Texture SRVs used in this pipeline"]
    pub srvTextureCount: u32,
    #[doc = "< Count of Buffer SRV used in this pipeline"]
    pub srvBufferCount: u32,
    #[doc = "< Count of Buffer UAVs used in this pipeline"]
    pub uavBufferCount: u32,
    #[doc = "< Count of constant buffers used in this pipeline"]
    pub constCount: u32,
    #[doc = "< Array of ResourceIdentifiers bound as texture UAVs"]
    pub uavTextureBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as texture SRVs"]
    pub srvTextureBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as buffer SRVs"]
    pub srvBufferBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as buffer UAVs"]
    pub uavBufferBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as CBs"]
    pub constantBufferBindings: [ResourceBinding; 3usize],
}
impl Default for PipelineState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateResourceDescription {
    #[doc = "< The heap type to hold the resource, typically <c><i>FFX_HEAP_TYPE_DEFAULT</i></c>."]
    pub heapType: HeapType,
    #[doc = "< A resource description."]
    pub resourceDescription: ResourceDescription,
    #[doc = "< The initial resource state."]
    pub initalState: ResourceStates,
    #[doc = "< Size of initial data buffer."]
    pub initDataSize: u32,
    #[doc = "< Buffer containing data to fill the resource."]
    pub initData: *mut ::std::os::raw::c_void,
    #[doc = "< Name of the resource."]
    pub name: *const u16,
    #[doc = "< Internal resource ID."]
    pub id: u32,
}
impl Default for CreateResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create sampler mappings\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerDescription {
    pub filter: FilterType,
    pub addressModeU: AddressMode,
    pub addressModeV: AddressMode,
    pub addressModeW: AddressMode,
    pub stage: BindStage,
}
impl Default for SamplerDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create root constant buffer mappings\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootConstantDescription {
    pub size: u32,
    pub stage: BindStage,
}
impl Default for RootConstantDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the description used to create a\n <c><i>FfxPipeline</i></c> structure.\n\n A pipeline is the name given to a shader and the collection of state that\n is required to dispatch it. In the context of the FidelityFX SDK and its architecture\n this means that a <c><i>FfxPipelineDescription</i></c> will map to either a\n monolithic object in an explicit API (such as a\n <c><i>PipelineStateObject</i></c> in DirectX 12). Or a shader and some\n ancillary API objects (in something like DirectX 11).\n\n The <c><i>contextFlags</i></c> field contains a copy of the flags passed\n to <c><i>ffxContextCreate</i></c> via the <c><i>flags</i></c> field of\n the <c><i>Ffx<Effect>InitializationParams</i></c> structure. These flags are\n used to determine which permutation of a pipeline for a specific\n <c><i>Ffx<Effect>Pass</i></c> should be used to implement the features required\n by each application, as well as to achieve the best performance on specific\n target hardware configurations.\n\n When using one of the provided backends for FidelityFX SDK (such as DirectX 12 or\n Vulkan) the data required to create a pipeline is compiled off line and\n included into the backend library that you are using. For cases where the\n backend interface is overridden by providing custom callback function\n implementations care should be taken to respect the contents of the\n <c><i>contextFlags</i></c> field in order to correctly support the options\n provided by the FidelityFX SDK, and achieve best performance.\n ///\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDescription {
    #[doc = "< A collection of <c><i>FfxInitializationFlagBits</i></c> which were passed to the context."]
    pub contextFlags: u32,
    #[doc = "< A collection of samplers to use when building the root signature for the pipeline"]
    pub samplers: *const SamplerDescription,
    #[doc = "< Number of samplers to create for the pipeline"]
    pub samplerCount: usize,
    #[doc = "< A collection of root constant descriptions to use when building the root signature for the pipeline"]
    pub rootConstants: *const RootConstantDescription,
    #[doc = "< Number of root constant buffers to create for the pipeline"]
    pub rootConstantBufferCount: u32,
    #[doc = "< Pipeline name with which to name the pipeline object"]
    pub name: [u16; 64usize],
    #[doc = "< The stage(s) for which this pipeline is being built"]
    pub stage: BindStage,
    #[doc = "< Whether this pipeline has an indirect workload"]
    pub indirectWorkload: u32,
    #[doc = "< For raster pipelines this contains the backbuffer format"]
    pub backbufferFormat: SurfaceFormat,
}
impl Default for PipelineDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a barrier\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BarrierDescription {
    pub resource: ResourceInternal,
    pub barrierType: BarrierType,
    pub currentState: ResourceStates,
    pub newState: ResourceStates,
    pub subResourceID: u32,
}
impl Default for BarrierDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing a constant buffer.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstantBuffer {
    #[doc = "< The size (expressed in 32-bit chunks) stored in data."]
    pub num32BitEntries: u32,
    #[doc = "< Constant buffer data"]
    pub data: [u32; 256usize],
}
impl Default for ConstantBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a clear render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ClearFloatJobDescription {
    #[doc = "< The clear color of the resource."]
    pub color: [f32; 4usize],
    #[doc = "< The resource to be cleared."]
    pub target: ResourceInternal,
}
#[doc = " A structure describing a compute render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComputeJobDescription {
    #[doc = "< Compute pipeline for the render job."]
    pub pipeline: PipelineState,
    #[doc = "< Dispatch dimensions."]
    pub dimensions: [u32; 3usize],
    #[doc = "< Dispatch indirect cmd argument buffer"]
    pub cmdArgument: ResourceInternal,
    #[doc = "< Dispatch indirect offset within the cmd argument buffer"]
    pub cmdArgumentOffset: u32,
    #[doc = "< SRV texture resources to be bound in the compute job."]
    pub srvTextures: [ResourceInternal; 16usize],
    pub srvTextureNames: [[u16; 64usize]; 16usize],
    #[doc = "< UAV texture resources to be bound in the compute job."]
    pub uavTextures: [ResourceInternal; 16usize],
    #[doc = "< Mip level of UAV texture resources to be bound in the compute job."]
    pub uavTextureMips: [u32; 16usize],
    pub uavTextureNames: [[u16; 64usize]; 16usize],
    #[doc = "< SRV buffer resources to be bound in the compute job."]
    pub srvBuffers: [ResourceInternal; 16usize],
    pub srvBufferNames: [[u16; 64usize]; 16usize],
    #[doc = "< UAV buffer resources to be bound in the compute job."]
    pub uavBuffers: [ResourceInternal; 16usize],
    pub uavBufferNames: [[u16; 64usize]; 16usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 3usize],
    pub cbNames: [[u16; 64usize]; 3usize],
}
impl Default for ComputeJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RasterJobDescription {
    #[doc = "< Raster pipeline for the render job."]
    pub pipeline: PipelineState,
    pub numVertices: u32,
    pub renderTarget: ResourceInternal,
    #[doc = "< SRV resources to be bound in the compute job."]
    pub srvTextures: [ResourceInternal; 16usize],
    pub srvTextureNames: [[u16; 64usize]; 16usize],
    #[doc = "< UAV resources to be bound in the compute job."]
    pub uavTextures: [ResourceInternal; 16usize],
    #[doc = "< Mip level of UAV resources to be bound in the compute job."]
    pub uavTextureMips: [u32; 16usize],
    pub uavTextureNames: [[u16; 64usize]; 16usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 3usize],
    pub cbNames: [[u16; 64usize]; 3usize],
}
impl Default for RasterJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a copy render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CopyJobDescription {
    #[doc = "< Source resource for the copy."]
    pub src: ResourceInternal,
    #[doc = "< Destination resource for the copy."]
    pub dst: ResourceInternal,
}
#[doc = " A structure describing a single render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GpuJobDescription {
    #[doc = "< Type of the job."]
    pub jobType: GpuJobType,
    pub __bindgen_anon_1: GpuJobDescription__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GpuJobDescription__bindgen_ty_1 {
    #[doc = "< Clear job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_CLEAR_FLOAT</i></c>."]
    pub clearJobDescriptor: ClearFloatJobDescription,
    #[doc = "< Copy job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COPY</i></c>."]
    pub copyJobDescriptor: CopyJobDescription,
    #[doc = "< Compute job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COMPUTE</i></c>."]
    pub computeJobDescriptor: ComputeJobDescription,
    pub rasterJobDescriptor: RasterJobDescription,
    pub barrierDescriptor: BarrierDescription,
}
impl Default for GpuJobDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GpuJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderBlob {
    pub data: *const u8,
    pub size: u32,
    pub cbvCount: u32,
    pub srvTextureCount: u32,
    pub uavTextureCount: u32,
    pub srvBufferCount: u32,
    pub uavBufferCount: u32,
    pub samplerCount: u32,
    pub rtAccelStructCount: u32,
    pub boundConstantBufferNames: *mut *const ::std::os::raw::c_char,
    pub boundConstantBuffers: *const u32,
    pub boundConstantBufferCounts: *const u32,
    pub boundSRVTextureNames: *mut *const ::std::os::raw::c_char,
    pub boundSRVTextures: *const u32,
    pub boundSRVTextureCounts: *const u32,
    pub boundUAVTextureNames: *mut *const ::std::os::raw::c_char,
    pub boundUAVTextures: *const u32,
    pub boundUAVTextureCounts: *const u32,
    pub boundSRVBufferNames: *mut *const ::std::os::raw::c_char,
    pub boundSRVBuffers: *const u32,
    pub boundSRVBufferCounts: *const u32,
    pub boundUAVBufferNames: *mut *const ::std::os::raw::c_char,
    pub boundUAVBuffers: *const u32,
    pub boundUAVBufferCounts: *const u32,
    pub boundSamplerNames: *mut *const ::std::os::raw::c_char,
    pub boundSamplers: *const u32,
    pub boundSamplerCounts: *const u32,
    pub boundRTAccelerationStructureNames: *mut *const ::std::os::raw::c_char,
    pub boundRTAccelerationStructures: *const u32,
    pub boundRTAccelerationStructureCounts: *const u32,
}
impl Default for ShaderBlob {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentCallbackDescription {
    pub device: Device,
    pub commandList: CommandList,
    pub currentBackBuffer: Resource,
    pub currentUI: Resource,
    pub outputSwapChainBuffer: Resource,
    pub isInterpolatedFrame: bool,
}
impl Default for PresentCallbackDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameGenerationDispatchDescription {
    pub commandList: CommandList,
    pub presentColor: Resource,
    pub outputs: [Resource; 4usize],
    pub numInterpolatedFrames: u32,
    pub reset: bool,
    pub backBufferTransferFunction: BackbufferTransferFunction,
    pub minMaxLuminance: [f32; 2usize],
}
impl Default for FrameGenerationDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The value of Pi.\n\n @ingroup Utils"]
pub const FFX_PI: f32 = 3.1415927410125732;
#[doc = " An epsilon value for floating point numbers.\n\n @ingroup Utils"]
pub const FFX_EPSILON: f32 = 0.0000009999999974752427;
#[doc = " A typedef for the callback function for assert printing.\n\n This can be used to re-route printing of assert messages from the FFX backend\n to another destination. For example instead of the default behaviour of printing\n the assert messages to the debugger's TTY the message can be re-routed to a\n MessageBox in a GUI application.\n\n @param [in] message                 The message generated by the assert.\n\n @ingroup Asserts"]
pub type AssertCallback =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Function to report an assert.\n\n @param [in] file                    The name of the file as a string.\n @param [in] line                    The index of the line in the file.\n @param [in] condition               The boolean condition that was tested.\n @param [in] msg                     The optional message to print.\n\n @returns\n Always returns true.\n\n @ingroup Asserts"]
    #[link_name = "\u{1}ffxAssertReport"]
    pub fn AssertReport(
        file: *const ::std::os::raw::c_char,
        line: i32,
        condition: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Provides the ability to set a callback for assert messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n\n @ingroup Asserts"]
    #[link_name = "\u{1}ffxAssertSetPrintingCallback"]
    pub fn AssertSetPrintingCallback(callback: AssertCallback);
}
#[doc = " Typedef for error codes returned from functions in the FidelityFX SDK.\n\n @ingroup Errors"]
pub type ErrorCode = i32;
#[doc = "< The operation completed successfully."]
pub const FFX_OK: ErrorCodes = 0;
#[doc = "< The operation failed due to an invalid pointer."]
pub const FFX_ERROR_INVALID_POINTER: ErrorCodes = -2147483648;
#[doc = "< The operation failed due to an invalid alignment."]
pub const FFX_ERROR_INVALID_ALIGNMENT: ErrorCodes = -2147483647;
#[doc = "< The operation failed due to an invalid size."]
pub const FFX_ERROR_INVALID_SIZE: ErrorCodes = -2147483646;
#[doc = "< The end of the file was encountered."]
pub const FFX_EOF: ErrorCodes = -2147483645;
#[doc = "< The operation failed because the specified path was invalid."]
pub const FFX_ERROR_INVALID_PATH: ErrorCodes = -2147483644;
#[doc = "< The operation failed because end of file was reached."]
pub const FFX_ERROR_EOF: ErrorCodes = -2147483643;
#[doc = "< The operation failed because of some malformed data."]
pub const FFX_ERROR_MALFORMED_DATA: ErrorCodes = -2147483642;
#[doc = "< The operation failed because it ran out memory."]
pub const FFX_ERROR_OUT_OF_MEMORY: ErrorCodes = -2147483641;
#[doc = "< The operation failed because the interface was not fully configured."]
pub const FFX_ERROR_INCOMPLETE_INTERFACE: ErrorCodes = -2147483640;
#[doc = "< The operation failed because of an invalid enumeration value."]
pub const FFX_ERROR_INVALID_ENUM: ErrorCodes = -2147483639;
#[doc = "< The operation failed because an argument was invalid."]
pub const FFX_ERROR_INVALID_ARGUMENT: ErrorCodes = -2147483638;
#[doc = "< The operation failed because a value was out of range."]
pub const FFX_ERROR_OUT_OF_RANGE: ErrorCodes = -2147483637;
#[doc = "< The operation failed because a device was null."]
pub const FFX_ERROR_NULL_DEVICE: ErrorCodes = -2147483636;
#[doc = "< The operation failed because the backend API returned an error code."]
pub const FFX_ERROR_BACKEND_API_ERROR: ErrorCodes = -2147483635;
#[doc = "< The operation failed because there was not enough memory."]
pub const FFX_ERROR_INSUFFICIENT_MEMORY: ErrorCodes = -2147483634;
#[doc = " Error codes and their meaning\n\n @ingroup Errors"]
pub type ErrorCodes = ::std::os::raw::c_int;
#[doc = " Stand in type for FfxPass\n\n These will be defined for each effect individually (i.e. FfxFsr2Pass).\n They are used to fetch the proper blob index to build effect shaders\n\n @ingroup FfxInterface"]
pub type Pass = u32;
#[doc = " Get the SDK version of the backend context.\n\n Newer effects may require support that legacy versions of the SDK will not be\n able to provide. A version query is thus required to ensure an effect component\n will always be paired with a backend which will support all needed functionality.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n\n @returns\n The SDK version a backend was built with.\n\n @ingroup FfxInterface"]
pub type GetSDKVersionFunc =
    ::std::option::Option<unsafe extern "C" fn(backendInterface: *mut Interface) -> UInt32>;
#[doc = " Create and initialize the backend context.\n\n The callback function sets up the backend context for rendering.\n It will create or reference the device and create required internal data structures.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n @param [out] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreateBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effectContextId: *mut UInt32,
    ) -> ErrorCode,
>;
#[doc = " Get a list of capabilities of the device.\n\n When creating an <c><i>FfxEffectContext</i></c> it is desirable for the FFX\n core implementation to be aware of certain characteristics of the platform\n that is being targetted. This is because some optimizations which FFX SDK\n attempts to perform are more effective on certain classes of hardware than\n others, or are not supported by older hardware. In order to avoid cases\n where optimizations actually have the effect of decreasing performance, or\n reduce the breadth of support provided by FFX SDK, the FFX interface queries the\n capabilities of the device to make such decisions.\n\n For target platforms with fixed hardware support you need not implement\n this callback function by querying the device, but instead may hardcore\n what features are available on the platform.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] outDeviceCapabilities              The device capabilities structure to fill out.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type GetDeviceCapabilitiesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        outDeviceCapabilities: *mut DeviceCapabilities,
    ) -> ErrorCode,
>;
#[doc = " Destroy the backend context and dereference the device.\n\n This function is called when the <c><i>FfxEffectContext</i></c> is destroyed.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, effectContextId: UInt32) -> ErrorCode,
>;
#[doc = " Create a resource.\n\n This callback is intended for the backend to create internal resources.\n\n Please note: It is also possible that the creation of resources might\n itself cause additional resources to be created by simply calling the\n <c><i>FfxCreateResourceFunc</i></c> function pointer again. This is\n useful when handling the initial creation of resources which must be\n initialized. The flow in such a case would be an initial call to create the\n CPU-side resource, another to create the GPU-side resource, and then a call\n to schedule a copy render job to move the data between the two. Typically\n this type of function call flow is only seen during the creation of an\n <c><i>FfxEffectContext</i></c>.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] createResourceDescription           A pointer to a <c><i>FfxCreateResourceDescription</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outResource                        A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreateResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        createResourceDescription: *const CreateResourceDescription,
        effectContextId: UInt32,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Register a resource in the backend for the current frame.\n\n Since the FfxInterface and the backends are not aware how many different\n resources will get passed in over time, it's not safe\n to register all resources simultaneously in the backend.\n Also passed resources may not be valid after the dispatch call.\n As a result it's safest to register them as FfxResourceInternal\n and clear them at the end of the dispatch call.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] inResource                          A pointer to a <c><i>FfxResource</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outResource                        A pointer to a <c><i>FfxResourceInternal</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type RegisterResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        inResource: *const Resource,
        effectContextId: UInt32,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Get an FfxResource from an FfxResourceInternal resource.\n\n At times it is necessary to create an FfxResource representation\n of an internally created resource in order to register it with a\n child effect context. This function sets up the FfxResource needed\n to register.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            The <c><i>FfxResourceInternal</i></c> for which to setup an FfxResource.\n\n @returns\n An FfxResource built from the internal resource\n\n @ingroup FfxInterface"]
pub type GetResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, resource: ResourceInternal) -> Resource,
>;
#[doc = " Unregister all temporary FfxResourceInternal from the backend.\n\n Unregister FfxResourceInternal referencing resources passed to\n a function as a parameter.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type UnregisterResourcesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        commandList: CommandList,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Retrieve a <c><i>FfxResourceDescription</i></c> matching a\n <c><i>FfxResource</i></c> structure.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @returns\n A description of the resource.\n\n @ingroup FfxInterface"]
pub type GetResourceDescriptionFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
    ) -> ResourceDescription,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Create a render pipeline.\n\n A rendering pipeline contains the shader as well as resource bindpoints\n and samplers.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] pass                                The identifier for the pass.\n @param [in] pipelineDescription                 A pointer to a <c><i>FfxPipelineDescription</i></c> describing the pipeline to be created.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outPipeline                        A pointer to a <c><i>FfxPipelineState</i></c> structure which should be populated.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreatePipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effect: Effect,
        pass: Pass,
        permutationOptions: u32,
        pipelineDescription: *const PipelineDescription,
        effectContextId: UInt32,
        outPipeline: *mut PipelineState,
    ) -> ErrorCode,
>;
pub type GetPermutationBlobByIndexFunc = ::std::option::Option<
    unsafe extern "C" fn(
        effectId: Effect,
        passId: Pass,
        bindStage: BindStage,
        permutationOptions: u32,
        outBlob: *mut ShaderBlob,
    ) -> ErrorCode,
>;
#[doc = " Destroy a render pipeline.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] pipeline                           A pointer to a <c><i>FfxPipelineState</i></c> structure which should be released.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyPipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        pipeline: *mut PipelineState,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Schedule a render job to be executed on the next call of\n <c><i>FfxExecuteGpuJobsFunc</i></c>.\n\n Render jobs can perform one of three different tasks: clear, copy or\n compute dispatches.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] job                                 A pointer to a <c><i>FfxGpuJobDescription</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type ScheduleGpuJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        job: *const GpuJobDescription,
    ) -> ErrorCode,
>;
#[doc = " Execute scheduled render jobs on the <c><i>comandList</i></c> provided.\n\n The recording of the graphics API commands should take place in this\n callback function, the render jobs which were previously enqueued (via\n callbacks made to <c><i>FfxScheduleGpuJobFunc</i></c>) should be\n processed in the order they were received. Advanced users might choose to\n reorder the rendering jobs, but should do so with care to respect the\n resource dependencies.\n\n Depending on the precise contents of <c><i>FfxDispatchDescription</i></c> a\n different number of render jobs might have previously been enqueued (for\n example if sharpening is toggled on and off).\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type ExecuteGpuJobsFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, commandList: CommandList) -> ErrorCode,
>;
pub type PresentCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(params: *const PresentCallbackDescription) -> ErrorCode,
>;
pub type FrameGenerationDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(params: *const FrameGenerationDispatchDescription) -> ErrorCode,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameGenerationConfig {
    pub swapChain: Swapchain,
    pub presentCallback: PresentCallbackFunc,
    pub frameGenerationCallback: FrameGenerationDispatchFunc,
    pub frameGenerationEnabled: bool,
    pub allowAsyncWorkloads: bool,
    pub HUDLessColor: Resource,
    pub flags: UInt32,
    pub onlyPresentInterpolated: bool,
}
impl Default for FrameGenerationConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SwapChainConfigureFrameGenerationFunc =
    ::std::option::Option<unsafe extern "C" fn(config: *const FrameGenerationConfig) -> ErrorCode>;
#[doc = " A structure encapsulating the interface between the core implementation of\n the FfxInterface and any graphics API that it should ultimately call.\n\n This set of functions serves as an abstraction layer between FfxInterfae and the\n API used to implement it. While the FidelityFX SDK ships with backends for DirectX12 and\n Vulkan, it is possible to implement your own backend for other platforms\n which sit on top of your engine's own abstraction layer. For details on the\n expectations of what each function should do you should refer the\n description of the following function pointer types:\n\n     <c><i>FfxCreateDeviceFunc</i></c>\n     <c><i>FfxGetDeviceCapabilitiesFunc</i></c>\n     <c><i>FfxDestroyDeviceFunc</i></c>\n     <c><i>FfxCreateResourceFunc</i></c>\n     <c><i>FfxRegisterResourceFunc</i></c>\n     <c><i>FfxGetResourceFunc</i></c>\n     <c><i>FfxUnregisterResourcesFunc</i></c>\n     <c><i>FfxGetResourceDescriptionFunc</i></c>\n     <c><i>FfxDestroyResourceFunc</i></c>\n     <c><i>FfxCreatePipelineFunc</i></c>\n     <c><i>FfxDestroyPipelineFunc</i></c>\n     <c><i>FfxScheduleGpuJobFunc</i></c>\n     <c><i>FfxExecuteGpuJobsFunc</i></c>\n\n Depending on the graphics API that is abstracted by the backend, it may be\n required that the backend is to some extent stateful. To ensure that\n applications retain full control to manage the memory used by the FidelityFX SDK, the\n <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields are\n provided. A backend should provide a means of specifying how much scratch\n memory is required for its internal implementation (e.g: via a function\n or constant value). The application is then responsible for allocating that\n memory and providing it when setting up the SDK backend. Backends provided\n with the FidelityFX SDK do not perform dynamic memory allocations, and instead\n sub-allocate all memory from the scratch buffers provided.\n\n The <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields\n should be populated according to the requirements of each backend. For\n example, if using the DirectX 12 backend you should call the\n <c><i>ffxGetScratchMemorySizeDX12</i></c> function. It is not required\n that custom backend implementations use a scratch buffer.\n\n Any functional addition to this interface mandates a version\n bump to ensure full functionality across effects and backends.\n\n @ingroup FfxInterface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Interface {
    #[doc = "< A callback function to query the SDK version."]
    pub fpGetSDKVersion: GetSDKVersionFunc,
    #[doc = "< A callback function to create and initialize the backend context."]
    pub fpCreateBackendContext: CreateBackendContextFunc,
    #[doc = "< A callback function to query device capabilities."]
    pub fpGetDeviceCapabilities: GetDeviceCapabilitiesFunc,
    #[doc = "< A callback function to destroy the backend context. This also dereferences the device."]
    pub fpDestroyBackendContext: DestroyBackendContextFunc,
    #[doc = "< A callback function to create a resource."]
    pub fpCreateResource: CreateResourceFunc,
    #[doc = "< A callback function to register an external resource."]
    pub fpRegisterResource: RegisterResourceFunc,
    #[doc = "< A callback function to convert an internal resource to external resource type"]
    pub fpGetResource: GetResourceFunc,
    #[doc = "< A callback function to unregister external resource."]
    pub fpUnregisterResources: UnregisterResourcesFunc,
    #[doc = "< A callback function to retrieve a resource description."]
    pub fpGetResourceDescription: GetResourceDescriptionFunc,
    #[doc = "< A callback function to destroy a resource."]
    pub fpDestroyResource: DestroyResourceFunc,
    #[doc = "< A callback function to create a render or compute pipeline."]
    pub fpCreatePipeline: CreatePipelineFunc,
    pub fpGetPermutationBlobByIndex: GetPermutationBlobByIndexFunc,
    #[doc = "< A callback function to destroy a render or compute pipeline."]
    pub fpDestroyPipeline: DestroyPipelineFunc,
    #[doc = "< A callback function to schedule a render job."]
    pub fpScheduleGpuJob: ScheduleGpuJobFunc,
    #[doc = "< A callback function to execute all queued render jobs."]
    pub fpExecuteGpuJobs: ExecuteGpuJobsFunc,
    #[doc = "< A callback function to configure swap chain present callback."]
    pub fpSwapChainConfigureFrameGeneration: SwapChainConfigureFrameGenerationFunc,
    #[doc = "< A preallocated buffer for memory utilized internally by the backend."]
    pub scratchBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the buffer pointed to by <c><i>scratchBuffer</i></c>."]
    pub scratchBufferSize: usize,
    #[doc = "< A backend specific device"]
    pub device: Device,
}
impl Default for Interface {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< A pass which performs depth clipping."]
pub const FFX_FSR3UPSCALER_PASS_DEPTH_CLIP: Fsr3UpscalerPass = 0;
#[doc = "< A pass which performs reconstruction of previous frame's depth."]
pub const FFX_FSR3UPSCALER_PASS_RECONSTRUCT_PREVIOUS_DEPTH: Fsr3UpscalerPass = 1;
#[doc = "< A pass which calculates pixel locks."]
pub const FFX_FSR3UPSCALER_PASS_LOCK: Fsr3UpscalerPass = 2;
#[doc = "< A pass which performs upscaling."]
pub const FFX_FSR3UPSCALER_PASS_ACCUMULATE: Fsr3UpscalerPass = 3;
#[doc = "< A pass which performs upscaling when sharpening is used."]
pub const FFX_FSR3UPSCALER_PASS_ACCUMULATE_SHARPEN: Fsr3UpscalerPass = 4;
#[doc = "< A pass which performs sharpening."]
pub const FFX_FSR3UPSCALER_PASS_RCAS: Fsr3UpscalerPass = 5;
#[doc = "< A pass which generates the luminance mipmap chain for the current frame."]
pub const FFX_FSR3UPSCALER_PASS_COMPUTE_LUMINANCE_PYRAMID: Fsr3UpscalerPass = 6;
#[doc = "< An optional pass to generate a reactive mask."]
pub const FFX_FSR3UPSCALER_PASS_GENERATE_REACTIVE: Fsr3UpscalerPass = 7;
#[doc = "< DEPRECATED - NO LONGER SUPPORTED"]
pub const FFX_FSR3UPSCALER_PASS_TCR_AUTOGENERATE: Fsr3UpscalerPass = 8;
#[doc = "< The number of passes performed by FSR3."]
pub const FFX_FSR3UPSCALER_PASS_COUNT: Fsr3UpscalerPass = 9;
#[doc = " An enumeration of all the passes which constitute the FSR3 algorithm.\n\n FSR3 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr3UpscalerScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr3UpscalerPass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR3\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR3UPSCALER_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR3UPSCALER_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr3UpscalerContext</i></c> is created and the\n precise contents of <c><i>FfxFsr3UpscalerDispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr3UpscalerContextDispatch</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerPass = ::std::os::raw::c_int;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.0x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_NATIVEAA: Fsr3UpscalerQualityMode = 0;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_QUALITY: Fsr3UpscalerQualityMode = 1;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_BALANCED: Fsr3UpscalerQualityMode = 2;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_PERFORMANCE: Fsr3UpscalerQualityMode = 3;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE: Fsr3UpscalerQualityMode = 4;
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 3 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR3. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerQualityMode = ::std::os::raw::c_int;
#[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
pub const FFX_FSR3UPSCALER_ENABLE_HIGH_DYNAMIC_RANGE: Fsr3UpscalerInitializationFlagBits = 1;
#[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
pub const FFX_FSR3UPSCALER_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS:
    Fsr3UpscalerInitializationFlagBits = 2;
#[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
pub const FFX_FSR3UPSCALER_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION:
    Fsr3UpscalerInitializationFlagBits = 4;
#[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
pub const FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED: Fsr3UpscalerInitializationFlagBits = 8;
#[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
pub const FFX_FSR3UPSCALER_ENABLE_DEPTH_INFINITE: Fsr3UpscalerInitializationFlagBits = 16;
#[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
pub const FFX_FSR3UPSCALER_ENABLE_AUTO_EXPOSURE: Fsr3UpscalerInitializationFlagBits = 32;
#[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
pub const FFX_FSR3UPSCALER_ENABLE_DYNAMIC_RESOLUTION: Fsr3UpscalerInitializationFlagBits = 64;
#[doc = "< A bit indicating that the backend should use 1D textures."]
pub const FFX_FSR3UPSCALER_ENABLE_TEXTURE1D_USAGE: Fsr3UpscalerInitializationFlagBits = 128;
#[doc = "< A bit indicating that the runtime should check some API values and report issues."]
pub const FFX_FSR3UPSCALER_ENABLE_DEBUG_CHECKING: Fsr3UpscalerInitializationFlagBits = 256;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr3UpscalerContext</i></c>. See <c><i>FfxFsr3UpscalerContextDescription</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerInitializationFlagBits = ::std::os::raw::c_int;
#[doc = " Pass a string message\n\n Used for debug messages.\n\n @param [in] type                       The type of message.\n @param [in] message                    A string message to pass.\n\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerMessage =
    ::std::option::Option<unsafe extern "C" fn(type_: MsgType, message: *const u16)>;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 3 upscaling.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3UpscalerContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr3UpscalerInitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub displaySize: Dimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
    #[doc = "< A pointer to a function that can receive messages from the runtime."]
    pub fpMessage: Fsr3UpscalerMessage,
}
impl Default for Fsr3UpscalerContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 3.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3UpscalerDispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR3UPSCALER_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit dilated depth and share with following effects."]
    pub dilatedDepth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit dilated motion vectors and share with following effects."]
    pub dilatedMotionVectors: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit reconstructed previous nearest depth and share with following effects."]
    pub reconstructedPrevNearestDepth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub output: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
}
impl Default for Fsr3UpscalerDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3UpscalerGenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for Fsr3UpscalerGenerateReactiveDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the resource descriptions for shared resources for this effect.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3UpscalerSharedResourceDescriptions {
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>reconstructedPrevNearestDepth</i></c> shared resource."]
    pub reconstructedPrevNearestDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedDepth</i></c> shared resource."]
    pub dilatedDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedMotionVectors</i></c> shared resource."]
    pub dilatedMotionVectors: CreateResourceDescription,
}
impl Default for Fsr3UpscalerSharedResourceDescriptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 3 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3UpscalerContext</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3UpscalerContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for Fsr3UpscalerContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 3 context from the parameters\n programmed to the <c><i>FfxFsr3UpscalerCreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3UpscalerContext</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3UpscalerContext</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3UpscalerDispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3UpscalerContext</i></c> is created, you should use the\n <c><i>ffxFsr3UpscalerContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3UpscalerContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3UpscalerContext</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3UpscalerContextDestroy</i></c>.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure to populate.\n @param [in]  pContextDescription     A pointer to a <c><i>FfxFsr3UpscalerContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3UpscalerContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextCreate"]
    pub fn Fsr3UpscalerContextCreate(
        pContext: *mut Fsr3UpscalerContext,
        pContextDescription: *const Fsr3UpscalerContextDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Provides the descriptions for shared resources that must be allocated for this effect.\n\n @param [in] context\t\t\t\t\tA pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [out] SharedResources\t\tA pointer to a <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> to populate.\n\n @returns\n FFX_OK\t\t\t\t\t\t\t\tThe operation completed successfully.\n @returns\n Anything else\t\t\t\t\t\tThe operation failed.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetSharedResourceDescriptions"]
    pub fn Fsr3UpscalerGetSharedResourceDescriptions(
        context: *mut Fsr3UpscalerContext,
        SharedResources: *mut Fsr3UpscalerSharedResourceDescriptions,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 3.\n\n FSR3 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr3UpscalerContextDispatch</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr3UpscalerContext</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr3UpscalerContext</i></c> correctly\n programming the <c><i>FfxFsr3UpscalerDispatchDescription</i></c> is key to ensuring\n the correct operation of FSR3. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR3 provides the\n <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c> and\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchDescription</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR3.\n\n @param [in] pContext                 A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [in] pDispatchDescription     A pointer to a <c><i>FfxFsr3UpscalerDispatchDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchDescription.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextDispatch"]
    pub fn Fsr3UpscalerContextDispatch(
        pContext: *mut Fsr3UpscalerContext,
        pDispatchDescription: *const Fsr3UpscalerDispatchDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] pContext                 A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [in] pParams                  A pointer to a <c><i>FfxFsr3UpscalerGenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextGenerateReactiveMask"]
    pub fn Fsr3UpscalerContextGenerateReactiveMask(
        pContext: *mut Fsr3UpscalerContext,
        pParams: *const Fsr3UpscalerGenerateReactiveDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextDestroy"]
    pub fn Fsr3UpscalerContextDestroy(pContext: *mut Fsr3UpscalerContext) -> ErrorCode;
}
extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetUpscaleRatioFromQualityMode"]
    pub fn Fsr3UpscalerGetUpscaleRatioFromQualityMode(qualityMode: Fsr3UpscalerQualityMode) -> f32;
}
extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr3UpscalerGetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] pRenderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] pRenderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetRenderResolutionFromQualityMode"]
    pub fn Fsr3UpscalerGetRenderResolutionFromQualityMode(
        pRenderWidth: *mut u32,
        pRenderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: Fsr3UpscalerQualityMode,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetJitterPhaseCount"]
    pub fn Fsr3UpscalerGetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR3 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR3 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr3UpscalerGetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr3UpscalerGetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr3UpscalerGetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr3UpscalerDispatchParameters</i></c> structure in order to inform FSR3\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] pOutX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] pOutY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetJitterOffset"]
    pub fn Fsr3UpscalerGetJitterOffset(
        pOutX: *mut f32,
        pOutY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerResourceIsNull"]
    pub fn Fsr3UpscalerResourceIsNull(resource: Resource) -> bool;
}
pub const FFX_FRAMEINTERPOLATION_PASS_SETUP: FrameInterpolationPass = 0;
pub const FFX_FRAMEINTERPOLATION_PASS_RECONSTRUCT_PREV_DEPTH: FrameInterpolationPass = 1;
pub const FFX_FRAMEINTERPOLATION_PASS_GAME_MOTION_VECTOR_FIELD: FrameInterpolationPass = 2;
pub const FFX_FRAMEINTERPOLATION_PASS_OPTICAL_FLOW_VECTOR_FIELD: FrameInterpolationPass = 3;
pub const FFX_FRAMEINTERPOLATION_PASS_DISOCCLUSION_MASK: FrameInterpolationPass = 4;
pub const FFX_FRAMEINTERPOLATION_PASS_INTERPOLATION: FrameInterpolationPass = 5;
pub const FFX_FRAMEINTERPOLATION_PASS_INPAINTING_PYRAMID: FrameInterpolationPass = 6;
pub const FFX_FRAMEINTERPOLATION_PASS_INPAINTING: FrameInterpolationPass = 7;
pub const FFX_FRAMEINTERPOLATION_PASS_GAME_VECTOR_FIELD_INPAINTING_PYRAMID: FrameInterpolationPass =
    8;
pub const FFX_FRAMEINTERPOLATION_PASS_DEBUG_VIEW: FrameInterpolationPass = 9;
#[doc = "< The number of passes performed by FrameInterpolation."]
pub const FFX_FRAMEINTERPOLATION_PASS_COUNT: FrameInterpolationPass = 10;
#[doc = " An enumeration of all the passes which constitute the FSR3 algorithm.\n\n FSR3 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr3ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr3Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR3\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR3_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR3_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr3Context</i></c> is created and the\n precise contents of <c><i>FfxFsr3DispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr3ContextDispatch</i></c>.\n\n @ingroup FRAMEINTERPOLATIONFRAMEINTERPOLATION"]
pub type FrameInterpolationPass = ::std::os::raw::c_int;
#[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_DEPTH_INVERTED: FrameInterpolationInitializationFlagBits =
    1;
#[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_DEPTH_INFINITE: FrameInterpolationInitializationFlagBits =
    2;
#[doc = "< A bit indicating that the backend should use 1D textures."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_TEXTURE1D_USAGE: FrameInterpolationInitializationFlagBits =
    4;
#[doc = "< A bit indicating that HDR values are present in the imaging pipeline."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_HDR_COLOR_INPUT: FrameInterpolationInitializationFlagBits =
    8;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFrameInterpolationContext</i></c>. See <c><i>FfxFrameInterpolationContextDescription</i></c>.\n\n @ingroup FRAMEINTERPOLATIONFRAMEINTERPOLATION"]
pub type FrameInterpolationInitializationFlagBits = ::std::os::raw::c_int;
#[doc = " A structure encapsulating the parameters required to initialize\n FidelityFX Frameinterpolation upscaling.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FrameInterpolationContextDescription {
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
    #[doc = "< A collection of <c><i>FfxFrameInterpolationInitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution"]
    pub displaySize: Dimensions2D,
    pub backBufferFormat: SurfaceFormat,
}
impl Default for FrameInterpolationContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 2 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3Context</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FrameInterpolationContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for FrameInterpolationContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 2 context from the parameters\n programmed to the <c><i>FfxFsr3CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3Context</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3Context</i></c> is created, you should use the\n <c><i>ffxFsr3ContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr3ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationContextCreate"]
    pub fn FrameInterpolationContextCreate(
        context: *mut FrameInterpolationContext,
        contextDescription: *mut FrameInterpolationContextDescription,
    ) -> ErrorCode;
}
#[doc = "< A bit indicating that the debug tear lines will be drawn to the interpolated output."]
pub const FFX_FRAMEINTERPOLATION_DISPATCH_DRAW_DEBUG_TEAR_LINES: FrameInterpolationDispatchFlags =
    1;
#[doc = "< A bit indicating that the interpolated output resource will contain debug views with relevant information."]
pub const FFX_FRAMEINTERPOLATION_DISPATCH_DRAW_DEBUG_VIEW: FrameInterpolationDispatchFlags = 2;
pub type FrameInterpolationDispatchFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameInterpolationDispatchDescription {
    #[doc = "< combination of FfxFrameInterpolationDispatchFlags"]
    pub flags: u32,
    #[doc = "< The <c><i>FfxCommandList</i></c> to record frame interpolation commands into."]
    pub commandList: CommandList,
    #[doc = "< The destination output dimensions"]
    pub displaySize: Dimensions2D,
    #[doc = "< The dimensions used to render game content, dilatedDepth, dilatedMotionVectors are expected to be of ths size."]
    pub renderSize: Dimensions2D,
    #[doc = "< The current presentation color, if currentBackBuffer_HUDLess is not used, this will be used as interpolation source data."]
    pub currentBackBuffer: Resource,
    #[doc = "< The current presentation color without HUD content, when use it will be used as interpolation source data."]
    pub currentBackBuffer_HUDLess: Resource,
    #[doc = "< The output resource where to store the interpolated result."]
    pub output: Resource,
    #[doc = "< The dilated depth buffer data (see example computation in the FfxFsr3Upscaler effect)"]
    pub dilatedDepth: Resource,
    #[doc = "< The dilated motion vector data (see example computation in the FfxFsr3Upscaler effect)"]
    pub dilatedMotionVectors: Resource,
    #[doc = "< The estimated previous frame depth buffer (see example computation in the FfxFsr3Upscaler effect)"]
    pub reconstructPrevNearDepth: Resource,
    #[doc = "< The area of the backbuffer that should be used for interpolation in case only a part of the screen is used e.g. due to movie bars"]
    pub interpolationRect: Rect2D,
    #[doc = "< The optical flow motion vectors (see example computation in the FfxOpticalFlow effect)"]
    pub opticalFlowVector: Resource,
    #[doc = "< The optical flow scene change detection data"]
    pub opticalFlowSceneChangeDetection: Resource,
    #[doc = "< The optical flow motion vector resource dimensions"]
    pub opticalFlowBufferSize: Dimensions2D,
    #[doc = "< The optical flow motion vector scale factor, used to scale resoure values into [0.0,1.0] range."]
    pub opticalFlowScale: FloatCoords2D,
    #[doc = "< The optical flow block dimension size"]
    pub opticalFlowBlockSize: ::std::os::raw::c_int,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The unit to scale view space coordinates to meters."]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The transfer function use to convert interpolation source color data to linear RGB."]
    pub backBufferTransferFunction: BackbufferTransferFunction,
    #[doc = "< Min and max luminance values, used when converting HDR colors to linear RGB"]
    pub minMaxLuminance: [f32; 2usize],
}
impl Default for FrameInterpolationDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationDispatch"]
    pub fn FrameInterpolationDispatch(
        context: *mut FrameInterpolationContext,
        params: *const FrameInterpolationDispatchDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationContextDestroy"]
    pub fn FrameInterpolationContextDestroy(context: *mut FrameInterpolationContext) -> ErrorCode;
}
pub const FFX_OPTICALFLOW_PASS_PREPARE_LUMA: OpticalflowPass = 0;
pub const FFX_OPTICALFLOW_PASS_GENERATE_OPTICAL_FLOW_INPUT_PYRAMID: OpticalflowPass = 1;
pub const FFX_OPTICALFLOW_PASS_GENERATE_SCD_HISTOGRAM: OpticalflowPass = 2;
pub const FFX_OPTICALFLOW_PASS_COMPUTE_SCD_DIVERGENCE: OpticalflowPass = 3;
pub const FFX_OPTICALFLOW_PASS_COMPUTE_OPTICAL_FLOW_ADVANCED_V5: OpticalflowPass = 4;
pub const FFX_OPTICALFLOW_PASS_FILTER_OPTICAL_FLOW_V5: OpticalflowPass = 5;
pub const FFX_OPTICALFLOW_PASS_SCALE_OPTICAL_FLOW_ADVANCED_V5: OpticalflowPass = 6;
pub const FFX_OPTICALFLOW_PASS_COUNT: OpticalflowPass = 7;
#[doc = " An enumeration of all the passes which constitute the OpticalFlow algorithm.\n\n @ingroup ffxOpticalflow"]
pub type OpticalflowPass = ::std::os::raw::c_int;
pub const FFX_OPTICALFLOW_ENABLE_TEXTURE1D_USAGE: OpticalflowInitializationFlagBits = 1;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxOpticalflowContext</i></c>. See <c><i>FfxOpticalflowDispatchDescription</i></c>.\n\n @ingroup ffxOpticalflow"]
pub type OpticalflowInitializationFlagBits = ::std::os::raw::c_int;
#[doc = " A structure encapsulating the parameters required to initialize\n FidelityFX OpticalFlow.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpticalflowContextDescription {
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
    #[doc = "< A collection of <c><i>FfxOpticalflowInitializationFlagBits</i></c>."]
    pub flags: u32,
    pub resolution: Dimensions2D,
}
impl Default for OpticalflowContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Opticalflow.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpticalflowDispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the input color buffer"]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output motion buffer"]
    pub opticalFlowVector: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output scene change detection buffer"]
    pub opticalFlowSCD: Resource,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    pub backbufferTransferFunction: ::std::os::raw::c_int,
    pub minMaxLuminance: FloatCoords2D,
}
impl Default for OpticalflowDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpticalflowSharedResourceDescriptions {
    pub opticalFlowVector: CreateResourceDescription,
    pub opticalFlowSCD: CreateResourceDescription,
}
impl Default for OpticalflowSharedResourceDescriptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX OpticalFlow context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by OpticalFlow.\n\n The <c><i>FfxOpticalflowContext</i></c> object should have a lifetime matching\n your use of OpticalFlow. Before destroying the OpticalFlow context care should be taken\n to ensure the GPU is not accessing the resources created or used by OpticalFlow.\n It is therefore recommended that the GPU is idle before destroying OpticalFlow\n OpticalFlow context.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpticalflowContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for OpticalflowContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX OpticalFlow context from the parameters\n programmed to the <c><i>FfxOpticalflowContextDescription</i></c> structure.\n\n The context structure is the main object used to interact with the OpticalFlow\n API, and is responsible for the management of the internal resources used\n by the OpticalFlow algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by OpticalFlow's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxOpticalflowContext</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxOpticalflowContext</i></c> how match the configuration of your\n application as well as the intended use of OpticalFlow. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxOpticalflowContextDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how OpticalFlow should be integerated into an application.\n\n When the <c><i>FfxOpticalflowContext</i></c> is created, you should use the\n <c><i>ffxOpticalflowContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxOpticalflowContextDispatch</i></c> for more details.\n\n The <c><i>FfxOpticalflowContext</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or OpticalFlow is\n disabled by a user. To destroy the OpticalFlow context you should call\n <c><i>ffxOpticalflowContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxOpticalflowContext</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxOpticalflowContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxOpticalflowContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxOpticalflow"]
    #[link_name = "\u{1}ffxOpticalflowContextCreate"]
    pub fn OpticalflowContextCreate(
        context: *mut OpticalflowContext,
        contextDescription: *mut OpticalflowContextDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxOpticalflowGetSharedResourceDescriptions"]
    pub fn OpticalflowGetSharedResourceDescriptions(
        context: *mut OpticalflowContext,
        SharedResources: *mut OpticalflowSharedResourceDescriptions,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxOpticalflowContextDispatch"]
    pub fn OpticalflowContextDispatch(
        context: *mut OpticalflowContext,
        dispatchDescription: *const OpticalflowDispatchDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX OpticalFlow context.\n\n @param [out] context                A pointer to a <c><i>FfxOpticalflowContext</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup ffxOpticalflow"]
    #[link_name = "\u{1}ffxOpticalflowContextDestroy"]
    pub fn OpticalflowContextDestroy(context: *mut OpticalflowContext) -> ErrorCode;
}
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
pub const FFX_FSR3_QUALITY_MODE_QUALITY: Fsr3QualityMode = 1;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
pub const FFX_FSR3_QUALITY_MODE_BALANCED: Fsr3QualityMode = 2;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
pub const FFX_FSR3_QUALITY_MODE_PERFORMANCE: Fsr3QualityMode = 3;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
pub const FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE: Fsr3QualityMode = 4;
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 2 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR3. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup FSR3"]
pub type Fsr3QualityMode = ::std::os::raw::c_int;
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating if the input color data provided to all inputs is using a high-dynamic range."]
    pub const FFX_FSR3_ENABLE_HIGH_DYNAMIC_RANGE: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(1);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
    pub const FFX_FSR3_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(2);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
    pub const FFX_FSR3_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(4);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const FFX_FSR3_ENABLE_DEPTH_INVERTED: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(8);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const FFX_FSR3_ENABLE_DEPTH_INFINITE: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(16);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
    pub const FFX_FSR3_ENABLE_AUTO_EXPOSURE: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(32);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
    pub const FFX_FSR3_ENABLE_DYNAMIC_RESOLUTION: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(64);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the backend should use 1D textures."]
    pub const FFX_FSR3_ENABLE_TEXTURE1D_USAGE: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(128);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const FFX_FSR3_ENABLE_DEBUG_CHECKING: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(256);
}
impl Fsr3InitializationFlagBits {
    pub const FFX_FSR3_ENABLE_UPSCALING_ONLY: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(512);
}
impl Fsr3InitializationFlagBits {
    #[doc = ", A bit indicating that the context will only be used for upscaling"]
    pub const FFX_FSR3_ENABLE_HDR_UPSCALE_SDR_FINALOUTPUT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(1024);
}
impl Fsr3InitializationFlagBits {
    #[doc = ", A bit indicating if the input color data provided to UPSCALE is using a high-dynamic range, final output SDR."]
    pub const FFX_FSR3_ENABLE_SDR_UPSCALE_HDR_FINALOUTPUT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(2048);
}
impl Fsr3InitializationFlagBits {
    #[doc = ", A bit indicating if the input color data provided to UPSCALE is using SDR, final output is high-dynamic range."]
    pub const FFX_FSR3_ENABLE_ASYNC_WORKLOAD_SUPPORT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(4096);
}
impl ::std::ops::BitOr<Fsr3InitializationFlagBits> for Fsr3InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        Fsr3InitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for Fsr3InitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: Fsr3InitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<Fsr3InitializationFlagBits> for Fsr3InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Fsr3InitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for Fsr3InitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: Fsr3InitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr3Context</i></c>. See <c><i>FfxFsr3ContextDescription</i></c>.\n\n @ingroup FSR3"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Fsr3InitializationFlagBits(pub ::std::os::raw::c_int);
#[doc = "< A bit indicating that the debug tear lines will be drawn to the interpolated output."]
pub const FFX_FSR3_FRAME_GENERATION_FLAG_DRAW_DEBUG_TEAR_LINES: Fsr3FrameGenerationFlags = 1;
#[doc = "< A bit indicating that the interpolated output resource will contain debug views with relevant information."]
pub const FFX_FSR3_FRAME_GENERATION_FLAG_DRAW_DEBUG_VIEW: Fsr3FrameGenerationFlags = 2;
pub type Fsr3FrameGenerationFlags = ::std::os::raw::c_int;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 3 upscaling.\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3ContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr3InitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub upscaleOutputSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the frame interpolation process."]
    pub displaySize: Dimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceSharedResources: Interface,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceUpscaling: Interface,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceFrameInterpolation: Interface,
    #[doc = "< A pointer to a function that can recieve messages from the runtime."]
    pub fpMessage: Fsr3UpscalerMessage,
    #[doc = "< The format of the swapchain surface"]
    pub backBufferFormat: SurfaceFormat,
}
impl Default for Fsr3ContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 3.\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3DispatchUpscaleDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub upscaleOutput: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
}
impl Default for Fsr3DispatchUpscaleDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}ffxFsr3DispatchFrameGeneration"]
    pub fn Fsr3DispatchFrameGeneration(
        desc: *const FrameGenerationDispatchDescription,
    ) -> ErrorCode;
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3GenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for Fsr3GenerateReactiveDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 3 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3Context</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3Context {
    pub data: [u32; 409752usize],
}
impl Default for Fsr3Context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 3 context from the parameters\n programmed to the <c><i>FfxFsr3CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3Context</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3Context</i></c> is created, you should use the\n <c><i>ffxFsr3ContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr3ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextCreate"]
    pub fn Fsr3ContextCreate(
        context: *mut Fsr3Context,
        contextDescription: *mut Fsr3ContextDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 3 Upscaling.\n\n FSR3 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr3ContextDispatchUpscale</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr3Context</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr3Context</i></c> correctly\n programming the <c><i>dispatchParams</i></c> is key to ensuring\n the correct operation of FSR3. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR3 provides the\n <c><i>ffxFsr3GetJitterPhaseCount</i></c> and\n <c><i>ffxFsr3GetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchParams</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr3GetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR3.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr3Context</i></c> structure.\n @param [in] dispatchParams     A pointer to a <c><i>FfxFsr3DispatchUpscaleDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchParams</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchParams.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextDispatchUpscale"]
    pub fn Fsr3ContextDispatchUpscale(
        context: *mut Fsr3Context,
        dispatchParams: *const Fsr3DispatchUpscaleDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxFsr3SkipPresent"]
    pub fn Fsr3SkipPresent(context: *mut Fsr3Context) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr3Context</i></c> structure.\n @param [in] params                  A pointer to a <c><i>FfxFsr3GenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextGenerateReactiveMask"]
    pub fn Fsr3ContextGenerateReactiveMask(
        context: *mut Fsr3Context,
        params: *const Fsr3GenerateReactiveDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxFsr3ConfigureFrameGeneration"]
    pub fn Fsr3ConfigureFrameGeneration(
        context: *mut Fsr3Context,
        config: *const FrameGenerationConfig,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextDestroy"]
    pub fn Fsr3ContextDestroy(context: *mut Fsr3Context) -> ErrorCode;
}
extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR3_QUALITY_MODE_NATIVEAA</i></c>          | 1.0x\n <c><i>FFX_FSR3_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR3_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR3_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetUpscaleRatioFromQualityMode"]
    pub fn Fsr3GetUpscaleRatioFromQualityMode(qualityMode: Fsr3QualityMode) -> f32;
}
extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr3GetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] renderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] renderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetRenderResolutionFromQualityMode"]
    pub fn Fsr3GetRenderResolutionFromQualityMode(
        renderWidth: *mut u32,
        renderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: Fsr3QualityMode,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr3GetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR3_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR3_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR3_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetJitterPhaseCount"]
    pub fn Fsr3GetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR3 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR3 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr3GetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr3GetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr3GetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr3GetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr3GetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr3GetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr3GetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr3GetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr3DispatchParameters</i></c> structure in order to inform FSR3\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr3GetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] outX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] outY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr3GetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetJitterOffset"]
    pub fn Fsr3GetJitterOffset(
        outX: *mut f32,
        outY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ResourceIsNull"]
    pub fn Fsr3ResourceIsNull(resource: Resource) -> bool;
}
