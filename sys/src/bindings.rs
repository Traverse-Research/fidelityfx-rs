/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _STL_COMPILER_PREPROCESSOR: u32 = 1;
pub const _STL_WARNING_LEVEL: u32 = 3;
pub const _STL_DISABLED_WARNING_C4984: u32 = 4984;
pub const _STL_DISABLED_WARNING_C5053: u32 = 5053;
pub const _CPPLIB_VER: u32 = 650;
pub const _MSVC_STL_VERSION: u32 = 143;
pub const _MSVC_STL_UPDATE: u32 = 202408;
pub const _HAS_STATIC_RTTI: u32 = 1;
pub const _HAS_STD_BYTE: u32 = 0;
pub const _ENFORCE_MATCHING_ALLOCATORS: u32 = 0;
pub const _ENFORCE_FACET_SPECIALIZATIONS: u32 = 0;
pub const _FACET_SPECIALIZATION_MESSAGE : & [u8 ; 167] = b"Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 to suppress this error.\0" ;
pub const _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS: u32 = 1;
pub const _STD_VECTORIZE_WITH_FLOAT_CONTROL: u32 = 1;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_freestanding_algorithm: u32 = 202311;
pub const __cpp_lib_freestanding_array: u32 = 202311;
pub const __cpp_lib_freestanding_char_traits: u32 = 202306;
pub const __cpp_lib_freestanding_cstdlib: u32 = 202306;
pub const __cpp_lib_freestanding_cstring: u32 = 202311;
pub const __cpp_lib_freestanding_cwchar: u32 = 202306;
pub const __cpp_lib_freestanding_errc: u32 = 202306;
pub const __cpp_lib_freestanding_feature_test_macros: u32 = 202306;
pub const __cpp_lib_freestanding_functional: u32 = 202306;
pub const __cpp_lib_freestanding_iterator: u32 = 202306;
pub const __cpp_lib_freestanding_memory: u32 = 202306;
pub const __cpp_lib_freestanding_operator_new: u32 = 202306;
pub const __cpp_lib_freestanding_ratio: u32 = 202306;
pub const __cpp_lib_freestanding_tuple: u32 = 202306;
pub const __cpp_lib_freestanding_utility: u32 = 202306;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_shared_timed_mutex: u32 = 201402;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const __cpp_lib_as_const: u32 = 201510;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_map_try_emplace: u32 = 201411;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const __cpp_lib_shared_mutex: u32 = 201505;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_atomic_value_initialization: u32 = 201911;
pub const __cpp_lib_chrono: u32 = 201510;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const __cpp_lib_experimental_filesystem: u32 = 201406;
pub const _USE_EXTERN_CXX_EVERYWHERE_FOR_STL: u32 = 0;
pub const _STL_WIN32_WINNT_VISTA: u32 = 1536;
pub const _STL_WIN32_WINNT_WIN7: u32 = 1537;
pub const _STL_WIN32_WINNT_WIN8: u32 = 1538;
pub const _STL_WIN32_WINNT_WIN10: u32 = 2560;
pub const _STL_WIN32_WINNT: u32 = 1537;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 0;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_WARN: u32 = 0;
pub const _CRT_ERROR: u32 = 1;
pub const _CRT_ASSERT: u32 = 2;
pub const _CRT_ERRCNT: u32 = 3;
pub const _CRTDBG_MODE_FILE: u32 = 1;
pub const _CRTDBG_MODE_DEBUG: u32 = 2;
pub const _CRTDBG_MODE_WNDW: u32 = 4;
pub const _CRTDBG_REPORT_MODE: i32 = -1;
pub const _CRT_RPTHOOK_INSTALL: u32 = 0;
pub const _CRT_RPTHOOK_REMOVE: u32 = 1;
pub const _HOOK_ALLOC: u32 = 1;
pub const _HOOK_REALLOC: u32 = 2;
pub const _HOOK_FREE: u32 = 3;
pub const _CRTDBG_ALLOC_MEM_DF: u32 = 1;
pub const _CRTDBG_DELAY_FREE_MEM_DF: u32 = 2;
pub const _CRTDBG_CHECK_ALWAYS_DF: u32 = 4;
pub const _CRTDBG_RESERVED_DF: u32 = 8;
pub const _CRTDBG_CHECK_CRT_DF: u32 = 16;
pub const _CRTDBG_LEAK_CHECK_DF: u32 = 32;
pub const _CRTDBG_CHECK_EVERY_16_DF: u32 = 1048576;
pub const _CRTDBG_CHECK_EVERY_128_DF: u32 = 8388608;
pub const _CRTDBG_CHECK_EVERY_1024_DF: u32 = 67108864;
pub const _CRTDBG_CHECK_DEFAULT_DF: u32 = 0;
pub const _CRTDBG_REPORT_FLAG: i32 = -1;
pub const _FREE_BLOCK: u32 = 0;
pub const _NORMAL_BLOCK: u32 = 1;
pub const _CRT_BLOCK: u32 = 2;
pub const _IGNORE_BLOCK: u32 = 3;
pub const _CLIENT_BLOCK: u32 = 4;
pub const _MAX_BLOCKS: u32 = 5;
pub const _UNKNOWN_BLOCK: i32 = -1;
pub const _CRT_MSVCP_CURRENT: &[u8; 13] = b"msvcp140.dll\0";
pub const _HAS_ITERATOR_DEBUGGING: u32 = 0;
pub const _SECURE_SCL: u32 = 0;
pub const _ITERATOR_DEBUG_LEVEL: u32 = 0;
pub const _CONTAINER_DEBUG_LEVEL: u32 = 0;
pub const _ENABLE_ATOMIC_REF_ALIGNMENT_CHECK: u32 = 0;
pub const _DEBUG_AFFIX: &[u8; 1] = b"\0";
pub const _IDL_DEFAULT: u32 = 0;
pub const _LIB_STEM: &[u8; 8] = b"libcpmt\0";
pub const _IDL_AFFIX: &[u8; 1] = b"\0";
pub const _LOCK_LOCALE: u32 = 0;
pub const _LOCK_STREAM: u32 = 2;
pub const _LOCK_DEBUG: u32 = 3;
pub const _CRT_USE_CONFORMING_ANNEX_K_TIME: u32 = 0;
pub const TIME_UTC: u32 = 1;
pub const FLT_EVAL_METHOD: u32 = 0;
pub const DBL_DECIMAL_DIG: u32 = 17;
pub const DBL_DIG: u32 = 15;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const DBL_MANT_DIG: u32 = 53;
pub const DBL_MAX_10_EXP: u32 = 308;
pub const DBL_MAX_EXP: u32 = 1024;
pub const DBL_MIN_10_EXP: i32 = -307;
pub const DBL_MIN_EXP: i32 = -1021;
pub const _DBL_RADIX: u32 = 2;
pub const FLT_DECIMAL_DIG: u32 = 9;
pub const FLT_DIG: u32 = 6;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const FLT_GUARD: u32 = 0;
pub const FLT_MANT_DIG: u32 = 24;
pub const FLT_MAX_10_EXP: u32 = 38;
pub const FLT_MAX_EXP: u32 = 128;
pub const FLT_MIN_10_EXP: i32 = -37;
pub const FLT_MIN_EXP: i32 = -125;
pub const FLT_NORMALIZE: u32 = 0;
pub const FLT_RADIX: u32 = 2;
pub const LDBL_DIG: u32 = 15;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_MANT_DIG: u32 = 53;
pub const LDBL_MAX_10_EXP: u32 = 308;
pub const LDBL_MAX_EXP: u32 = 1024;
pub const LDBL_MIN_10_EXP: i32 = -307;
pub const LDBL_MIN_EXP: i32 = -1021;
pub const _LDBL_RADIX: u32 = 2;
pub const DECIMAL_DIG: u32 = 17;
pub const _SW_INEXACT: u32 = 1;
pub const _SW_UNDERFLOW: u32 = 2;
pub const _SW_OVERFLOW: u32 = 4;
pub const _SW_ZERODIVIDE: u32 = 8;
pub const _SW_INVALID: u32 = 16;
pub const _SW_DENORMAL: u32 = 524288;
pub const _EM_AMBIGUIOUS: u32 = 2147483648;
pub const _EM_AMBIGUOUS: u32 = 2147483648;
pub const _MCW_EM: u32 = 524319;
pub const _EM_INEXACT: u32 = 1;
pub const _EM_UNDERFLOW: u32 = 2;
pub const _EM_OVERFLOW: u32 = 4;
pub const _EM_ZERODIVIDE: u32 = 8;
pub const _EM_INVALID: u32 = 16;
pub const _EM_DENORMAL: u32 = 524288;
pub const _MCW_RC: u32 = 768;
pub const _RC_NEAR: u32 = 0;
pub const _RC_DOWN: u32 = 256;
pub const _RC_UP: u32 = 512;
pub const _RC_CHOP: u32 = 768;
pub const _MCW_PC: u32 = 196608;
pub const _PC_64: u32 = 0;
pub const _PC_53: u32 = 65536;
pub const _PC_24: u32 = 131072;
pub const _MCW_IC: u32 = 262144;
pub const _IC_AFFINE: u32 = 262144;
pub const _IC_PROJECTIVE: u32 = 0;
pub const _MCW_DN: u32 = 50331648;
pub const _DN_SAVE: u32 = 0;
pub const _DN_FLUSH: u32 = 16777216;
pub const _DN_FLUSH_OPERANDS_SAVE_RESULTS: u32 = 33554432;
pub const _DN_SAVE_OPERANDS_FLUSH_RESULTS: u32 = 50331648;
pub const _SW_UNEMULATED: u32 = 64;
pub const _SW_SQRTNEG: u32 = 128;
pub const _SW_STACKOVERFLOW: u32 = 512;
pub const _SW_STACKUNDERFLOW: u32 = 1024;
pub const _FPE_INVALID: u32 = 129;
pub const _FPE_DENORMAL: u32 = 130;
pub const _FPE_ZERODIVIDE: u32 = 131;
pub const _FPE_OVERFLOW: u32 = 132;
pub const _FPE_UNDERFLOW: u32 = 133;
pub const _FPE_INEXACT: u32 = 134;
pub const _FPE_UNEMULATED: u32 = 135;
pub const _FPE_SQRTNEG: u32 = 136;
pub const _FPE_STACKOVERFLOW: u32 = 138;
pub const _FPE_STACKUNDERFLOW: u32 = 139;
pub const _FPE_EXPLICITGEN: u32 = 140;
pub const _FPE_MULTIPLE_TRAPS: u32 = 141;
pub const _FPE_MULTIPLE_FAULTS: u32 = 142;
pub const _FPCLASS_SNAN: u32 = 1;
pub const _FPCLASS_QNAN: u32 = 2;
pub const _FPCLASS_NINF: u32 = 4;
pub const _FPCLASS_NN: u32 = 8;
pub const _FPCLASS_ND: u32 = 16;
pub const _FPCLASS_NZ: u32 = 32;
pub const _FPCLASS_PZ: u32 = 64;
pub const _FPCLASS_PD: u32 = 128;
pub const _FPCLASS_PN: u32 = 256;
pub const _FPCLASS_PINF: u32 = 512;
pub const _CW_DEFAULT: u32 = 524319;
pub const DBL_RADIX: u32 = 2;
pub const LDBL_RADIX: u32 = 2;
pub const EM_AMBIGUIOUS: u32 = 2147483648;
pub const EM_AMBIGUOUS: u32 = 2147483648;
pub const MCW_EM: u32 = 524319;
pub const EM_INVALID: u32 = 16;
pub const EM_DENORMAL: u32 = 524288;
pub const EM_ZERODIVIDE: u32 = 8;
pub const EM_OVERFLOW: u32 = 4;
pub const EM_UNDERFLOW: u32 = 2;
pub const EM_INEXACT: u32 = 1;
pub const MCW_IC: u32 = 262144;
pub const IC_AFFINE: u32 = 262144;
pub const IC_PROJECTIVE: u32 = 0;
pub const MCW_RC: u32 = 768;
pub const RC_CHOP: u32 = 768;
pub const RC_UP: u32 = 512;
pub const RC_DOWN: u32 = 256;
pub const RC_NEAR: u32 = 0;
pub const MCW_PC: u32 = 196608;
pub const PC_24: u32 = 131072;
pub const PC_53: u32 = 65536;
pub const PC_64: u32 = 0;
pub const CW_DEFAULT: u32 = 524319;
pub const SW_INVALID: u32 = 16;
pub const SW_DENORMAL: u32 = 524288;
pub const SW_ZERODIVIDE: u32 = 8;
pub const SW_OVERFLOW: u32 = 4;
pub const SW_UNDERFLOW: u32 = 2;
pub const SW_INEXACT: u32 = 1;
pub const SW_UNEMULATED: u32 = 64;
pub const SW_SQRTNEG: u32 = 128;
pub const SW_STACKOVERFLOW: u32 = 512;
pub const SW_STACKUNDERFLOW: u32 = 1024;
pub const FPE_INVALID: u32 = 129;
pub const FPE_DENORMAL: u32 = 130;
pub const FPE_ZERODIVIDE: u32 = 131;
pub const FPE_OVERFLOW: u32 = 132;
pub const FPE_UNDERFLOW: u32 = 133;
pub const FPE_INEXACT: u32 = 134;
pub const FPE_UNEMULATED: u32 = 135;
pub const FPE_SQRTNEG: u32 = 136;
pub const FPE_STACKOVERFLOW: u32 = 138;
pub const FPE_STACKUNDERFLOW: u32 = 139;
pub const FPE_EXPLICITGEN: u32 = 140;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const _SH_DENYRW: u32 = 16;
pub const _SH_DENYWR: u32 = 32;
pub const _SH_DENYRD: u32 = 48;
pub const _SH_DENYNO: u32 = 64;
pub const _SH_SECURE: u32 = 128;
pub const SH_DENYRW: u32 = 16;
pub const SH_DENYWR: u32 = 32;
pub const SH_DENYRD: u32 = 48;
pub const SH_DENYNO: u32 = 64;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const _S_IFMT: u32 = 61440;
pub const _S_IFDIR: u32 = 16384;
pub const _S_IFCHR: u32 = 8192;
pub const _S_IFIFO: u32 = 4096;
pub const _S_IFREG: u32 = 32768;
pub const _S_IREAD: u32 = 256;
pub const _S_IWRITE: u32 = 128;
pub const _S_IEXEC: u32 = 64;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFREG: u32 = 32768;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const _USE_STD_VECTOR_ALGORITHMS: u32 = 1;
pub const _USE_STD_VECTOR_FLOATING_ALGORITHMS: u32 = 1;
pub const _HAS_MEMCPY_MEMMOVE_INTRINSICS: u32 = 1;
pub const _HAS_U8_INTRINSICS: u32 = 0;
pub const _STD_ATOMIC_USE_ARM64_LDAR_STLR: u32 = 0;
pub const ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const _CMPXCHG_MASK_OUT_PADDING_BITS: u32 = 0;
pub const _P_WAIT: u32 = 0;
pub const _P_NOWAIT: u32 = 1;
pub const _OLD_P_OVERLAY: u32 = 2;
pub const _P_NOWAITO: u32 = 3;
pub const _P_DETACH: u32 = 4;
pub const _P_OVERLAY: u32 = 2;
pub const _WAIT_CHILD: u32 = 0;
pub const _WAIT_GRANDCHILD: u32 = 1;
pub const P_WAIT: u32 = 0;
pub const P_NOWAIT: u32 = 1;
pub const P_OVERLAY: u32 = 2;
pub const OLD_P_OVERLAY: u32 = 2;
pub const P_NOWAITO: u32 = 3;
pub const P_DETACH: u32 = 4;
pub const WAIT_CHILD: u32 = 0;
pub const WAIT_GRANDCHILD: u32 = 1;
pub const FFX_SDK_DEFAULT_CONTEXT_SIZE: u32 = 131072;
pub const FFX_MAX_NUM_SRVS: u32 = 64;
pub const FFX_MAX_NUM_UAVS: u32 = 64;
pub const FFX_MAX_NUM_CONST_BUFFERS: u32 = 3;
pub const FFX_RESOURCE_NAME_SIZE: u32 = 64;
pub const FFX_MAX_QUEUED_FRAMES: u32 = 4;
pub const FFX_MAX_RESOURCE_COUNT: u32 = 512;
pub const FFX_MAX_PASS_COUNT: u32 = 50;
pub const FFX_RING_BUFFER_DESCRIPTOR_COUNT: u32 = 102400;
pub const FFX_BUFFER_SIZE: u32 = 4096;
pub const FFX_CONSTANT_BUFFER_RING_BUFFER_SIZE: u32 = 819200;
pub const FFX_MAX_BARRIERS: u32 = 128;
pub const FFX_MAX_GPU_JOBS: u32 = 256;
pub const FFX_MAX_SAMPLERS: u32 = 16;
pub const UPLOAD_JOB_COUNT: u32 = 16;
pub const FFX_UNSPECIFIED_VERSION: u32 = 4294946048;
pub const FFX_MAXIMUM_PATH: u32 = 260;
pub const FFX_SDK_VERSION_MAJOR: u32 = 1;
pub const FFX_SDK_VERSION_MINOR: u32 = 1;
pub const FFX_SDK_VERSION_PATCH: u32 = 4;
pub const FFX_FSR3UPSCALER_VERSION_MAJOR: u32 = 3;
pub const FFX_FSR3UPSCALER_VERSION_MINOR: u32 = 1;
pub const FFX_FSR3UPSCALER_VERSION_PATCH: u32 = 4;
pub const FFX_FSR3UPSCALER_CONTEXT_COUNT: u32 = 1;
pub const FFX_FSR3UPSCALER_CONTEXT_SIZE: u32 = 131072;
pub const FFX_FRAMEINTERPOLATION_VERSION_MAJOR: u32 = 1;
pub const FFX_FRAMEINTERPOLATION_VERSION_MINOR: u32 = 1;
pub const FFX_FRAMEINTERPOLATION_VERSION_PATCH: u32 = 3;
pub const FFX_FRAMEINTERPOLATION_CONTEXT_COUNT: u32 = 1;
pub const FFX_FRAMEINTERPOLATION_CONTEXT_SIZE: u32 = 131072;
pub const FFX_OPTICALFLOW_VERSION_MAJOR: u32 = 1;
pub const FFX_OPTICALFLOW_VERSION_MINOR: u32 = 1;
pub const FFX_OPTICALFLOW_VERSION_PATCH: u32 = 2;
pub const FFX_OPTICALFLOW_CONTEXT_COUNT: u32 = 1;
pub const FFX_OPTICALFLOW_CONTEXT_SIZE: u32 = 131072;
pub const FFX_FSR3_VERSION_MAJOR: u32 = 3;
pub const FFX_FSR3_VERSION_MINOR: u32 = 1;
pub const FFX_FSR3_VERSION_PATCH: u32 = 4;
pub const FFX_FSR3_CONTEXT_COUNT: u32 = 4;
pub const FFX_FSR3_CONTEXT_SIZE: u32 = 524288;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __the_value: __vcrt_va_list_is_reference__bindgen_ty_1 = false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const u16,
        _FunctionName: *const u16,
        _FileName: *const u16,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_nothrow_t {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}nothrow"]
    pub static std_nothrow: std_nothrow_t;
}
pub const _Noinit: std__Uninitialized = 0;
pub type std__Uninitialized = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default)]
pub struct std__Lockit {
    pub _Locktype: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_Lockit_ctor"]
    pub fn std__Lockit__Lockit_ctor(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Lockit_dtor"]
    pub fn std__Lockit__Lockit_dtor(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Lockit"]
    pub fn std__Lockit__Lockit(this: *mut std__Lockit);
}
extern "C" {
    #[link_name = "\u{1}_Lockit"]
    pub fn std__Lockit__Lockit1(this: *mut std__Lockit, arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Lockit_destructor"]
    pub fn std__Lockit__Lockit_destructor(this: *mut std__Lockit);
}
impl std__Lockit {
    #[inline]
    pub unsafe fn _Lockit_ctor(arg1: ::std::os::raw::c_int) {
        std__Lockit__Lockit_ctor(arg1)
    }
    #[inline]
    pub unsafe fn _Lockit_dtor(arg1: ::std::os::raw::c_int) {
        std__Lockit__Lockit_dtor(arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Lockit__Lockit(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Lockit__Lockit1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std__Lockit__Lockit_destructor(self)
    }
}
pub type std_integral_constant_value_type<_Ty> = _Ty;
pub type std_integral_constant_type = u8;
pub type std_bool_constant = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std_enable_if_t = u8;
pub type std_conditional_type<_Ty1> = _Ty1;
pub type std_conditional_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Ty> = _Ty;
pub type std_remove_const_t = std_remove_const;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Ty> = _Ty;
pub type std_remove_volatile_t = std_remove_volatile;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Ty> = _Ty;
pub type std_remove_cv__Apply = u8;
pub type std_remove_cv_t = std_remove_cv;
pub type std__Disjunction_type<_First> = _First;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_disjunction {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Ty> = _Ty;
pub type std_remove_reference__Const_thru_ref_type<_Ty> = _Ty;
pub type std_remove_reference_t = std_remove_reference;
pub type std__Const_thru_ref = std_remove_reference;
pub type std__Remove_cvref_t = std_remove_cv_t;
pub const denorm_indeterminate: std_float_denorm_style = -1;
pub const denorm_absent: std_float_denorm_style = 0;
pub const denorm_present: std_float_denorm_style = 1;
pub type std_float_denorm_style = ::std::os::raw::c_int;
pub const round_indeterminate: std_float_round_style = -1;
pub const round_toward_zero: std_float_round_style = 0;
pub const round_to_nearest: std_float_round_style = 1;
pub const round_toward_infinity: std_float_round_style = 2;
pub const round_toward_neg_infinity: std_float_round_style = 3;
pub type std_float_round_style = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Num_base {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}has_denorm"]
    pub static std__Num_base_has_denorm: std_float_denorm_style;
}
pub const std__Num_base_has_denorm_loss: bool = false;
pub const std__Num_base_has_infinity: bool = false;
pub const std__Num_base_has_quiet_NaN: bool = false;
pub const std__Num_base_has_signaling_NaN: bool = false;
pub const std__Num_base_is_bounded: bool = false;
pub const std__Num_base_is_exact: bool = false;
pub const std__Num_base_is_iec559: bool = false;
pub const std__Num_base_is_integer: bool = false;
pub const std__Num_base_is_modulo: bool = false;
pub const std__Num_base_is_signed: bool = false;
pub const std__Num_base_is_specialized: bool = false;
pub const std__Num_base_tinyness_before: bool = false;
pub const std__Num_base_traps: bool = false;
extern "C" {
    #[link_name = "\u{1}round_style"]
    pub static std__Num_base_round_style: std_float_round_style;
}
pub const std__Num_base_digits: ::std::os::raw::c_int = 0;
pub const std__Num_base_digits10: ::std::os::raw::c_int = 0;
pub const std__Num_base_max_digits10: ::std::os::raw::c_int = 0;
pub const std__Num_base_max_exponent: ::std::os::raw::c_int = 0;
pub const std__Num_base_max_exponent10: ::std::os::raw::c_int = 0;
pub const std__Num_base_min_exponent: ::std::os::raw::c_int = 0;
pub const std__Num_base_min_exponent10: ::std::os::raw::c_int = 0;
pub const std__Num_base_radix: ::std::os::raw::c_int = 0;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_numeric_limits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Num_int_base {
    pub _address: u8,
}
pub const std__Num_int_base_is_bounded: bool = true;
pub const std__Num_int_base_is_exact: bool = true;
pub const std__Num_int_base_is_integer: bool = true;
pub const std__Num_int_base_is_specialized: bool = true;
pub const std__Num_int_base_radix: ::std::os::raw::c_int = 2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Num_float_base {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}has_denorm"]
    pub static std__Num_float_base_has_denorm: std_float_denorm_style;
}
pub const std__Num_float_base_has_infinity: bool = true;
pub const std__Num_float_base_has_quiet_NaN: bool = true;
pub const std__Num_float_base_has_signaling_NaN: bool = true;
pub const std__Num_float_base_is_bounded: bool = true;
pub const std__Num_float_base_is_iec559: bool = true;
pub const std__Num_float_base_is_signed: bool = true;
pub const std__Num_float_base_is_specialized: bool = true;
extern "C" {
    #[link_name = "\u{1}round_style"]
    pub static std__Num_float_base_round_style: std_float_round_style;
}
pub const std__Num_float_base_radix: ::std::os::raw::c_int = 2;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type std_max_align_t = f64;
pub type std__Conjunction_type<_First> = _First;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_conjunction {
    pub _base: std_true_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_negation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
pub type std_void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Identity {
    pub _address: u8,
}
pub type std__Identity_type<_Ty> = _Ty;
pub type std__Identity_t = std__Identity;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Ty> = _Ty;
pub type std_add_const_t = std_add_const;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Ty> = _Ty;
pub type std_add_volatile_t = std_add_volatile;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type<_Ty> = _Ty;
pub type std_add_cv_t = std_add_cv;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Add_reference {
    pub _address: u8,
}
pub type std__Add_reference__Lvalue<_Ty> = _Ty;
pub type std__Add_reference__Rvalue<_Ty> = _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std_add_lvalue_reference_type = std__Add_reference;
pub type std_add_lvalue_reference_t = std__Add_reference;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_add_rvalue_reference_type = std__Add_reference;
pub type std_add_rvalue_reference_t = std__Add_reference;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Ty> = _Ty;
pub type std_remove_extent_t = std_remove_extent;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Ty> = _Ty;
pub type std_remove_all_extents_t = std_remove_all_extents;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_type<_Ty> = _Ty;
pub type std_remove_pointer_t = std_remove_pointer;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Add_pointer {
    pub _address: u8,
}
pub type std__Add_pointer_type<_Ty> = _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_add_pointer_type = std__Add_pointer;
pub type std_add_pointer_t = std__Add_pointer;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_array {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Arg_types {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_memfunptr {
    pub _address: u8,
}
pub type std__Is_memfunptr__Bool_type = std_false_type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_const {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_volatile {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_implicitly_default_constructible {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
pub type std__Is_assignable_no_precondition_check = std_is_assignable;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
pub type std__Is_copy_assignable_no_precondition_check = std_is_copy_assignable;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
pub type std__Is_move_assignable_no_precondition_check = std_is_move_assignable;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
pub type std__Sign_base__Uty = std_remove_cv_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
pub type std__Select__Apply<_Ty1> = _Ty1;
pub type std__Make_signed1 = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = std_remove_cv;
pub type std_make_signed_t = std_make_signed;
pub type std__Make_unsigned1 = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = std_remove_cv;
pub type std_make_unsigned_t = std_make_unsigned;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
pub type std__Aligned_storage__Next = ::std::os::raw::c_char;
extern "C" {
    #[link_name = "\u{1}_Fits"]
    pub static std__Aligned_storage__Fits: bool;
}
pub type std__Aligned_storage_type = u8;
pub type std__Aligned_storage_t = u8;
pub type std_aligned_storage_type = std__Aligned_storage_t;
pub type std_aligned_storage_t = std__Aligned_storage_t;
pub type std_aligned_union_type = std__Aligned_storage_t;
pub type std_aligned_union_t = u8;
pub type std__Underlying_type_type<_Ty> = _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
pub type std_underlying_type_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_rank {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay__Ty1 = std_remove_reference_t;
pub type std_decay__Ty2 = u8;
pub type std_decay_type = u8;
pub type std_decay_t = std_decay;
pub type std__Conditional_type<_Ty1> = _Ty1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Decayed_cond_oper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
pub type std_common_type_t = std_common_type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Common_type2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Common_type3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_specialization {
    pub _address: u8,
}
pub const _Functor: std__Invoker_strategy = 0;
pub const _Pmf_object: std__Invoker_strategy = 1;
pub const _Pmf_refwrap: std__Invoker_strategy = 2;
pub const _Pmf_pointer: std__Invoker_strategy = 3;
pub const _Pmd_object: std__Invoker_strategy = 4;
pub const _Pmd_refwrap: std__Invoker_strategy = 5;
pub const _Pmd_pointer: std__Invoker_strategy = 6;
pub type std__Invoker_strategy = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoker_functor {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Strategy"]
    pub static std__Invoker_functor__Strategy: std__Invoker_strategy;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoker_pmf_object {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Strategy"]
    pub static std__Invoker_pmf_object__Strategy: std__Invoker_strategy;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoker_pmf_refwrap {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Strategy"]
    pub static std__Invoker_pmf_refwrap__Strategy: std__Invoker_strategy;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoker_pmf_pointer {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Strategy"]
    pub static std__Invoker_pmf_pointer__Strategy: std__Invoker_strategy;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoker_pmd_object {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Strategy"]
    pub static std__Invoker_pmd_object__Strategy: std__Invoker_strategy;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoker_pmd_refwrap {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Strategy"]
    pub static std__Invoker_pmd_refwrap__Strategy: std__Invoker_strategy;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoker_pmd_pointer {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Strategy"]
    pub static std__Invoker_pmd_pointer__Strategy: std__Invoker_strategy;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_nothrow_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoke_convertible {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoke_nothrow_convertible {
    pub _address: u8,
}
pub type std__Invoke_traits_common_type<_Result> = _Result;
pub type std__Invoke_traits_common__Is_invocable = std_true_type;
pub type std__Invoke_traits_common__Is_nothrow_invocable = std_bool_constant;
pub type std__Invoke_traits_common__Is_invocable_r = std_bool_constant;
pub type std__Invoke_traits_common__Is_nothrow_invocable_r = std_bool_constant;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoke_traits_zero {
    pub _address: u8,
}
pub type std__Invoke_traits_zero__Is_invocable = std_false_type;
pub type std__Invoke_traits_zero__Is_nothrow_invocable = std_false_type;
pub type std__Invoke_traits_zero__Is_invocable_r = std_false_type;
pub type std__Invoke_traits_zero__Is_nothrow_invocable_r = std_false_type;
pub type std__Decltype_invoke_zero<_Callable> = _Callable;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Invoke_traits_nonzero {
    pub _address: u8,
}
pub type std__Invoke_traits_nonzero__Is_invocable = std_false_type;
pub type std__Invoke_traits_nonzero__Is_nothrow_invocable = std_false_type;
pub type std__Invoke_traits_nonzero__Is_invocable_r = std_false_type;
pub type std__Invoke_traits_nonzero__Is_nothrow_invocable_r = std_false_type;
pub type std__Decltype_invoke_nonzero = u8;
pub type std__Select_invoke_traits = std_conditional_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
pub type std_result_of_t = std_result_of;
pub type std__Invoke_result_t = std__Select_invoke_traits;
pub type std__Is_invocable_r_ = std__Select_invoke_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Is_invocable_r {
    pub _address: u8,
}
impl Default for std__Is_invocable_r {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Function_args {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Weak_result_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Weak_argument_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Weak_binary_args {
    pub _address: u8,
}
pub type std__Weak_types = std_conditional_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Refwrap_has_ctor_from {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper<_Ty> {
    pub _Ptr: *mut _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
pub type std_reference_wrapper_type<_Ty> = _Ty;
impl<_Ty> Default for std_reference_wrapper<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Swappable_with_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Swap_cannot_throw {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_nothrow_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Has_ADL_swap_detail__Has_ADL_swap {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_trivially_swappable {
    pub _address: u8,
}
pub const std__FNV_offset_basis: ::std::os::raw::c_ulonglong = 14695981039346656037;
pub const std__FNV_prime: ::std::os::raw::c_ulonglong = 1099511628211;
pub type std__Conditionally_enabled_hash_argument_type<_Kty> = _Kty;
pub type std__Conditionally_enabled_hash_result_type = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_nothrow_hashable {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
pub type std_less_first_argument_type<_Ty> = _Ty;
pub type std_less_second_argument_type<_Ty> = _Ty;
pub type std_less_result_type = bool;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Floating_type_traits {
    pub _address: u8,
}
pub type std__Maybe_const = std_conditional_t;
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Ratio_add {
    pub _address: u8,
}
pub type std__Ratio_add_type = u8;
pub type std_ratio_add = std__Ratio_add;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Ratio_subtract {
    pub _address: u8,
}
pub type std__Ratio_subtract_type = std_ratio_add;
pub type std_ratio_subtract = std__Ratio_subtract;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Ratio_multiply {
    pub _address: u8,
}
pub type std__Ratio_multiply__Num = u8;
pub type std__Ratio_multiply__Den = u8;
pub type std_ratio_multiply = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Ratio_divide {
    pub _address: u8,
}
pub type std__Ratio_divide__Rx2_inverse = u8;
pub type std__Ratio_divide_sfinae = u8;
pub type std_ratio_divide = std__Ratio_divide_sfinae;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_ratio_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_ratio_not_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Big_uint128 {
    pub _Upper: ::std::os::raw::c_ulonglong,
    pub _Lower: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_ratio_less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_ratio_less_equal {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_ratio_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_ratio_greater_equal {
    pub _address: u8,
}
pub type std_atto = u8;
pub type std_femto = u8;
pub type std_pico = u8;
pub type std_nano = u8;
pub type std_micro = u8;
pub type std_milli = u8;
pub type std_centi = u8;
pub type std_deci = u8;
pub type std_deca = u8;
pub type std_hecto = u8;
pub type std_kilo = u8;
pub type std_mega = u8;
pub type std_giga = u8;
pub type std_tera = u8;
pub type std_peta = u8;
pub type std_exa = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_Elem> {
    pub _First: *const _Elem,
    pub _Last: *const _Elem,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Elem>>,
}
pub type std_initializer_list_value_type<_Elem> = _Elem;
pub type std_initializer_list_reference<_Elem> = *const _Elem;
pub type std_initializer_list_const_reference<_Elem> = *const _Elem;
pub type std_initializer_list_size_type = ::std::os::raw::c_ulonglong;
pub type std_initializer_list_iterator<_Elem> = *const _Elem;
pub type std_initializer_list_const_iterator<_Elem> = *const _Elem;
impl<_Elem> Default for std_initializer_list<_Elem> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_integer_sequence_value_type<_Ty> = _Ty;
pub type std_make_integer_sequence = u8;
pub type std_index_sequence = u8;
pub type std_make_index_sequence = std_make_integer_sequence;
pub type std_index_sequence_for = std_make_index_sequence;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}piecewise_construct"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Ignore {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}ignore"]
    pub static std_ignore: std__Ignore;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
pub type std_tuple_element_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair<_Ty1, _Ty2> {
    pub first: _Ty1,
    pub second: _Ty2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty2>>,
}
pub type std_pair_first_type<_Ty1> = _Ty1;
pub type std_pair_second_type<_Ty2> = _Ty2;
impl<_Ty1, _Ty2> Default for std_pair<_Ty1, _Ty2> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Unrefwrap_helper {
    pub _address: u8,
}
pub type std__Unrefwrap_helper_type<_Ty> = _Ty;
pub type std__Unrefwrap_t = std__Unrefwrap_helper;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Tuple_size_sfinae {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_treat_as_floating_point {
    pub _address: u8,
}
impl Default for std_chrono_treat_as_floating_point {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_chrono_duration_values {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration<_Rep> {
    pub _MyRep: _Rep,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Rep>>,
}
pub type std_chrono_duration_rep<_Rep> = _Rep;
pub type std_chrono_duration_period = [u8; 0usize];
impl<_Rep> Default for std_chrono_duration<_Rep> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_time_point<_Duration> {
    pub _MyDur: _Duration,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Duration>>,
}
pub type std_chrono_time_point_clock<_Clock> = _Clock;
pub type std_chrono_time_point_duration<_Duration> = _Duration;
pub type std_chrono_time_point_rep = [u8; 0usize];
pub type std_chrono_time_point_period = [u8; 0usize];
impl<_Duration> Default for std_chrono_time_point<_Duration> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_chrono__Duration_div_mod1_type<_CR> = std_chrono_duration<_CR>;
pub type std_chrono_nanoseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_microseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_milliseconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_seconds = std_chrono_duration<::std::os::raw::c_longlong>;
pub type std_chrono_minutes = std_chrono_duration<::std::os::raw::c_int>;
pub type std_chrono_hours = std_chrono_duration<::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_chrono_system_clock {
    pub _address: u8,
}
pub type std_chrono_system_clock_rep = ::std::os::raw::c_longlong;
pub type std_chrono_system_clock_period = u8;
pub type std_chrono_system_clock_duration = std_chrono_duration<std_chrono_system_clock_rep>;
pub type std_chrono_system_clock_time_point =
    std_chrono_time_point<std_chrono_duration<::std::os::raw::c_longlong>>;
pub const std_chrono_system_clock_is_steady: bool = false;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_chrono_steady_clock {
    pub _address: u8,
}
pub type std_chrono_steady_clock_rep = ::std::os::raw::c_longlong;
pub type std_chrono_steady_clock_period = std_nano;
pub type std_chrono_steady_clock_duration = std_chrono_nanoseconds;
pub type std_chrono_steady_clock_time_point =
    std_chrono_time_point<std_chrono_duration<::std::os::raw::c_longlong>>;
pub const std_chrono_steady_clock_is_steady: bool = true;
pub type std_chrono_high_resolution_clock = std_chrono_steady_clock;
extern "C" {
    #[link_name = "\u{1}uncaught_exception"]
    pub fn std_uncaught_exception() -> bool;
}
extern "C" {
    #[link_name = "\u{1}uncaught_exceptions"]
    pub fn std_uncaught_exceptions() -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
    pub _Data: __std_exception_data,
}
impl Default for std_exception {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_exception {
    pub _base: std_exception,
}
impl Default for std_bad_exception {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_alloc {
    pub _base: std_exception,
}
impl Default for std_bad_alloc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_array_new_length {
    pub _base: std_bad_alloc,
}
impl Default for std_bad_array_new_length {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_exception_ptr {
    pub _Data1: *mut ::std::os::raw::c_void,
    pub _Data2: *mut ::std::os::raw::c_void,
}
impl Default for std_exception_ptr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std_nested_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_nested_exception {
    pub vtable_: *const std_nested_exception__bindgen_vtable,
    pub _Exc: std_exception_ptr,
}
impl Default for std_nested_exception {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__With_nested_v2<_Uty> {
    pub _base: _Uty,
    pub _base_1: std_nested_exception,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Uty>>,
}
impl<_Uty> Default for std__With_nested_v2<_Uty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_variant_access {
    pub _base: std_exception,
}
impl Default for std_bad_variant_access {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_streamoff = ::std::os::raw::c_longlong;
pub type std_streamsize = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_fpos<_Statetype> {
    pub _Myoff: std_streamoff,
    pub _Fpos: ::std::os::raw::c_longlong,
    pub _Mystate: _Statetype,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Statetype>>,
}
impl<_Statetype> Default for std_fpos<_Statetype> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_streampos = std_fpos<_Mbstatet>;
pub type std_wstreampos = std_streampos;
pub type std_u16streampos = std_streampos;
pub type std_u32streampos = std_streampos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_ios {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_istreambuf_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_ostreambuf_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_streambuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_istream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_ostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_iostream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_stringbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_istringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_ostringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_stringstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_filebuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_ifstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_ofstream {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_basic_fstream {
    pub _address: u8,
}
pub type std_ios = std_basic_ios;
pub type std_streambuf = std_basic_streambuf;
pub type std_istream = std_basic_istream;
pub type std_ostream = std_basic_ostream;
pub type std_iostream = std_basic_iostream;
pub type std_stringbuf = std_basic_stringbuf;
pub type std_istringstream = std_basic_istringstream;
pub type std_ostringstream = std_basic_ostringstream;
pub type std_stringstream = std_basic_stringstream;
pub type std_filebuf = std_basic_filebuf;
pub type std_ifstream = std_basic_ifstream;
pub type std_ofstream = std_basic_ofstream;
pub type std_fstream = std_basic_fstream;
pub type std_wios = std_basic_ios;
pub type std_wstreambuf = std_basic_streambuf;
pub type std_wistream = std_basic_istream;
pub type std_wostream = std_basic_ostream;
pub type std_wiostream = std_basic_iostream;
pub type std_wstringbuf = std_basic_stringbuf;
pub type std_wistringstream = std_basic_istringstream;
pub type std_wostringstream = std_basic_ostringstream;
pub type std_wstringstream = std_basic_stringstream;
pub type std_wfilebuf = std_basic_filebuf;
pub type std_wifstream = std_basic_ifstream;
pub type std_wofstream = std_basic_ofstream;
pub type std_wfstream = std_basic_fstream;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Has_allocator_type {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_arg_t {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}allocator_arg"]
    pub static std_allocator_arg: std_allocator_arg_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_uses_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_output_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_random_access_iterator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Iterator_traits_base {
    pub _address: u8,
}
pub type std__Iterator_traits_pointer_base_iterator_category = std_random_access_iterator_tag;
pub type std__Iterator_traits_pointer_base_value_type = std_remove_cv_t;
pub type std__Iterator_traits_pointer_base_difference_type = ::std::os::raw::c_longlong;
pub type std__Iterator_traits_pointer_base_pointer<_Ty> = *mut _Ty;
pub type std__Iterator_traits_pointer_base_reference<_Ty> = *mut _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Meta_npos"]
    pub static std__Meta_npos: ::std::os::raw::c_ulonglong;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Meta_find_unique_index_ {
    pub _address: u8,
}
pub type std__Meta_find_unique_index__type = u8;
pub type std__Meta_find_unique_index = std__Meta_find_unique_index_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_first_parameter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Replace_first_parameter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_ptr_difference_type {
    pub _address: u8,
}
pub type std__Get_ptr_difference_type_type = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_rebind_alias {
    pub _address: u8,
}
pub type std__Get_rebind_alias_type = std__Replace_first_parameter;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Ptr_traits_base {
    pub _address: u8,
}
pub type std__Ptr_traits_base_pointer<_Ty> = _Ty;
pub type std__Ptr_traits_base_element_type<_Elem> = _Elem;
pub type std__Ptr_traits_base_difference_type = std__Get_ptr_difference_type;
pub type std__Ptr_traits_base_rebind = std__Get_rebind_alias;
pub type std__Ptr_traits_base__Reftype = *mut std_conditional_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Ptr_traits_sfinae_layer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_plus {
    pub _address: u8,
}
pub type std_plus_first_argument_type<_Ty> = _Ty;
pub type std_plus_second_argument_type<_Ty> = _Ty;
pub type std_plus_result_type<_Ty> = _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_minus {
    pub _address: u8,
}
pub type std_minus_first_argument_type<_Ty> = _Ty;
pub type std_minus_second_argument_type<_Ty> = _Ty;
pub type std_minus_result_type<_Ty> = _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_multiplies {
    pub _address: u8,
}
pub type std_multiplies_first_argument_type<_Ty> = _Ty;
pub type std_multiplies_second_argument_type<_Ty> = _Ty;
pub type std_multiplies_result_type<_Ty> = _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
pub type std_equal_to_first_argument_type<_Ty> = _Ty;
pub type std_equal_to_second_argument_type<_Ty> = _Ty;
pub type std_equal_to_result_type = bool;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_not_equal_to {
    pub _address: u8,
}
pub type std_not_equal_to_first_argument_type<_Ty> = _Ty;
pub type std_not_equal_to_second_argument_type<_Ty> = _Ty;
pub type std_not_equal_to_result_type = bool;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
pub type std_greater_first_argument_type<_Ty> = _Ty;
pub type std_greater_second_argument_type<_Ty> = _Ty;
pub type std_greater_result_type = bool;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_greater_equal {
    pub _address: u8,
}
pub type std_greater_equal_first_argument_type<_Ty> = _Ty;
pub type std_greater_equal_second_argument_type<_Ty> = _Ty;
pub type std_greater_equal_result_type = bool;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_less_equal {
    pub _address: u8,
}
pub type std_less_equal_first_argument_type<_Ty> = _Ty;
pub type std_less_equal_second_argument_type<_Ty> = _Ty;
pub type std_less_equal_result_type = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Ref_fn<_Fx> {
    pub _Fn: *mut _Fx,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Fx>>,
}
impl<_Fx> Default for std__Ref_fn<_Fx> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Unused_parameter {
    pub _address: u8,
}
pub type std__Algorithm_int_t = std_conditional_t;
pub type std__Iter_ref_t = std_iterator_traits;
pub type std__Iter_value_t = std_iterator_traits;
pub type std__Iter_diff_t = std_iterator_traits;
pub type std__Make_unsigned_like_t = std_make_unsigned_t;
pub type std__Common_diff_t = std_common_type_t;
pub type std__Iter_cat_t = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_iterator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_checked_helper {
    pub _address: u8,
}
pub type std__Unwrapped_t = std__Remove_cvref_t;
pub type std__Unwrapped_unverified_t = std__Remove_cvref_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Distance_unknown {
    pub _address: u8,
}
pub type std__Unwrap_enum_type = std_underlying_type_t;
pub type std__Unwrap_enum_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_BidIt> {
    pub current: _BidIt,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_BidIt>>,
}
pub type std_reverse_iterator_iterator_type<_BidIt> = _BidIt;
pub type std_reverse_iterator_iterator_category = std__Iter_cat_t;
pub type std_reverse_iterator_value_type = std__Iter_value_t;
pub type std_reverse_iterator_difference_type = std__Iter_diff_t;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_reference = std__Iter_ref_t;
pub type std_reverse_iterator__Prevent_inheriting_unwrap<_BidIt> = std_reverse_iterator<_BidIt>;
impl<_BidIt> Default for std_reverse_iterator<_BidIt> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Default_sentinel {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Move_iterator_category {
    pub _address: u8,
}
pub type std__Move_iterator_category_iterator_category = std__Iter_cat_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_move_iterator<_Iter> {
    pub _Current: _Iter,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
}
pub type std_move_iterator_iterator_type<_Iter> = _Iter;
pub type std_move_iterator_value_type = std__Iter_value_t;
pub type std_move_iterator_difference_type = std__Iter_diff_t;
pub type std_move_iterator_pointer<_Iter> = _Iter;
pub type std_move_iterator_reference = std_conditional_t;
pub type std_move_iterator__Prevent_inheriting_unwrap<_Iter> = std_move_iterator<_Iter>;
impl<_Iter> Default for std_move_iterator<_Iter> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Trivial_cat {
    pub _address: u8,
}
pub type std__Trivial_cat__USource = std__Unwrap_enum_t;
pub type std__Trivial_cat__UDest = std__Unwrap_enum_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__False_trivial_cat {
    pub _address: u8,
}
pub const std__False_trivial_cat__Bitcopy_constructible: bool = false;
pub const std__False_trivial_cat__Bitcopy_assignable: bool = false;
pub type std__Sent_copy_cat = std_conditional_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_character {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_character_or_bool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_character_or_byte_or_bool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Lex_compare_memcmp_classify_pred {
    pub _address: u8,
}
pub type std__Lex_compare_memcmp_classify_pred__Pred = ::std::os::raw::c_void;
pub type std__Lex_compare_memcmp_classify = std_conditional_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Vector_alg_in_find_is_safe_object_pointers {
    pub _base: std_false_type,
}
pub const _KeepTrimming: std__TrimResult = 0;
pub const _HaveWorkAfterTrimming: std__TrimResult = 1;
pub const _ReturnFalse: std__TrimResult = 2;
pub const _ReturnTrue: std__TrimResult = 3;
pub type std__TrimResult = ::std::os::raw::c_uchar;
extern "C" {
    #[link_name = "\u{1}_Xbad_alloc"]
    pub fn std__Xbad_alloc();
}
extern "C" {
    #[link_name = "\u{1}_Xinvalid_argument"]
    pub fn std__Xinvalid_argument(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_Xlength_error"]
    pub fn std__Xlength_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_Xout_of_range"]
    pub fn std__Xout_of_range(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_Xoverflow_error"]
    pub fn std__Xoverflow_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_Xruntime_error"]
    pub fn std__Xruntime_error(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_XGetLastError"]
    pub fn std__XGetLastError();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Ty> = _Ty;
pub type std_iterator_difference_type<_Diff> = _Diff;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Char_traits {
    pub _address: u8,
}
pub type std__Char_traits_char_type<_Elem> = _Elem;
pub type std__Char_traits_int_type<_Int_type> = _Int_type;
pub type std__Char_traits_pos_type = std_streampos;
pub type std__Char_traits_off_type = std_streamoff;
pub type std__Char_traits_state_type = _Mbstatet;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__WChar_traits {
    pub _address: u8,
}
pub type std__WChar_traits__Primary_char_traits = std__Char_traits;
pub type std__WChar_traits_char_type<_Elem> = _Elem;
pub type std__WChar_traits_int_type = ::std::os::raw::c_ushort;
pub type std__WChar_traits_pos_type = std_streampos;
pub type std__WChar_traits_off_type = std_streamoff;
pub type std__WChar_traits_state_type = _Mbstatet;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Narrow_char_traits {
    pub _address: u8,
}
pub type std__Narrow_char_traits__Primary_char_traits = std__Char_traits;
pub type std__Narrow_char_traits_char_type<_Elem> = _Elem;
pub type std__Narrow_char_traits_int_type<_Int_type> = _Int_type;
pub type std__Narrow_char_traits_pos_type = std_streampos;
pub type std__Narrow_char_traits_off_type = std_streamoff;
pub type std__Narrow_char_traits_state_type = _Mbstatet;
impl Default for std__Narrow_char_traits {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std__Traits_ch_t = [u8; 0usize];
pub type std__Traits_ptr_t = *const [u8; 0usize];
pub type std_new_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}set_new_handler"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
extern "C" {
    #[link_name = "\u{1}get_new_handler"]
    pub fn std_get_new_handler() -> std_new_handler;
}
pub const memory_order_relaxed: std_memory_order = 0;
pub const memory_order_consume: std_memory_order = 1;
pub const memory_order_acquire: std_memory_order = 2;
pub const memory_order_release: std_memory_order = 3;
pub const memory_order_acq_rel: std_memory_order = 4;
pub const memory_order_seq_cst: std_memory_order = 5;
pub type std_memory_order = ::std::os::raw::c_int;
pub type std__Atomic_counter_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug)]
pub struct std__Tidy_guard<_Ty> {
    pub _Target: *mut _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std__Tidy_guard<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Tidy_deallocate_guard<_Ty> {
    pub _Target: *mut _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std__Tidy_deallocate_guard<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Default_allocate_traits {
    pub _address: u8,
}
pub const std__Big_allocation_threshold: ::std::os::raw::c_ulonglong = 4096;
pub const std__Big_allocation_alignment: ::std::os::raw::c_ulonglong = 32;
pub const std__Non_user_size: ::std::os::raw::c_ulonglong = 39;
pub const std__Big_allocation_sentinel: ::std::os::raw::c_ulonglong = 18085043209519168250;
pub type std__Rebind_pointer_t = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_pointer_type {
    pub _address: u8,
}
pub type std__Get_pointer_type_type = *mut [u8; 0usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_const_pointer_type {
    pub _address: u8,
}
pub type std__Get_const_pointer_type__Ptrty = std__Get_pointer_type;
pub type std__Get_const_pointer_type__Valty = [u8; 0usize];
pub type std__Get_const_pointer_type_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_void_pointer_type {
    pub _address: u8,
}
pub type std__Get_void_pointer_type__Ptrty = std__Get_pointer_type;
pub type std__Get_void_pointer_type_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_const_void_pointer_type {
    pub _address: u8,
}
pub type std__Get_const_void_pointer_type__Ptrty = std__Get_pointer_type;
pub type std__Get_const_void_pointer_type_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_difference_type {
    pub _address: u8,
}
pub type std__Get_difference_type__Ptrty = std__Get_pointer_type;
pub type std__Get_difference_type_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_size_type {
    pub _address: u8,
}
pub type std__Get_size_type_type = std_make_unsigned_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_propagate_on_container_copy {
    pub _address: u8,
}
pub type std__Get_propagate_on_container_copy_type = std_false_type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_propagate_on_container_move {
    pub _address: u8,
}
pub type std__Get_propagate_on_container_move_type = std_false_type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_propagate_on_container_swap {
    pub _address: u8,
}
pub type std__Get_propagate_on_container_swap_type = std_false_type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_is_always_equal {
    pub _address: u8,
}
pub type std__Get_is_always_equal_type = std_bool_constant;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_rebind_type {
    pub _address: u8,
}
pub type std__Get_rebind_type_type = std__Replace_first_parameter;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_default_allocator {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Has_no_allocator_construct {
    pub _base: std_true_type,
}
pub type std__Uses_default_construct = std_disjunction;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Has_no_alloc_destroy {
    pub _base: std_true_type,
}
pub type std__Uses_default_destroy = std_disjunction;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Has_allocate_hint {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Has_max_size {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Has_select_on_container_copy_construction {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Normal_allocator_traits {
    pub _address: u8,
}
pub type std__Normal_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std__Normal_allocator_traits_value_type = [u8; 0usize];
pub type std__Normal_allocator_traits_pointer = std__Get_pointer_type;
pub type std__Normal_allocator_traits_const_pointer = std__Get_const_pointer_type;
pub type std__Normal_allocator_traits_void_pointer = std__Get_void_pointer_type;
pub type std__Normal_allocator_traits_const_void_pointer = std__Get_const_void_pointer_type;
pub type std__Normal_allocator_traits_size_type = std__Get_size_type;
pub type std__Normal_allocator_traits_difference_type = std__Get_difference_type;
pub type std__Normal_allocator_traits_propagate_on_container_copy_assignment =
    std__Get_propagate_on_container_copy;
pub type std__Normal_allocator_traits_propagate_on_container_move_assignment =
    std__Get_propagate_on_container_move;
pub type std__Normal_allocator_traits_propagate_on_container_swap =
    std__Get_propagate_on_container_swap;
pub type std__Normal_allocator_traits_is_always_equal = std__Get_is_always_equal;
pub type std__Normal_allocator_traits_rebind_alloc = std__Get_rebind_type;
pub type std__Normal_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Default_allocator_traits {
    pub _address: u8,
}
pub type std__Default_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std__Default_allocator_traits_value_type = [u8; 0usize];
pub type std__Default_allocator_traits_pointer = *mut std__Default_allocator_traits_value_type;
pub type std__Default_allocator_traits_const_pointer =
    *const std__Default_allocator_traits_value_type;
pub type std__Default_allocator_traits_void_pointer = *mut ::std::os::raw::c_void;
pub type std__Default_allocator_traits_const_void_pointer = *const ::std::os::raw::c_void;
pub type std__Default_allocator_traits_size_type = ::std::os::raw::c_ulonglong;
pub type std__Default_allocator_traits_difference_type = ::std::os::raw::c_longlong;
pub type std__Default_allocator_traits_propagate_on_container_copy_assignment = std_false_type;
pub type std__Default_allocator_traits_propagate_on_container_move_assignment = std_true_type;
pub type std__Default_allocator_traits_propagate_on_container_swap = std_false_type;
pub type std__Default_allocator_traits_is_always_equal = std_true_type;
pub type std__Default_allocator_traits_rebind_alloc = std_allocator;
pub type std__Default_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub const _Equal_allocators: std__Pocma_values = 0;
pub const _Propagate_allocators: std__Pocma_values = 1;
pub const _No_propagate_allocators: std__Pocma_values = 2;
pub type std__Pocma_values = ::std::os::raw::c_int;
pub type std__Rebind_alloc_t = std_allocator_traits;
pub type std__Maybe_rebind_alloc_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Simple_types {
    pub _address: u8,
}
pub type std__Simple_types_value_type<_Value_type> = _Value_type;
pub type std__Simple_types_size_type = ::std::os::raw::c_ulonglong;
pub type std__Simple_types_difference_type = ::std::os::raw::c_longlong;
pub type std__Simple_types_pointer<_Value_type> = *mut std__Simple_types_value_type<_Value_type>;
pub type std__Simple_types_const_pointer<_Value_type> =
    *const std__Simple_types_value_type<_Value_type>;
pub const std__Asan_granularity: ::std::os::raw::c_ulonglong = 8;
pub const std__Asan_granularity_mask: ::std::os::raw::c_ulonglong = 7;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Asan_aligned_pointers {
    pub _First: *const ::std::os::raw::c_void,
    pub _End: *const ::std::os::raw::c_void,
}
impl Default for std__Asan_aligned_pointers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator__From_primary = std_allocator;
pub type std_allocator_value_type<_Ty> = _Ty;
pub type std_allocator_pointer<_Ty> = *mut _Ty;
pub type std_allocator_const_pointer<_Ty> = *const _Ty;
pub type std_allocator_reference<_Ty> = *mut _Ty;
pub type std_allocator_const_reference<_Ty> = *const _Ty;
pub type std_allocator_size_type = ::std::os::raw::c_ulonglong;
pub type std_allocator_difference_type = ::std::os::raw::c_longlong;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std__Alloc_ptr_t = std_allocator_traits;
pub type std__Alloc_size_t = std_allocator_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std__Alloc_construct_ptr<_Alloc> {
    pub _Al: *mut _Alloc,
    pub _Ptr: std__Alloc_construct_ptr_pointer,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std__Alloc_construct_ptr_pointer = std__Alloc_ptr_t;
impl<_Alloc> Default for std__Alloc_construct_ptr<_Alloc> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Fake_allocator {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Container_base0 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Iterator_base0 {
    pub _address: u8,
}
pub const std__Iterator_base0__Unwrap_when_unverified: bool = true;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Container_proxy {
    pub _Mycont: *const std__Container_base12,
    pub _Myfirstiter: *mut std__Iterator_base12,
}
impl Default for std__Container_proxy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Container_base12 {
    pub _Myproxy: *mut std__Container_proxy,
}
impl Default for std__Container_base12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Iterator_base12 {
    pub _Myproxy: *mut std__Container_proxy,
    pub _Mynextiter: *mut std__Iterator_base12,
}
pub const std__Iterator_base12__Unwrap_when_unverified: bool = true;
impl Default for std__Iterator_base12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std__Container_base = std__Container_base0;
pub type std__Iterator_base = std__Iterator_base0;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Leave_proxy_unbound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Fake_proxy_ptr_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Basic_container_proxy_ptr12 {
    pub _Ptr: *mut std__Container_proxy,
}
impl Default for std__Basic_container_proxy_ptr12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Container_proxy_ptr12<_Alloc> {
    pub _base: std__Basic_container_proxy_ptr12,
    pub _Al: *mut _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
impl<_Alloc> Default for std__Container_proxy_ptr12<_Alloc> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}_Fake_alloc"]
    pub static std__Fake_alloc: std__Fake_allocator;
}
pub type std__Container_proxy_ptr = std__Fake_proxy_ptr_impl;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Zero_then_variadic_args_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__One_then_variadic_args_t {
    pub _address: u8,
}
pub type std__Compressed_pair__Mybase<_Ty1> = _Ty1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Move_allocator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Uninitialized_backout<_NoThrowFwdIt> {
    pub _First: _NoThrowFwdIt,
    pub _Last: _NoThrowFwdIt,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_NoThrowFwdIt>>,
}
impl<_NoThrowFwdIt> Default for std__Uninitialized_backout<_NoThrowFwdIt> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Uninitialized_backout_al<_Alloc> {
    pub _First: std__Uninitialized_backout_al_pointer,
    pub _Last: std__Uninitialized_backout_al_pointer,
    pub _Al: *mut _Alloc,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std__Uninitialized_backout_al_pointer = std__Alloc_ptr_t;
impl<_Alloc> Default for std__Uninitialized_backout_al<_Alloc> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__In_place_key_extract_set {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__In_place_key_extract_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Wrap<_Ty> {
    pub _Value: _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std__Wrap<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__Alloc_temporary2<_Alloc> {
    pub _Al: *mut _Alloc,
    pub __bindgen_anon_1: std__Alloc_temporary2__bindgen_ty_1,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Alloc>>,
}
pub type std__Alloc_temporary2_value_type = [u8; 0usize];
pub type std__Alloc_temporary2__Traits = std_allocator_traits;
#[repr(C)]
#[repr(align(1))]
pub struct std__Alloc_temporary2__bindgen_ty_1 {
    pub _Value: __BindgenUnionField<std__Alloc_temporary2_value_type>,
    pub bindgen_union_field: [u8; 0usize],
}
impl Default for std__Alloc_temporary2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl<_Alloc> Default for std__Alloc_temporary2<_Alloc> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std__Normally_bound_ref<_Ty> = _Ty;
pub type std__Ebco_base__Mybase<_Ty> = _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Is_transparent {
    pub _address: u8,
}
#[repr(C)]
pub struct std__String_const_iterator {
    pub _Ptr: std__String_const_iterator_pointer,
}
pub type std__String_const_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__String_const_iterator_value_type = [u8; 0usize];
pub type std__String_const_iterator_difference_type = [u8; 0usize];
pub type std__String_const_iterator_pointer = [u8; 0usize];
pub type std__String_const_iterator_reference = *const std__String_const_iterator_value_type;
pub type std__String_const_iterator__Prevent_inheriting_unwrap = std__String_const_iterator;
impl Default for std__String_const_iterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__String_iterator {
    pub _base: std__String_const_iterator,
}
pub type std__String_iterator__Mybase = std__String_const_iterator;
pub type std__String_iterator_iterator_category = std_random_access_iterator_tag;
pub type std__String_iterator_value_type = [u8; 0usize];
pub type std__String_iterator_difference_type = [u8; 0usize];
pub type std__String_iterator_pointer = [u8; 0usize];
pub type std__String_iterator_reference = *mut std__String_iterator_value_type;
pub type std__String_iterator__Prevent_inheriting_unwrap = std__String_iterator;
impl Default for std__String_iterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__String_iter_types {
    pub _address: u8,
}
pub type std__String_iter_types_value_type<_Value_type> = _Value_type;
pub type std__String_iter_types_size_type<_Size_type> = _Size_type;
pub type std__String_iter_types_difference_type<_Difference_type> = _Difference_type;
pub type std__String_iter_types_pointer<_Pointer> = _Pointer;
pub type std__String_iter_types_const_pointer<_Const_pointer> = _Const_pointer;
#[repr(C)]
pub struct std__String_val {
    pub _Bx: std__String_val__Bxty,
    pub _Mysize: std__String_val_size_type,
    pub _Myres: std__String_val_size_type,
}
pub type std__String_val_value_type = [u8; 0usize];
pub type std__String_val_size_type = [u8; 0usize];
pub type std__String_val_difference_type = [u8; 0usize];
pub type std__String_val_pointer = [u8; 0usize];
pub type std__String_val_const_pointer = [u8; 0usize];
pub type std__String_val_reference = *mut std__String_val_value_type;
pub type std__String_val_const_reference = *const std__String_val_value_type;
#[repr(C)]
pub union std__String_val__Bxty {
    pub _Buf: ::std::mem::ManuallyDrop<*mut std__String_val_value_type>,
    pub _Ptr: ::std::mem::ManuallyDrop<std__String_val_pointer>,
    pub _Alias: ::std::mem::ManuallyDrop<*mut ::std::os::raw::c_char>,
}
impl Default for std__String_val__Bxty {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for std__String_val {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__String_constructor_concat_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__String_constructor_rvalue_allocator_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct std_basic_string {
    pub _Mypair: u8,
}
pub type std_basic_string__Alty = std__Rebind_alloc_t;
pub type std_basic_string__Alty_traits = std_allocator_traits;
pub type std_basic_string__Scary_val = std__String_val;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_allocator_type<_Alloc> = _Alloc;
pub type std_basic_string_value_type<_Elem> = _Elem;
pub type std_basic_string_size_type = std_basic_string__Alty_traits;
pub type std_basic_string_difference_type = std_basic_string__Alty_traits;
pub type std_basic_string_pointer = std_basic_string__Alty_traits;
pub type std_basic_string_const_pointer = std_basic_string__Alty_traits;
pub type std_basic_string_reference<_Elem> = *mut std_basic_string_value_type<_Elem>;
pub type std_basic_string_const_reference<_Elem> = *const std_basic_string_value_type<_Elem>;
pub type std_basic_string_iterator = std__String_iterator;
pub type std_basic_string_const_iterator = std__String_const_iterator;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string__Is_elem_cptr = std_bool_constant;
pub const _At_least: std_basic_string__Allocation_policy = 0;
pub const _Exactly: std_basic_string__Allocation_policy = 0;
pub type std_basic_string__Allocation_policy = ::std::os::raw::c_int;
pub const _From_char: std_basic_string__Construct_strategy = 0;
pub const _From_ptr: std_basic_string__Construct_strategy = 0;
pub const _From_string: std_basic_string__Construct_strategy = 0;
pub type std_basic_string__Construct_strategy = ::std::os::raw::c_uchar;
pub type std_string = std_basic_string;
pub type std_wstring = std_basic_string;
pub type std_u16string = std_basic_string;
pub type std_u32string = std_basic_string;
#[repr(C)]
#[derive(Debug)]
pub struct std_logic_error {
    pub _base: std_exception,
}
pub type std_logic_error__Mybase = std_exception;
impl Default for std_logic_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_domain_error {
    pub _base: std_logic_error,
}
pub type std_domain_error__Mybase = std_logic_error;
impl Default for std_domain_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_invalid_argument {
    pub _base: std_logic_error,
}
pub type std_invalid_argument__Mybase = std_logic_error;
impl Default for std_invalid_argument {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_length_error {
    pub _base: std_logic_error,
}
pub type std_length_error__Mybase = std_logic_error;
impl Default for std_length_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_out_of_range {
    pub _base: std_logic_error,
}
pub type std_out_of_range__Mybase = std_logic_error;
impl Default for std_out_of_range {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_runtime_error {
    pub _base: std_exception,
}
pub type std_runtime_error__Mybase = std_exception;
impl Default for std_runtime_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_overflow_error {
    pub _base: std_runtime_error,
}
pub type std_overflow_error__Mybase = std_runtime_error;
impl Default for std_overflow_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_underflow_error {
    pub _base: std_runtime_error,
}
pub type std_underflow_error__Mybase = std_runtime_error;
impl Default for std_underflow_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_range_error {
    pub _base: std_runtime_error,
}
pub type std_range_error__Mybase = std_runtime_error;
impl Default for std_range_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_once_flag {
    pub _Opaque: *mut ::std::os::raw::c_void,
}
impl Default for std_once_flag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct std__Immortalizer_impl<_Ty> {
    pub _Storage: __BindgenUnionField<_Ty>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std__Immortalizer_impl<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}__std_init_once_begin_initialize_clr"]
    pub fn std___std_init_once_begin_initialize_clr(
        _LpInitOnce: *mut *mut ::std::os::raw::c_void,
        _DwFlags: ::std::os::raw::c_ulong,
        _FPending: *mut ::std::os::raw::c_int,
        _LpContext: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__std_init_once_complete_clr"]
    pub fn std___std_init_once_complete_clr(
        _LpInitOnce: *mut *mut ::std::os::raw::c_void,
        _DwFlags: ::std::os::raw::c_ulong,
        _LpContext: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__std_init_once_link_alternate_names_and_abort"]
    pub fn std___std_init_once_link_alternate_names_and_abort();
}
pub const std__Init_once_init_failed: ::std::os::raw::c_ulong = 4;
#[repr(C)]
#[derive(Debug)]
pub struct std__Init_once_completer {
    pub _Once: *mut std_once_flag,
    pub _DwFlags: ::std::os::raw::c_ulong,
}
impl Default for std__Init_once_completer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const address_family_not_supported: std_errc = 102;
pub const address_in_use: std_errc = 100;
pub const address_not_available: std_errc = 101;
pub const already_connected: std_errc = 113;
pub const argument_list_too_long: std_errc = 7;
pub const argument_out_of_domain: std_errc = 33;
pub const bad_address: std_errc = 14;
pub const bad_file_descriptor: std_errc = 9;
pub const bad_message: std_errc = 104;
pub const broken_pipe: std_errc = 32;
pub const connection_aborted: std_errc = 106;
pub const connection_already_in_progress: std_errc = 103;
pub const connection_refused: std_errc = 107;
pub const connection_reset: std_errc = 108;
pub const cross_device_link: std_errc = 18;
pub const destination_address_required: std_errc = 109;
pub const device_or_resource_busy: std_errc = 16;
pub const directory_not_empty: std_errc = 41;
pub const executable_format_error: std_errc = 8;
pub const file_exists: std_errc = 17;
pub const file_too_large: std_errc = 27;
pub const filename_too_long: std_errc = 38;
pub const function_not_supported: std_errc = 40;
pub const host_unreachable: std_errc = 110;
pub const identifier_removed: std_errc = 111;
pub const illegal_byte_sequence: std_errc = 42;
pub const inappropriate_io_control_operation: std_errc = 25;
pub const interrupted: std_errc = 4;
pub const invalid_argument: std_errc = 22;
pub const invalid_seek: std_errc = 29;
pub const io_error: std_errc = 5;
pub const is_a_directory: std_errc = 21;
pub const message_size: std_errc = 115;
pub const network_down: std_errc = 116;
pub const network_reset: std_errc = 117;
pub const network_unreachable: std_errc = 118;
pub const no_buffer_space: std_errc = 119;
pub const no_child_process: std_errc = 10;
pub const no_link: std_errc = 121;
pub const no_lock_available: std_errc = 39;
pub const no_message_available: std_errc = 120;
pub const no_message: std_errc = 122;
pub const no_protocol_option: std_errc = 123;
pub const no_space_on_device: std_errc = 28;
pub const no_stream_resources: std_errc = 124;
pub const no_such_device_or_address: std_errc = 6;
pub const no_such_device: std_errc = 19;
pub const no_such_file_or_directory: std_errc = 2;
pub const no_such_process: std_errc = 3;
pub const not_a_directory: std_errc = 20;
pub const not_a_socket: std_errc = 128;
pub const not_a_stream: std_errc = 125;
pub const not_connected: std_errc = 126;
pub const not_enough_memory: std_errc = 12;
pub const not_supported: std_errc = 129;
pub const operation_canceled: std_errc = 105;
pub const operation_in_progress: std_errc = 112;
pub const operation_not_permitted: std_errc = 1;
pub const operation_not_supported: std_errc = 130;
pub const operation_would_block: std_errc = 140;
pub const owner_dead: std_errc = 133;
pub const permission_denied: std_errc = 13;
pub const protocol_error: std_errc = 134;
pub const protocol_not_supported: std_errc = 135;
pub const read_only_file_system: std_errc = 30;
pub const resource_deadlock_would_occur: std_errc = 36;
pub const resource_unavailable_try_again: std_errc = 11;
pub const result_out_of_range: std_errc = 34;
pub const state_not_recoverable: std_errc = 127;
pub const stream_timeout: std_errc = 137;
pub const text_file_busy: std_errc = 139;
pub const timed_out: std_errc = 138;
pub const too_many_files_open_in_system: std_errc = 23;
pub const too_many_files_open: std_errc = 24;
pub const too_many_links: std_errc = 31;
pub const too_many_symbolic_link_levels: std_errc = 114;
pub const value_too_large: std_errc = 132;
pub const wrong_protocol_type: std_errc = 136;
pub type std_errc = ::std::os::raw::c_int;
pub const _DEVICE_OR_RESOURCE_BUSY: std__bindgen_ty_1 = 0;
pub const _INVALID_ARGUMENT: std__bindgen_ty_1 = 1;
pub const _NO_SUCH_PROCESS: std__bindgen_ty_1 = 2;
pub const _NOT_ENOUGH_MEMORY: std__bindgen_ty_1 = 3;
pub const _OPERATION_NOT_PERMITTED: std__bindgen_ty_1 = 4;
pub const _RESOURCE_DEADLOCK_WOULD_OCCUR: std__bindgen_ty_1 = 5;
pub const _RESOURCE_UNAVAILABLE_TRY_AGAIN: std__bindgen_ty_1 = 6;
pub type std__bindgen_ty_1 = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_Throw_Cpp_error"]
    pub fn std__Throw_Cpp_error(_Code: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Storage_for {
    pub _Storage: *mut ::std::os::raw::c_uchar,
}
impl Default for std__Storage_for {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Atomic_padded<_Ty> {
    pub _Value: _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std__Atomic_padded<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Atomic_storage_types {
    pub _address: u8,
}
pub type std__Atomic_storage_types__TStorage<_Ty> = std__Atomic_padded<_Ty>;
pub type std__Atomic_storage_types__Spinlock = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct std__Atomic_lock_guard<_Spinlock_t> {
    pub _Spinlock: *mut _Spinlock_t,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Spinlock_t>>,
}
impl<_Spinlock_t> Default for std__Atomic_lock_guard<_Spinlock_t> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std__Atomic_storage__TVal = std_remove_reference_t;
pub type std__Atomic_storage__Guard = std__Atomic_lock_guard<std__Atomic_storage_types>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Atomic_integral_facade {
    pub _address: u8,
}
pub type std__Atomic_integral_facade__Base = u8;
pub type std__Atomic_integral_facade_difference_type<_Ty> = _Ty;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Atomic_pointer {
    pub _address: u8,
}
pub type std__Atomic_pointer__Base = u8;
pub type std__Atomic_pointer_difference_type = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Atomic_nonobject_pointer {
    pub _address: u8,
}
pub type std__Atomic_nonobject_pointer__Base = u8;
pub type std__Atomic_nonobject_pointer_difference_type = ::std::os::raw::c_longlong;
pub type std__Choose_atomic_base2_t = u8;
pub type std__Choose_atomic_base_t = std__Choose_atomic_base2_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std_atomic__Base = std__Choose_atomic_base_t;
pub type std_atomic_value_type<_Ty> = _Ty;
impl Default for std_atomic {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_atomic_bool = std_atomic;
pub type std_atomic_char = std_atomic;
pub type std_atomic_schar = std_atomic;
pub type std_atomic_uchar = std_atomic;
pub type std_atomic_short = std_atomic;
pub type std_atomic_ushort = std_atomic;
pub type std_atomic_int = std_atomic;
pub type std_atomic_uint = std_atomic;
pub type std_atomic_long = std_atomic;
pub type std_atomic_ulong = std_atomic;
pub type std_atomic_llong = std_atomic;
pub type std_atomic_ullong = std_atomic;
pub type std_atomic_char16_t = std_atomic;
pub type std_atomic_char32_t = std_atomic;
pub type std_atomic_wchar_t = std_atomic;
pub type std_atomic_int8_t = std_atomic;
pub type std_atomic_uint8_t = std_atomic;
pub type std_atomic_int16_t = std_atomic;
pub type std_atomic_uint16_t = std_atomic;
pub type std_atomic_int32_t = std_atomic;
pub type std_atomic_uint32_t = std_atomic;
pub type std_atomic_int64_t = std_atomic;
pub type std_atomic_uint64_t = std_atomic;
pub type std_atomic_int_least8_t = std_atomic;
pub type std_atomic_uint_least8_t = std_atomic;
pub type std_atomic_int_least16_t = std_atomic;
pub type std_atomic_uint_least16_t = std_atomic;
pub type std_atomic_int_least32_t = std_atomic;
pub type std_atomic_uint_least32_t = std_atomic;
pub type std_atomic_int_least64_t = std_atomic;
pub type std_atomic_uint_least64_t = std_atomic;
pub type std_atomic_int_fast8_t = std_atomic;
pub type std_atomic_uint_fast8_t = std_atomic;
pub type std_atomic_int_fast16_t = std_atomic;
pub type std_atomic_uint_fast16_t = std_atomic;
pub type std_atomic_int_fast32_t = std_atomic;
pub type std_atomic_uint_fast32_t = std_atomic;
pub type std_atomic_int_fast64_t = std_atomic;
pub type std_atomic_uint_fast64_t = std_atomic;
pub type std_atomic_intptr_t = std_atomic;
pub type std_atomic_uintptr_t = std_atomic;
pub type std_atomic_size_t = std_atomic;
pub type std_atomic_ptrdiff_t = std_atomic;
pub type std_atomic_intmax_t = std_atomic;
pub type std_atomic_uintmax_t = std_atomic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic_flag {
    pub _Storage: std_atomic,
}
impl Default for std_atomic_flag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const stream: std_io_errc = 1;
pub type std_io_errc = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_error_code_enum {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_error_condition_enum {
    pub _base: std_false_type,
}
#[repr(C)]
pub struct std_error_category__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct std_error_category {
    pub vtable_: *const std_error_category__bindgen_vtable,
    pub _Addr: std_error_category__Addr_storage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_error_category__Addr_storage {
    pub _Num: ::std::os::raw::c_ulonglong,
    pub _Ptr: *mut std_error_category,
}
impl Default for std_error_category__Addr_storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const _Future_addr: std_error_category__bindgen_ty_1 = 1;
pub const _Generic_addr: std_error_category__bindgen_ty_1 = 3;
pub const _Iostream_addr: std_error_category__bindgen_ty_1 = 5;
pub const _System_addr: std_error_category__bindgen_ty_1 = 7;
pub type std_error_category__bindgen_ty_1 = ::std::os::raw::c_ulonglong;
impl Default for std_error_category {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_code {
    pub _Myval: ::std::os::raw::c_int,
    pub _Mycat: *const std_error_category,
}
impl Default for std_error_code {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_condition {
    pub _Myval: ::std::os::raw::c_int,
    pub _Mycat: *const std_error_category,
}
impl Default for std_error_condition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__System_error {
    pub _base: std_runtime_error,
    pub _Mycode: std_error_code,
}
impl Default for std__System_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_system_error {
    pub _base: std__System_error,
}
pub type std_system_error__Mybase = std__System_error;
impl Default for std_system_error {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}_Syserror_map"]
    pub fn std__Syserror_map(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_Winerror_map"]
    pub fn std__Winerror_map(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct std__System_error_message {
    pub _Str: *mut ::std::os::raw::c_char,
    pub _Length: ::std::os::raw::c_ulonglong,
}
impl Default for std__System_error_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__Generic_error_category {
    pub _base: std_error_category,
}
impl Default for std__Generic_error_category {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__Iostream_error_category2 {
    pub _base: std_error_category,
}
impl Default for std__Iostream_error_category2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__System_error_category {
    pub _base: std_error_category,
}
impl Default for std__System_error_category {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_cast {
    pub _base: std_exception,
}
impl Default for std_bad_cast {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_typeid {
    pub _base: std_exception,
}
impl Default for std_bad_typeid {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std___non_rtti_object {
    pub _base: std_bad_typeid,
}
impl Default for std___non_rtti_object {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const std__Small_object_num_ptrs: ::std::os::raw::c_int = 8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_raw_storage_iterator<_OutIt> {
    pub _Next: _OutIt,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_OutIt>>,
}
pub type std_raw_storage_iterator_iterator_category = std_output_iterator_tag;
pub type std_raw_storage_iterator_value_type = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_difference_type = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_pointer = ::std::os::raw::c_void;
pub type std_raw_storage_iterator_reference = ::std::os::raw::c_void;
impl<_OutIt> Default for std_raw_storage_iterator<_OutIt> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_auto_ptr_ref<_Ty> {
    pub _Ref: *mut _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std_auto_ptr_ref<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_auto_ptr<_Ty> {
    pub _Myptr: *mut _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
pub type std_auto_ptr_element_type<_Ty> = _Ty;
impl<_Ty> Default for std_auto_ptr<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_bad_weak_ptr {
    pub _base: std_exception,
}
impl Default for std_bad_weak_ptr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__Ref_count_base__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std__Ref_count_base {
    pub vtable_: *const std__Ref_count_base__bindgen_vtable,
    pub _Uses: std__Atomic_counter_t,
    pub _Weaks: std__Atomic_counter_t,
}
impl Default for std__Ref_count_base {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Ref_count<_Ty> {
    pub _base: std__Ref_count_base,
    pub _Ptr: *mut _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std__Ref_count<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Ref_count_resource {
    pub _base: std__Ref_count_base,
    pub _Mypair: u8,
}
impl Default for std__Ref_count_resource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Ref_count_resource_alloc {
    pub _base: std__Ref_count_base,
    pub _Mypair: u8,
}
pub type std__Ref_count_resource_alloc__Myalty = std__Rebind_alloc_t;
impl Default for std__Ref_count_resource_alloc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Can_enable_shared {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Exception_ptr_access {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Ptr_base {
    pub _Ptr: *mut std__Ptr_base_element_type,
    pub _Rep: *mut std__Ref_count_base,
}
pub type std__Ptr_base_element_type = std_remove_extent_t;
impl Default for std__Ptr_base {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Can_scalar_delete {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Can_array_delete {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Can_call_function_object {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__SP_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__SP_pointer_compatible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Temporary_owner<_Ux> {
    pub _Ptr: *mut _Ux,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ux>>,
}
impl<_Ux> Default for std__Temporary_owner<_Ux> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Temporary_owner_del<_UxptrOrNullptr, _Dx> {
    pub _Ptr: _UxptrOrNullptr,
    pub _Dt: *mut _Dx,
    pub _Call_deleter: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_UxptrOrNullptr>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Dx>>,
}
impl<_UxptrOrNullptr, _Dx> Default for std__Temporary_owner_del<_UxptrOrNullptr, _Dx> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_shared_ptr {
    pub _base: std__Ptr_base,
}
pub type std_shared_ptr__Mybase = std__Ptr_base;
impl Default for std_shared_ptr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__Ref_count_obj2 {
    pub _base: std__Ref_count_base,
    pub __bindgen_anon_1: std__Ref_count_obj2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(1))]
pub struct std__Ref_count_obj2__bindgen_ty_1 {
    pub _Storage: __BindgenUnionField<std__Wrap<std_remove_cv_t>>,
    pub bindgen_union_field: [u8; 0usize],
}
impl Default for std__Ref_count_obj2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for std__Ref_count_obj2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std__Ref_count_obj_alloc3<_Ty> {
    pub _base_1: std__Ref_count_base,
    pub __bindgen_anon_1: std__Ref_count_obj_alloc3__bindgen_ty_1<_Ty>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
pub type std__Ref_count_obj_alloc3__Rebound = std__Rebind_alloc_t;
#[repr(C)]
#[repr(align(1))]
pub struct std__Ref_count_obj_alloc3__bindgen_ty_1<_Ty> {
    pub _Storage: __BindgenUnionField<std__Wrap<_Ty>>,
    pub bindgen_union_field: [u8; 0usize],
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std__Ref_count_obj_alloc3__bindgen_ty_1<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl<_Ty> Default for std__Ref_count_obj_alloc3<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_weak_ptr {
    pub _base: std__Ptr_base,
}
impl Default for std_weak_ptr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_enable_shared_from_this {
    pub _Wptr: std_weak_ptr,
}
pub type std_enable_shared_from_this__Esft_type = std_enable_shared_from_this;
impl Default for std_enable_shared_from_this {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Get_deleter_pointer_type {
    pub _address: u8,
}
pub type std__Get_deleter_pointer_type_type<_Ty> = *mut _Ty;
pub type std__Unique_ptr_enable_default_t = std_enable_if_t;
#[repr(C)]
#[derive(Debug, Default)]
pub struct std_unique_ptr {
    pub _Mypair: u8,
}
pub type std_unique_ptr_pointer = std__Get_deleter_pointer_type;
pub type std_unique_ptr_element_type<_Ty> = _Ty;
pub type std_unique_ptr_deleter_type<_Dx> = _Dx;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Can_stream_unique_ptr {
    pub _base: std_false_type,
}
pub const relaxed: std_pointer_safety = 0;
pub const preferred: std_pointer_safety = 1;
pub const strict: std_pointer_safety = 2;
pub type std_pointer_safety = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_owner_less {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_Lock_shared_ptr_spin_lock"]
    pub fn std__Lock_shared_ptr_spin_lock();
}
extern "C" {
    #[link_name = "\u{1}_Unlock_shared_ptr_spin_lock"]
    pub fn std__Unlock_shared_ptr_spin_lock();
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct std__Shared_ptr_spin_lock {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Tuple_constructible_val {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Tuple_assignable_val {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Tuple_convert_val {
    pub _base: std_true_type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Tuple_perfect_val {
    pub _base: std_true_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Tuple_val<_Ty> {
    pub _Val: _Ty,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Ty>>,
}
impl<_Ty> Default for std__Tuple_val<_Ty> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Exact_args_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Unpack_tuple_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Alloc_exact_args_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Alloc_unpack_tuple_t {
    pub _address: u8,
}
pub type std__Tuple_cat1 = u8;
#[repr(C)]
#[derive(Debug)]
pub struct std_thread {
    pub _Thr: _Thrd_t,
}
pub type std_thread_native_handle_type = *mut ::std::os::raw::c_void;
impl Default for std_thread {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std__Clamped_rel_time_ms_count_result {
    pub _Count: ::std::os::raw::c_ulong,
    pub _Clamped: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_thread_id {
    pub _Id: _Thrd_id_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_condition_variable_any {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std__Mutex_base {
    pub _Mtx_storage: _Mtx_internal_imp_t,
}
impl Default for std__Mutex_base {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_mutex {
    pub _base: std__Mutex_base,
}
impl Default for std_mutex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct std_recursive_mutex {
    pub _base: std__Mutex_base,
}
impl Default for std_recursive_mutex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_adopt_lock_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_defer_lock_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_try_to_lock_t {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}adopt_lock"]
    pub static std_adopt_lock: std_adopt_lock_t;
}
extern "C" {
    #[link_name = "\u{1}defer_lock"]
    pub static std_defer_lock: std_defer_lock_t;
}
extern "C" {
    #[link_name = "\u{1}try_to_lock"]
    pub static std_try_to_lock: std_try_to_lock_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_lock<_Mutex> {
    pub _Pmtx: *mut _Mutex,
    pub _Owns: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Mutex>>,
}
pub type std_unique_lock_mutex_type<_Mutex> = _Mutex;
impl<_Mutex> Default for std_unique_lock<_Mutex> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Unlock_call_guard<_Fn> {
    pub _Func: _Fn,
    pub _Valid: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Fn>>,
}
impl<_Fn> Default for std__Unlock_call_guard<_Fn> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Unlock_one_guard<_Lock> {
    pub _Lk_ptr: *mut _Lock,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Lock>>,
}
impl<_Lock> Default for std__Unlock_one_guard<_Lock> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std_lock_guard<_Mutex> {
    pub _MyMutex: *mut _Mutex,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Mutex>>,
}
pub type std_lock_guard_mutex_type<_Mutex> = _Mutex;
impl<_Mutex> Default for std_lock_guard<_Mutex> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const no_timeout: std_cv_status = 0;
pub const timeout: std_cv_status = 1;
pub type std_cv_status = ::std::os::raw::c_int;
#[repr(C)]
pub struct std_condition_variable {
    pub _Cnd_storage: _Cnd_internal_imp_t,
}
impl Default for std_condition_variable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__UInt_is_zero {
    pub _UInt: *const ::std::os::raw::c_uint,
}
impl Default for std__UInt_is_zero {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std_timed_mutex {
    pub _My_mutex: std_mutex,
    pub _My_cond: std_condition_variable,
    pub _My_locked: ::std::os::raw::c_uint,
}
impl Default for std_timed_mutex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std_recursive_timed_mutex {
    pub _My_mutex: std_mutex,
    pub _My_cond: std_condition_variable,
    pub _My_locked: ::std::os::raw::c_uint,
    pub _My_owner: std_thread_id,
}
impl Default for std_recursive_timed_mutex {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _HFILE = *mut ::std::os::raw::c_void;
pub type _CRT_REPORT_HOOK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type _CRT_REPORT_HOOKW = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut u16,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type _CRT_ALLOC_HOOK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_long,
        arg6: *const ::std::os::raw::c_uchar,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type _CRT_DUMP_CLIENT =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: usize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CrtMemBlockHeader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CrtMemState {
    pub pBlockHeader: *mut _CrtMemBlockHeader,
    pub lCounts: [usize; 5usize],
    pub lSizes: [usize; 5usize],
    pub lHighWaterCount: usize,
    pub lTotalCount: usize,
}
impl Default for _CrtMemState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut u16;
}
extern "C" {
    pub fn _wasctime_s(_Buffer: *mut u16, _SizeInWords: usize, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _Format: *const u16,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut u16;
}
extern "C" {
    pub fn _wctime32_s(_Buffer: *mut u16, _SizeInWords: usize, _Time: *const __time32_t)
        -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut u16;
}
extern "C" {
    pub fn _wctime64_s(_Buffer: *mut u16, _SizeInWords: usize, _Time: *const __time64_t)
        -> errno_t;
}
extern "C" {
    pub fn _wstrdate_s(_Buffer: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wstrtime_s(_Buffer: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut u16) -> *mut u16;
}
pub type clock_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
extern "C" {
    pub fn __daylight() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dstbias() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __timezone() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __tzname() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_DaylightSavingsBias: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_TimeZone: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Index: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn strftime(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _strftime_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxSize: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _strdate_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _timespec32_get(
        _Ts: *mut _timespec32,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _timespec64_get(
        _Ts: *mut _timespec64,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _setsystime(
        _Tm: *mut tm,
        _Milliseconds: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _clearfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _controlfp(
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _set_controlfp(_NewValue: ::std::os::raw::c_uint, _Mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _controlfp_s(
        _CurrentState: *mut ::std::os::raw::c_uint,
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> errno_t;
}
extern "C" {
    pub fn _statusfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _fpreset();
}
extern "C" {
    pub fn _control87(
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __fpecode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpe_flt_rounds() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
    pub fn _scalb(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn _logb(_X: f64) -> f64;
}
extern "C" {
    pub fn _nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _finite(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnan(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclass(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scalbf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn fpreset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
impl Default for _iobuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: u16) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut u16,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut u16;
}
extern "C" {
    pub fn fputws(_Buffer: *const u16, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut u16, _BufferCount: usize) -> *mut u16;
}
extern "C" {
    pub fn putwc(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: u16) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(_Stream: *mut *mut FILE, _FileName: *const u16, _Mode: *const u16) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(_FileName: *const u16, _Mode: *const u16, _OldStream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const u16,
        _Mode: *const u16,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const u16,
        _Mode: *const u16,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const u16);
}
extern "C" {
    pub fn _wpopen(_Command: *const u16, _Mode: *const u16) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const u16, _FilePrefix: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut u16, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: u16, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const u16,
        _BufferCount: usize,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const u16, _Ch: u16) -> *const u16;
}
extern "C" {
    pub fn wcsrchr(_Str: *const u16, _Ch: u16) -> *const u16;
}
extern "C" {
    pub fn wcsstr(_Str: *const u16, _SubStr: *const u16) -> *const u16;
}
extern "C" {
    pub fn _cgetws_s(_Buffer: *mut u16, _BufferCount: usize, _SizeRead: *mut usize) -> errno_t;
}
extern "C" {
    pub fn _cputws(_Buffer: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getwch() -> wint_t;
}
extern "C" {
    pub fn _getwche() -> wint_t;
}
extern "C" {
    pub fn _putwch(_Character: u16) -> wint_t;
}
extern "C" {
    pub fn _ungetwch(_Character: wint_t) -> wint_t;
}
extern "C" {
    pub fn _getwch_nolock() -> wint_t;
}
extern "C" {
    pub fn _getwche_nolock() -> wint_t;
}
extern "C" {
    pub fn _putwch_nolock(_Character: u16) -> wint_t;
}
extern "C" {
    pub fn _ungetwch_nolock(_Character: wint_t) -> wint_t;
}
extern "C" {
    pub fn __conio_common_vcwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __conio_common_vcwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __conio_common_vcwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __conio_common_vcwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Format: *const u16,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __pctype_func() -> *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __pwctype_func() -> *const wctype_t;
}
extern "C" {
    pub fn iswalnum(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswascii(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsymf(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsym(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswblank_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isleadbyte_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wgetcwd(_DstBuf: *mut u16, _SizeInWords: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wgetdcwd(
        _Drive: ::std::os::raw::c_int,
        _DstBuf: *mut u16,
        _SizeInWords: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _wchdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wmkdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wrmdir(_Path: *const u16) -> ::std::os::raw::c_int;
}
pub type _fsize_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: _fsize_t,
    pub name: [u16; 260usize],
}
impl Default for _wfinddata32_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata32i64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time32_t,
    pub time_access: __time32_t,
    pub time_write: __time32_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [u16; 260usize],
}
impl Default for _wfinddata32i64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata64i32_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: _fsize_t,
    pub name: [u16; 260usize],
}
impl Default for _wfinddata64i32_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wfinddata64_t {
    pub attrib: ::std::os::raw::c_uint,
    pub time_create: __time64_t,
    pub time_access: __time64_t,
    pub time_write: __time64_t,
    pub size: ::std::os::raw::c_longlong,
    pub name: [u16; 260usize],
}
impl Default for _wfinddata64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _waccess(
        _FileName: *const u16,
        _AccessMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _waccess_s(_FileName: *const u16, _AccessMode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _wchmod(_FileName: *const u16, _Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcreat(
        _FileName: *const u16,
        _PermissionMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindfirst32(_FileName: *const u16, _FindData: *mut _wfinddata32_t) -> isize;
}
extern "C" {
    pub fn _wfindnext32(
        _FindHandle: isize,
        _FindData: *mut _wfinddata32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wunlink(_FileName: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wrename(_OldFileName: *const u16, _NewFileName: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wmktemp_s(_TemplateName: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wmktemp(_TemplateName: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wfindfirst32i64(_FileName: *const u16, _FindData: *mut _wfinddata32i64_t) -> isize;
}
extern "C" {
    pub fn _wfindfirst64i32(_FileName: *const u16, _FindData: *mut _wfinddata64i32_t) -> isize;
}
extern "C" {
    pub fn _wfindfirst64(_FileName: *const u16, _FindData: *mut _wfinddata64_t) -> isize;
}
extern "C" {
    pub fn _wfindnext32i64(
        _FindHandle: isize,
        _FindData: *mut _wfinddata32i64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindnext64i32(
        _FindHandle: isize,
        _FindData: *mut _wfinddata64i32_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wfindnext64(
        _FindHandle: isize,
        _FindData: *mut _wfinddata64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wsopen_s(
        _FileHandle: *mut ::std::os::raw::c_int,
        _FileName: *const u16,
        _OpenFlag: ::std::os::raw::c_int,
        _ShareFlag: ::std::os::raw::c_int,
        _PermissionFlag: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsopen_dispatch(
        _FileName: *const u16,
        _OFlag: ::std::os::raw::c_int,
        _ShFlag: ::std::os::raw::c_int,
        _PMode: ::std::os::raw::c_int,
        _PFileHandle: *mut ::std::os::raw::c_int,
        _BSecure: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wexecl(_FileName: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexecle(_FileName: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexeclp(_FileName: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexeclpe(_FileName: *const u16, _ArgList: *const u16, ...) -> isize;
}
extern "C" {
    pub fn _wexecv(_FileName: *const u16, _ArgList: *const *const u16) -> isize;
}
extern "C" {
    pub fn _wexecve(
        _FileName: *const u16,
        _ArgList: *const *const u16,
        _Env: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wexecvp(_FileName: *const u16, _ArgList: *const *const u16) -> isize;
}
extern "C" {
    pub fn _wexecvpe(
        _FileName: *const u16,
        _ArgList: *const *const u16,
        _Env: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnl(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const u16,
        _ArgList: *const u16,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnle(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const u16,
        _ArgList: *const u16,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnlp(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const u16,
        _ArgList: *const u16,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnlpe(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const u16,
        _ArgList: *const u16,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _wspawnv(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const u16,
        _ArgList: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnve(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const u16,
        _ArgList: *const *const u16,
        _Env: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnvp(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const u16,
        _ArgList: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wspawnvpe(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const u16,
        _ArgList: *const *const u16,
        _Env: *const *const u16,
    ) -> isize;
}
extern "C" {
    pub fn _wsystem(_Command: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn wcstod(_String: *const u16, _EndPtr: *mut *mut u16) -> f64;
}
extern "C" {
    pub fn _wcstod_l(_String: *const u16, _EndPtr: *mut *mut u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const u16, _EndPtr: *mut *mut u16) -> f64;
}
extern "C" {
    pub fn _wcstold_l(_String: *const u16, _EndPtr: *mut *mut u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const u16, _EndPtr: *mut *mut u16) -> f32;
}
extern "C" {
    pub fn _wcstof_l(_String: *const u16, _EndPtr: *mut *mut u16, _Locale: _locale_t) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const u16) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const u16, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const u16) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const u16) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut u16;
}
extern "C" {
    pub fn _wtoi64(_String: *const u16) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const u16, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const u16,
        _EndPtr: *mut *mut u16,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(_Buffer: *mut u16, _Path: *const u16, _BufferCount: usize) -> *mut u16;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut u16,
        _BufferCount: usize,
        _Drive: *const u16,
        _Dir: *const u16,
        _Filename: *const u16,
        _Ext: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut u16,
        _Drive: *const u16,
        _Dir: *const u16,
        _Filename: *const u16,
        _Ext: *const u16,
    );
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const u16,
        _Drive: *mut u16,
        _Dir: *mut u16,
        _Filename: *mut u16,
        _Ext: *mut u16,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const u16,
        _Drive: *mut u16,
        _DriveCount: usize,
        _Dir: *mut u16,
        _DirCount: usize,
        _Filename: *mut u16,
        _FilenameCount: usize,
        _Ext: *mut u16,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut u16,
        _BufferCount: *mut usize,
        _VarName: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut u16,
        _BufferCount: usize,
        _VarName: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const u16, _Value: *const u16) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const u16,
        _VarName: *const u16,
        _Buffer: *mut u16,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(_Filename: *const u16, _VarName: *const u16, _ResultPath: *mut u16);
}
extern "C" {
    pub fn wcscat_s(_Destination: *mut u16, _SizeInWords: rsize_t, _Source: *const u16) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(_Destination: *mut u16, _SizeInWords: rsize_t, _Source: *const u16) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut u16,
        _SizeInWords: rsize_t,
        _Source: *const u16,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut u16,
        _SizeInWords: rsize_t,
        _Source: *const u16,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(_String: *mut u16, _Delimiter: *const u16, _Context: *mut *mut u16)
        -> *mut u16;
}
extern "C" {
    pub fn _wcsdup(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscat(_Destination: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut u16, _Source: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcscspn(_String: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const u16) -> usize;
}
extern "C" {
    pub fn wcsnlen(_Source: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(_Destination: *mut u16, _Source: *const u16, _Count: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(_Destination: *mut u16, _Source: *const u16, _Count: usize) -> *mut u16;
}
extern "C" {
    pub fn wcspbrk(_String: *const u16, _Control: *const u16) -> *const u16;
}
extern "C" {
    pub fn wcsspn(_String: *const u16, _Control: *const u16) -> usize;
}
extern "C" {
    pub fn wcstok(_String: *mut u16, _Delimiter: *const u16, _Context: *mut *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut u16;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut u16,
        _SizeInWords: usize,
        _ErrorMessage: *const u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut u16,
        _SizeInWords: usize,
        _Value: u16,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut u16, _Value: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn _wcsrev(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut u16, _SizeInWords: usize, _Value: u16) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut u16, _Value: u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut u16, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut u16, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut u16, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut u16, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut u16, _Locale: _locale_t) -> *mut u16;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut u16, _Source: *const u16, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut u16,
        _Source: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicmp(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const u16,
        _String2: *const u16,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut u16, _Value: u16, _MaxCount: usize) -> *mut u16;
}
extern "C" {
    pub fn wcsrev(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsset(_String: *mut u16, _Value: u16) -> *mut u16;
}
extern "C" {
    pub fn wcslwr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsupr(_String: *mut u16) -> *mut u16;
}
extern "C" {
    pub fn wcsicoll(_String1: *const u16, _String2: *const u16) -> ::std::os::raw::c_int;
}
pub type _ino_t = ::std::os::raw::c_ushort;
pub type ino_t = _ino_t;
pub type _dev_t = ::std::os::raw::c_uint;
pub type dev_t = _dev_t;
pub type _off_t = ::std::os::raw::c_long;
pub type off_t = _off_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _stat32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _stat32i64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time32_t,
    pub st_mtime: __time32_t,
    pub st_ctime: __time32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _stat64i32 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _stat64 {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: ::std::os::raw::c_longlong,
    pub st_atime: __time64_t,
    pub st_mtime: __time64_t,
    pub st_ctime: __time64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stat {
    pub st_dev: _dev_t,
    pub st_ino: _ino_t,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_short,
    pub st_uid: ::std::os::raw::c_short,
    pub st_gid: ::std::os::raw::c_short,
    pub st_rdev: _dev_t,
    pub st_size: _off_t,
    pub st_atime: time_t,
    pub st_mtime: time_t,
    pub st_ctime: time_t,
}
extern "C" {
    pub fn _fstat32(
        _FileHandle: ::std::os::raw::c_int,
        _Stat: *mut _stat32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fstat32i64(
        _FileHandle: ::std::os::raw::c_int,
        _Stat: *mut _stat32i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fstat64i32(
        _FileHandle: ::std::os::raw::c_int,
        _Stat: *mut _stat64i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fstat64(
        _FileHandle: ::std::os::raw::c_int,
        _Stat: *mut _stat64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stat32(
        _FileName: *const ::std::os::raw::c_char,
        _Stat: *mut _stat32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stat32i64(
        _FileName: *const ::std::os::raw::c_char,
        _Stat: *mut _stat32i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stat64i32(
        _FileName: *const ::std::os::raw::c_char,
        _Stat: *mut _stat64i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stat64(
        _FileName: *const ::std::os::raw::c_char,
        _Stat: *mut _stat64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat32(_FileName: *const u16, _Stat: *mut _stat32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat32i64(_FileName: *const u16, _Stat: *mut _stat32i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat64i32(_FileName: *const u16, _Stat: *mut _stat64i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wstat64(_FileName: *const u16, _Stat: *mut _stat64) -> ::std::os::raw::c_int;
}
pub type _Wint_t = u16;
extern "C" {
    pub fn _wsetlocale(_Category: ::std::os::raw::c_int, _Locale: *const u16) -> *mut u16;
}
extern "C" {
    pub fn _wcreate_locale(_Category: ::std::os::raw::c_int, _Locale: *const u16) -> _locale_t;
}
extern "C" {
    pub fn btowc(_Ch: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn mbrlen(
        _Ch: *const ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbrtowc(
        _DstCh: *mut u16,
        _SrcCh: *const ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbsrtowcs_s(
        _Retval: *mut usize,
        _Dst: *mut u16,
        _Size: usize,
        _PSrc: *mut *const ::std::os::raw::c_char,
        _N: usize,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn mbsrtowcs(
        _Dest: *mut u16,
        _PSrc: *mut *const ::std::os::raw::c_char,
        _Count: usize,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb_s(
        _Retval: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Ch: u16,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcrtomb(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: u16,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsrtombs_s(
        _Retval: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Src: *mut *const u16,
        _Size: usize,
        _State: *mut mbstate_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsrtombs(
        _Dest: *mut ::std::os::raw::c_char,
        _PSource: *mut *const u16,
        _Count: usize,
        _State: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wctob(_WCh: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy_s(_S1: *mut u16, _N1: rsize_t, _S2: *const u16, _N: rsize_t) -> errno_t;
}
extern "C" {
    pub fn wmemmove_s(_S1: *mut u16, _N1: rsize_t, _S2: *const u16, _N: rsize_t) -> errno_t;
}
extern "C" {
    pub fn _BitScanForward(
        _Index: *mut ::std::os::raw::c_ulong,
        _Mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanReverse(
        _Index: *mut ::std::os::raw::c_ulong,
        _Mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _ReadWriteBarrier();
}
extern "C" {
    pub fn _umul128(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_ulonglong,
        arg3: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __shiftleft128(
        _LowPart: ::std::os::raw::c_ulonglong,
        _HighPart: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __shiftright128(
        _LowPart: ::std::os::raw::c_ulonglong,
        _HighPart: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _mm_pause();
}
extern "C" {
    pub fn _InterlockedCompareExchange128(
        _Destination: *mut ::std::os::raw::c_longlong,
        _ExchangeHigh: ::std::os::raw::c_longlong,
        _ExchangeLow: ::std::os::raw::c_longlong,
        _ComparandResult: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanForward64(
        _Index: *mut ::std::os::raw::c_ulong,
        _Mask: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanReverse64(
        _Index: *mut ::std::os::raw::c_ulong,
        _Mask: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _InterlockedDecrement64(
        _Addend: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchange64(
        _Target: *mut ::std::os::raw::c_longlong,
        _Value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchangeAdd64(
        _Addend: *mut ::std::os::raw::c_longlong,
        _Value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchangeSub64(
        _Subend: *mut ::std::os::raw::c_longlong,
        _Value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedIncrement64(
        _Addend: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedOr64(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedXor64(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedAnd64(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
pub type max_align_t = f64;
extern "C" {
    pub fn _Xtime_get_ticks() -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _Query_perf_counter() -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _Query_perf_frequency() -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
impl Default for _exception {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _complex {
    pub x: f64,
    pub y: f64,
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub static _HUGE: f64;
}
extern "C" {
    pub fn _fperrraise(_Except: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _dclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdclass(_X: f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdsign(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdpcomp(_X: f32, _Y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdtest(_Px: *mut f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _d_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ld_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fd_int(_Px: *mut f32, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdscale(_Px: *mut f32, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f32)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdexp(_Px: *mut f32, _Y: f32, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdpoly(_X: f32, _Tab: *const f32, _N: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdlog(_X: f32, _Baseflag: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _ldsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _fdsin(_X: f32, _Qoff: ::std::os::raw::c_uint) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
impl Default for _double_val {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
    pub _Sh: [::std::os::raw::c_ushort; 2usize],
    pub _Val: f32,
}
impl Default for _float_val {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
}
impl Default for _ldouble_val {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
    pub _Word: [::std::os::raw::c_ushort; 4usize],
    pub _Float: f32,
    pub _Double: f64,
    pub _Long_double: f64,
}
impl Default for _float_const {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static _Denorm_C: _float_const;
}
extern "C" {
    pub static _Inf_C: _float_const;
}
extern "C" {
    pub static _Nan_C: _float_const;
}
extern "C" {
    pub static _Snan_C: _float_const;
}
extern "C" {
    pub static _Hugeval_C: _float_const;
}
extern "C" {
    pub static _FDenorm_C: _float_const;
}
extern "C" {
    pub static _FInf_C: _float_const;
}
extern "C" {
    pub static _FNan_C: _float_const;
}
extern "C" {
    pub static _FSnan_C: _float_const;
}
extern "C" {
    pub static _LDenorm_C: _float_const;
}
extern "C" {
    pub static _LInf_C: _float_const;
}
extern "C" {
    pub static _LNan_C: _float_const;
}
extern "C" {
    pub static _LSnan_C: _float_const;
}
extern "C" {
    pub static _Eps_C: _float_const;
}
extern "C" {
    pub static _Rteps_C: _float_const;
}
extern "C" {
    pub static _FEps_C: _float_const;
}
extern "C" {
    pub static _FRteps_C: _float_const;
}
extern "C" {
    pub static _LEps_C: _float_const;
}
extern "C" {
    pub static _LRteps_C: _float_const;
}
extern "C" {
    pub static _Zero_C: f64;
}
extern "C" {
    pub static _Xbig_C: f64;
}
extern "C" {
    pub static _FZero_C: f32;
}
extern "C" {
    pub static _FXbig_C: f32;
}
extern "C" {
    pub static _LZero_C: f64;
}
extern "C" {
    pub static _LXbig_C: f64;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Combined_type {
    pub _address: u8,
}
pub type _Combined_type__Type = f32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Real_widened {
    pub _address: u8,
}
pub type _Real_widened__Type = f64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Real_type {
    pub _address: u8,
}
pub type _Real_type__Type = f64;
extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_X: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn acos(_X: f64) -> f64;
}
extern "C" {
    pub fn asin(_X: f64) -> f64;
}
extern "C" {
    pub fn atan(_X: f64) -> f64;
}
extern "C" {
    pub fn atan2(_Y: f64, _X: f64) -> f64;
}
extern "C" {
    pub fn cos(_X: f64) -> f64;
}
extern "C" {
    pub fn cosh(_X: f64) -> f64;
}
extern "C" {
    pub fn exp(_X: f64) -> f64;
}
extern "C" {
    pub fn fabs(_X: f64) -> f64;
}
extern "C" {
    pub fn fmod(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn log(_X: f64) -> f64;
}
extern "C" {
    pub fn log10(_X: f64) -> f64;
}
extern "C" {
    pub fn pow(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn sin(_X: f64) -> f64;
}
extern "C" {
    pub fn sinh(_X: f64) -> f64;
}
extern "C" {
    pub fn sqrt(_X: f64) -> f64;
}
extern "C" {
    pub fn tan(_X: f64) -> f64;
}
extern "C" {
    pub fn tanh(_X: f64) -> f64;
}
extern "C" {
    pub fn acosh(_X: f64) -> f64;
}
extern "C" {
    pub fn asinh(_X: f64) -> f64;
}
extern "C" {
    pub fn atanh(_X: f64) -> f64;
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _cabs(_Complex_value: _complex) -> f64;
}
extern "C" {
    pub fn cbrt(_X: f64) -> f64;
}
extern "C" {
    pub fn ceil(_X: f64) -> f64;
}
extern "C" {
    pub fn copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erf(_X: f64) -> f64;
}
extern "C" {
    pub fn erfc(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1(_X: f64) -> f64;
}
extern "C" {
    pub fn fdim(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn floor(_X: f64) -> f64;
}
extern "C" {
    pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmax(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmin(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogb(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn llrint(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1p(_X: f64) -> f64;
}
extern "C" {
    pub fn log2(_X: f64) -> f64;
}
extern "C" {
    pub fn logb(_X: f64) -> f64;
}
extern "C" {
    pub fn lrint(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _matherr(_Except: *mut _exception) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
}
extern "C" {
    pub fn nan(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyint(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainder(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquo(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(_X: f64) -> f64;
}
extern "C" {
    pub fn round(_X: f64) -> f64;
}
extern "C" {
    pub fn scalbln(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbn(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn trunc(_X: f64) -> f64;
}
extern "C" {
    pub fn _j0(_X: f64) -> f64;
}
extern "C" {
    pub fn _j1(_X: f64) -> f64;
}
extern "C" {
    pub fn _jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn _y0(_X: f64) -> f64;
}
extern "C" {
    pub fn _y1(_X: f64) -> f64;
}
extern "C" {
    pub fn _yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn acoshf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn atanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn _chgsignf(_X: f32) -> f32;
}
extern "C" {
    pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn erff(_X: f32) -> f32;
}
extern "C" {
    pub fn erfcf(_X: f32) -> f32;
}
extern "C" {
    pub fn expm1f(_X: f32) -> f32;
}
extern "C" {
    pub fn exp2f(_X: f32) -> f32;
}
extern "C" {
    pub fn fdimf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fminf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _hypotf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn llrintf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pf(_X: f32) -> f32;
}
extern "C" {
    pub fn log2f(_X: f32) -> f32;
}
extern "C" {
    pub fn logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn lrintf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanf(_X: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nearbyintf(_X: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn remquof(_X: f32, _Y: f32, _Z: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(_X: f32) -> f32;
}
extern "C" {
    pub fn roundf(_X: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbnf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn tgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn truncf(_X: f32) -> f32;
}
extern "C" {
    pub fn _logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_FMA3_enable(_Flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_FMA3_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinf(_X: f32) -> f32;
}
extern "C" {
    pub fn atan2f(_Y: f32, _X: f32) -> f32;
}
extern "C" {
    pub fn atanf(_X: f32) -> f32;
}
extern "C" {
    pub fn ceilf(_X: f32) -> f32;
}
extern "C" {
    pub fn cosf(_X: f32) -> f32;
}
extern "C" {
    pub fn coshf(_X: f32) -> f32;
}
extern "C" {
    pub fn expf(_X: f32) -> f32;
}
extern "C" {
    pub fn floorf(_X: f32) -> f32;
}
extern "C" {
    pub fn fmodf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn log10f(_X: f32) -> f32;
}
extern "C" {
    pub fn logf(_X: f32) -> f32;
}
extern "C" {
    pub fn modff(_X: f32, _Y: *mut f32) -> f32;
}
extern "C" {
    pub fn powf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn sinf(_X: f32) -> f32;
}
extern "C" {
    pub fn sinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn acoshl(_X: f64) -> f64;
}
extern "C" {
    pub fn asinhl(_X: f64) -> f64;
}
extern "C" {
    pub fn atanhl(_X: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(_X: f64) -> f64;
}
extern "C" {
    pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erfl(_X: f64) -> f64;
}
extern "C" {
    pub fn erfcl(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2l(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1l(_X: f64) -> f64;
}
extern "C" {
    pub fn fdiml(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fminl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogbl(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn llrintl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pl(_X: f64) -> f64;
}
extern "C" {
    pub fn log2l(_X: f64) -> f64;
}
extern "C" {
    pub fn logbl(_X: f64) -> f64;
}
extern "C" {
    pub fn lrintl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanl(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyintl(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquol(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rintl(_X: f64) -> f64;
}
extern "C" {
    pub fn roundl(_X: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbnl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn truncl(_X: f64) -> f64;
}
extern "C" {
    pub static mut HUGE: f64;
}
extern "C" {
    pub fn j0(_X: f64) -> f64;
}
extern "C" {
    pub fn j1(_X: f64) -> f64;
}
extern "C" {
    pub fn jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn y0(_X: f64) -> f64;
}
extern "C" {
    pub fn y1(_X: f64) -> f64;
}
extern "C" {
    pub fn yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const u16,
        arg2: *const u16,
        arg3: *const u16,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut u16;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut u16) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut u16,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut u16,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut u16,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut u16,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut u16,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: u16,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: u16,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: u16,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const u16,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const u16,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const u16,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const u16,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut u16;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut u16;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn __std_get_string_size_without_trailing_whitespace(
        _Str: *const ::std::os::raw::c_char,
        _Size: usize,
    ) -> usize;
}
extern "C" {
    pub fn __std_system_error_allocate_message(
        _Message_id: ::std::os::raw::c_ulong,
        _Ptr_str: *mut *mut ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn __std_system_error_deallocate_message(_Str: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
impl Default for _heapinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _HEAPINFO = _heapinfo;
extern "C" {
    pub fn _alloca(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
pub type terminate_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type terminate_function = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn terminate() -> !;
}
extern "C" {
    pub fn set_terminate(_NewTerminateHandler: terminate_handler) -> terminate_handler;
}
extern "C" {
    pub fn _get_terminate() -> terminate_handler;
}
pub type unexpected_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn unexpected() -> !;
}
extern "C" {
    pub fn set_unexpected(_NewUnexpectedHandler: unexpected_handler) -> unexpected_handler;
}
extern "C" {
    pub fn _get_unexpected() -> unexpected_handler;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
    _unused: [u8; 0],
}
pub type _se_translator_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_uint, arg2: *mut _EXCEPTION_POINTERS),
>;
extern "C" {
    pub fn _set_se_translator(_NewSETranslator: _se_translator_function)
        -> _se_translator_function;
}
extern "C" {
    pub fn _is_exception_typeof(
        _Type: *const type_info,
        _ExceptionPtr: *mut _EXCEPTION_POINTERS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uncaught_exception() -> bool;
}
extern "C" {
    pub fn __uncaught_exceptions() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __std_exception_data {
    pub _What: *const ::std::os::raw::c_char,
    pub _DoFree: bool,
}
impl Default for __std_exception_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __std_exception_copy(_From: *const __std_exception_data, _To: *mut __std_exception_data);
}
extern "C" {
    pub fn __std_exception_destroy(_Data: *mut __std_exception_data);
}
extern "C" {
    pub fn __ExceptionPtrCreate(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __ExceptionPtrDestroy(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __ExceptionPtrCopy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __ExceptionPtrAssign(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __ExceptionPtrCompare(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn __ExceptionPtrToBool(arg1: *const ::std::os::raw::c_void) -> bool;
}
extern "C" {
    pub fn __ExceptionPtrSwap(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __ExceptionPtrCurrentException(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __ExceptionPtrRethrow(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn __ExceptionPtrCopyException(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __std_reverse_trivially_swappable_1(
        _First: *mut ::std::os::raw::c_void,
        _Last: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __std_reverse_trivially_swappable_2(
        _First: *mut ::std::os::raw::c_void,
        _Last: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __std_reverse_trivially_swappable_4(
        _First: *mut ::std::os::raw::c_void,
        _Last: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __std_reverse_trivially_swappable_8(
        _First: *mut ::std::os::raw::c_void,
        _Last: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __std_swap_ranges_trivially_swappable_noalias(
        _First1: *mut ::std::os::raw::c_void,
        _Last1: *mut ::std::os::raw::c_void,
        _First2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __std_count_trivial_1(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Val: u8,
    ) -> usize;
}
extern "C" {
    pub fn __std_count_trivial_2(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Val: u16,
    ) -> usize;
}
extern "C" {
    pub fn __std_count_trivial_4(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Val: u32,
    ) -> usize;
}
extern "C" {
    pub fn __std_count_trivial_8(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Val: u64,
    ) -> usize;
}
extern "C" {
    pub fn __std_find_trivial_1(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Val: u8,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_find_trivial_2(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Val: u16,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_find_trivial_4(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Val: u32,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_find_trivial_8(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Val: u64,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_min_element_1(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Signed: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_min_element_2(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Signed: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_min_element_4(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Signed: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_min_element_8(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Signed: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_min_element_f(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Unused: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_min_element_d(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Unused: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_max_element_1(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Signed: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_max_element_2(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Signed: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_max_element_4(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Signed: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_max_element_8(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Signed: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_max_element_f(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Unused: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_max_element_d(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
        _Unused: bool,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn __std_min_1i(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> i8;
}
extern "C" {
    pub fn __std_min_1u(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> u8;
}
extern "C" {
    pub fn __std_min_2i(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> i16;
}
extern "C" {
    pub fn __std_min_2u(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> u16;
}
extern "C" {
    pub fn __std_min_4i(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    pub fn __std_min_4u(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    pub fn __std_min_8i(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> i64;
}
extern "C" {
    pub fn __std_min_8u(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    pub fn __std_min_f(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> f32;
}
extern "C" {
    pub fn __std_min_d(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> f64;
}
extern "C" {
    pub fn __std_max_1i(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> i8;
}
extern "C" {
    pub fn __std_max_1u(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> u8;
}
extern "C" {
    pub fn __std_max_2i(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> i16;
}
extern "C" {
    pub fn __std_max_2u(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> u16;
}
extern "C" {
    pub fn __std_max_4i(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    pub fn __std_max_4u(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    pub fn __std_max_8i(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> i64;
}
extern "C" {
    pub fn __std_max_8u(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    pub fn __std_max_f(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> f32;
}
extern "C" {
    pub fn __std_max_d(
        _First: *const ::std::os::raw::c_void,
        _Last: *const ::std::os::raw::c_void,
    ) -> f64;
}
extern "C" {
    pub fn __std_mismatch_1(
        _First1: *const ::std::os::raw::c_void,
        _First2: *const ::std::os::raw::c_void,
        _Count: usize,
    ) -> usize;
}
extern "C" {
    pub fn __std_mismatch_2(
        _First1: *const ::std::os::raw::c_void,
        _First2: *const ::std::os::raw::c_void,
        _Count: usize,
    ) -> usize;
}
extern "C" {
    pub fn __std_mismatch_4(
        _First1: *const ::std::os::raw::c_void,
        _First2: *const ::std::os::raw::c_void,
        _Count: usize,
    ) -> usize;
}
extern "C" {
    pub fn __std_mismatch_8(
        _First1: *const ::std::os::raw::c_void,
        _First2: *const ::std::os::raw::c_void,
        _Count: usize,
    ) -> usize;
}
pub type _Thrd_id_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Thrd_t {
    pub _Hnd: *mut ::std::os::raw::c_void,
    pub _Id: _Thrd_id_t,
}
impl Default for _Thrd_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _Smtx_t = *mut ::std::os::raw::c_void;
pub const _Success: _Thrd_result = 0;
pub const _Nomem: _Thrd_result = 1;
pub const _Timedout: _Thrd_result = 2;
pub const _Busy: _Thrd_result = 3;
pub const _Error: _Thrd_result = 4;
pub type _Thrd_result = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Stl_critical_section {
    pub _Unused: *mut ::std::os::raw::c_void,
    pub _M_srw_lock: _Smtx_t,
}
impl Default for _Stl_critical_section {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Mtx_internal_imp_t {
    pub _Type: ::std::os::raw::c_int,
    pub __bindgen_anon_1: _Mtx_internal_imp_t__bindgen_ty_1,
    pub _Thread_id: ::std::os::raw::c_long,
    pub _Count: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Mtx_internal_imp_t__bindgen_ty_1 {
    pub _Critical_section: _Stl_critical_section,
    pub _Cs_storage: [u64; 8usize],
}
impl Default for _Mtx_internal_imp_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const _Mtx_internal_imp_t__Critical_section_size: usize = 64;
impl Default for _Mtx_internal_imp_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _Mtx_t = *mut _Mtx_internal_imp_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Stl_condition_variable {
    pub _Unused: *mut ::std::os::raw::c_void,
    pub _Win_cv: *mut ::std::os::raw::c_void,
}
impl Default for _Stl_condition_variable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Cnd_internal_imp_t {
    pub __bindgen_anon_1: _Cnd_internal_imp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Cnd_internal_imp_t__bindgen_ty_1 {
    pub _Stl_cv: _Stl_condition_variable,
    pub _Cv_storage: [u64; 9usize],
}
impl Default for _Cnd_internal_imp_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const _Cnd_internal_imp_t__Cnd_internal_imp_size: usize = 72;
impl Default for _Cnd_internal_imp_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _Cnd_t = *mut _Cnd_internal_imp_t;
extern "C" {
    pub fn _Thrd_detach(arg1: _Thrd_t) -> _Thrd_result;
}
extern "C" {
    pub fn _Thrd_join(arg1: _Thrd_t, arg2: *mut ::std::os::raw::c_int) -> _Thrd_result;
}
extern "C" {
    pub fn _Thrd_yield();
}
extern "C" {
    pub fn _Thrd_hardware_concurrency() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _Thrd_id() -> _Thrd_id_t;
}
extern "C" {
    pub fn _Thrd_sleep_for(arg1: ::std::os::raw::c_ulong);
}
pub const _Mtx_plain: _bindgen_ty_7 = 1;
pub const _Mtx_try: _bindgen_ty_7 = 2;
pub const _Mtx_timed: _bindgen_ty_7 = 4;
pub const _Mtx_recursive: _bindgen_ty_7 = 256;
pub type _bindgen_ty_7 = ::std::os::raw::c_int;
extern "C" {
    pub fn _Mtx_current_owns(arg1: _Mtx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Mtx_lock(arg1: _Mtx_t) -> _Thrd_result;
}
extern "C" {
    pub fn _Mtx_trylock(arg1: _Mtx_t) -> _Thrd_result;
}
extern "C" {
    pub fn _Mtx_unlock(arg1: _Mtx_t) -> _Thrd_result;
}
extern "C" {
    pub fn _Smtx_lock_exclusive(arg1: *mut _Smtx_t);
}
extern "C" {
    pub fn _Smtx_lock_shared(arg1: *mut _Smtx_t);
}
extern "C" {
    pub fn _Smtx_try_lock_exclusive(arg1: *mut _Smtx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Smtx_try_lock_shared(arg1: *mut _Smtx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Smtx_unlock_exclusive(arg1: *mut _Smtx_t);
}
extern "C" {
    pub fn _Smtx_unlock_shared(arg1: *mut _Smtx_t);
}
extern "C" {
    pub fn _Cnd_wait(arg1: _Cnd_t, arg2: _Mtx_t) -> _Thrd_result;
}
extern "C" {
    pub fn _Cnd_broadcast(arg1: _Cnd_t) -> _Thrd_result;
}
extern "C" {
    pub fn _Cnd_signal(arg1: _Cnd_t) -> _Thrd_result;
}
extern "C" {
    pub fn _Cnd_register_at_thread_exit(
        arg1: _Cnd_t,
        arg2: _Mtx_t,
        arg3: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _Cnd_unregister_at_thread_exit(arg1: _Mtx_t);
}
extern "C" {
    pub fn _Cnd_do_broadcast_at_thread_exit();
}
extern "C" {
    pub fn _Cnd_timedwait_for_unchecked(
        arg1: _Cnd_t,
        arg2: _Mtx_t,
        arg3: ::std::os::raw::c_uint,
    ) -> _Thrd_result;
}
pub const _Atomic_memory_order_relaxed: _bindgen_ty_8 = 0;
pub const _Atomic_memory_order_consume: _bindgen_ty_8 = 1;
pub const _Atomic_memory_order_acquire: _bindgen_ty_8 = 2;
pub const _Atomic_memory_order_release: _bindgen_ty_8 = 3;
pub const _Atomic_memory_order_acq_rel: _bindgen_ty_8 = 4;
pub const _Atomic_memory_order_seq_cst: _bindgen_ty_8 = 5;
pub type _bindgen_ty_8 = ::std::os::raw::c_int;
extern "C" {
    pub fn __std_atomic_get_mutex(_Key: *const ::std::os::raw::c_void) -> *mut _Smtx_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __type_info_node {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut __type_info_root_node: __type_info_node;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __std_type_info_data {
    pub _UndecoratedName: *const ::std::os::raw::c_char,
    pub _DecoratedName: [::std::os::raw::c_char; 1usize],
}
impl Default for __std_type_info_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __std_type_info_compare(
        _Lhs: *const __std_type_info_data,
        _Rhs: *const __std_type_info_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __std_type_info_hash(_Data: *const __std_type_info_data) -> usize;
}
extern "C" {
    pub fn __std_type_info_name(
        _Data: *mut __std_type_info_data,
        _RootNode: *mut __type_info_node,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct type_info__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct type_info {
    pub vtable_: *const type_info__bindgen_vtable,
    pub _Data: __std_type_info_data,
}
impl Default for type_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}type_info_destructor"]
    pub fn type_info_type_info_destructor(this: *mut type_info);
}
pub const _crt_argv_no_arguments: _crt_argv_mode = 0;
pub const _crt_argv_unexpanded_arguments: _crt_argv_mode = 1;
pub const _crt_argv_expanded_arguments: _crt_argv_mode = 2;
pub type _crt_argv_mode = ::std::os::raw::c_int;
pub const _crt_exit_terminate_process: _crt_exit_return_mode = 0;
pub const _crt_exit_return_to_caller: _crt_exit_return_mode = 1;
pub type _crt_exit_return_mode = ::std::os::raw::c_int;
pub const _crt_exit_full_cleanup: _crt_exit_cleanup_mode = 0;
pub const _crt_exit_quick_cleanup: _crt_exit_cleanup_mode = 1;
pub const _crt_exit_no_cleanup: _crt_exit_cleanup_mode = 2;
pub type _crt_exit_cleanup_mode = ::std::os::raw::c_int;
extern "C" {
    pub static mut __current_exit_return_mode: _crt_exit_return_mode;
}
extern "C" {
    pub fn __vcrt_initialize() -> __vcrt_bool;
}
extern "C" {
    pub fn __vcrt_uninitialize(_Terminating: __vcrt_bool) -> __vcrt_bool;
}
extern "C" {
    pub fn __vcrt_uninitialize_critical() -> __vcrt_bool;
}
extern "C" {
    pub fn __vcrt_thread_attach() -> __vcrt_bool;
}
extern "C" {
    pub fn __vcrt_thread_detach() -> __vcrt_bool;
}
extern "C" {
    pub fn __isa_available_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_startup_argv_mode() -> _crt_argv_mode;
}
extern "C" {
    pub fn _seh_filter_dll(
        _ExceptionNum: ::std::os::raw::c_ulong,
        _ExceptionPtr: *mut _EXCEPTION_POINTERS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _seh_filter_exe(
        _ExceptionNum: ::std::os::raw::c_ulong,
        _ExceptionPtr: *mut _EXCEPTION_POINTERS,
    ) -> ::std::os::raw::c_int;
}
pub const _crt_unknown_app: _crt_app_type = 0;
pub const _crt_console_app: _crt_app_type = 1;
pub const _crt_gui_app: _crt_app_type = 2;
pub type _crt_app_type = ::std::os::raw::c_int;
extern "C" {
    pub fn _query_app_type() -> _crt_app_type;
}
extern "C" {
    pub fn _set_app_type(_Type: _crt_app_type);
}
pub type _UserMathErrorFunctionPointer =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut _exception) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __setusermatherr(_UserMathErrorFunction: _UserMathErrorFunctionPointer);
}
extern "C" {
    pub fn _is_c_termination_complete() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _configure_narrow_argv(mode: _crt_argv_mode) -> errno_t;
}
extern "C" {
    pub fn _configure_wide_argv(mode: _crt_argv_mode) -> errno_t;
}
extern "C" {
    pub fn _initialize_narrow_environment() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _initialize_wide_environment() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_initial_narrow_environment() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _get_initial_wide_environment() -> *mut *mut u16;
}
extern "C" {
    pub fn _get_narrow_winmain_command_line() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _get_wide_winmain_command_line() -> *mut u16;
}
extern "C" {
    pub fn __p__acmdln() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wcmdln() -> *mut *mut u16;
}
pub type _PVFV = ::std::option::Option<unsafe extern "C" fn()>;
pub type _PIFV = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type _PVFI = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn _initterm(_First: *mut _PVFV, _Last: *mut _PVFV);
}
extern "C" {
    pub fn _initterm_e(_First: *mut _PIFV, _Last: *mut _PIFV) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _onexit_table_t {
    pub _first: *mut _PVFV,
    pub _last: *mut _PVFV,
    pub _end: *mut _PVFV,
}
impl Default for _onexit_table_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn _initialize_onexit_table(_Table: *mut _onexit_table_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _register_onexit_function(
        _Table: *mut _onexit_table_t,
        _Function: _onexit_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _execute_onexit_table(_Table: *mut _onexit_table_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _crt_atexit(_Function: _PVFV) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _crt_at_quick_exit(_Function: _PVFV) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __acrt_initialize() -> __crt_bool;
}
extern "C" {
    pub fn __acrt_uninitialize(_Terminating: __crt_bool) -> __crt_bool;
}
extern "C" {
    pub fn __acrt_uninitialize_critical(_Terminating: __crt_bool) -> __crt_bool;
}
extern "C" {
    pub fn __acrt_thread_attach() -> __crt_bool;
}
extern "C" {
    pub fn __acrt_thread_detach() -> __crt_bool;
}
extern "C" {
    pub fn _cexit();
}
extern "C" {
    pub fn _c_exit();
}
pub type _tls_callback_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn _register_thread_local_exe_atexit_callback(_Callback: _tls_callback_type);
}
pub type _beginthread_proc_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type _beginthreadex_proc_type = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
>;
extern "C" {
    pub fn _beginthread(
        _StartAddress: _beginthread_proc_type,
        _StackSize: ::std::os::raw::c_uint,
        _ArgList: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    pub fn _endthread();
}
extern "C" {
    pub fn _beginthreadex(
        _Security: *mut ::std::os::raw::c_void,
        _StackSize: ::std::os::raw::c_uint,
        _StartAddress: _beginthreadex_proc_type,
        _ArgList: *mut ::std::os::raw::c_void,
        _InitFlag: ::std::os::raw::c_uint,
        _ThrdAddr: *mut ::std::os::raw::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn _endthreadex(_ReturnCode: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _getpid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _cwait(
        _TermStat: *mut ::std::os::raw::c_int,
        _ProcHandle: isize,
        _Action: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn _execl(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _execle(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _execlp(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _execlpe(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _execv(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _execve(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
        _Environment: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _execvp(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _execvpe(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
        _Environment: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _spawnl(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _spawnle(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _spawnlp(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _spawnlpe(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn _spawnv(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _spawnve(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
        _Environment: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _spawnvp(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _spawnvpe(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
        _Environment: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn _loaddll(_FileName: *mut ::std::os::raw::c_char) -> isize;
}
extern "C" {
    pub fn _unloaddll(_Handle: isize) -> ::std::os::raw::c_int;
}
pub type _GetDllProcAddrProcType =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn _getdllprocaddr(
        _Handle: isize,
        _ProcedureName: *mut ::std::os::raw::c_char,
        _Ordinal: isize,
    ) -> _GetDllProcAddrProcType;
}
extern "C" {
    pub fn cwait(
        _TermStat: *mut ::std::os::raw::c_int,
        _ProcHandle: isize,
        _Action: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn execl(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn execle(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn execlp(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn execlpe(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn execv(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn execve(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
        _Environment: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn execvp(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn execvpe(
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
        _Environment: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn spawnl(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn spawnle(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn spawnlp(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn spawnlpe(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const ::std::os::raw::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn spawnv(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn spawnve(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
        _Environment: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn spawnvp(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn spawnvpe(
        _Mode: ::std::os::raw::c_int,
        _FileName: *const ::std::os::raw::c_char,
        _Arguments: *const *const ::std::os::raw::c_char,
        _Environment: *const *const ::std::os::raw::c_char,
    ) -> isize;
}
extern "C" {
    pub fn getpid() -> ::std::os::raw::c_int;
}
#[doc = " A typedef for version numbers returned from functions in the FidelityFX SDK.\n\n @ingroup CPUTypes"]
pub type VersionNumber = u32;
#[doc = " A typedef for a boolean value.\n\n @ingroup CPUTypes"]
pub type Boolean = bool;
#[doc = " A typedef for a unsigned 8bit integer.\n\n @ingroup CPUTypes"]
pub type UInt8 = u8;
#[doc = " A typedef for a unsigned 16bit integer.\n\n @ingroup CPUTypes"]
pub type UInt16 = u16;
#[doc = " A typedef for a unsigned 32bit integer.\n\n @ingroup CPUTypes"]
pub type UInt32 = u32;
#[doc = " A typedef for a unsigned 64bit integer.\n\n @ingroup CPUTypes"]
pub type UInt64 = u64;
#[doc = " A typedef for a signed 8bit integer.\n\n @ingroup CPUTypes"]
pub type Int8 = i8;
#[doc = " A typedef for a signed 16bit integer.\n\n @ingroup CPUTypes"]
pub type Int16 = i16;
#[doc = " A typedef for a signed 32bit integer.\n\n @ingroup CPUTypes"]
pub type Int32 = i32;
#[doc = " A typedef for a signed 64bit integer.\n\n @ingroup CPUTypes"]
pub type Int64 = i64;
#[doc = " A typedef for a floating point value.\n\n @ingroup CPUTypes"]
pub type Float32 = f32;
#[doc = " A typedef for a 2-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x2 = [f32; 2usize];
#[doc = " A typedef for a 3-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x3 = [f32; 3usize];
#[doc = " A typedef for a 4-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x4 = [f32; 4usize];
#[doc = " A typedef for a 4x4 floating point matrix.\n\n @ingroup CPUTypes"]
pub type Float32x4x4 = [f32; 16usize];
#[doc = " A typedef for a 2-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x2 = [u32; 2usize];
#[doc = " A typedef for a 3-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x3 = [u32; 3usize];
#[doc = " A typedef for a 4-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x4 = [u32; 4usize];
#[doc = " A typedef for a 2-dimensional 32bit signed integer.\n\n @ingroup CPUTypes"]
pub type Int32x2 = [i32; 2usize];
#[doc = " A typedef for a 3-dimensional 32bit signed integer.\n\n @ingroup CPUTypes"]
pub type Int32x3 = [i32; 3usize];
#[doc = " A typedef for a 4-dimensional 32bit signed integer.\n\n @ingroup CPUTypes"]
pub type Int32x4 = [i32; 4usize];
#[doc = "< Unknown format"]
pub const FFX_SURFACE_FORMAT_UNKNOWN: SurfaceFormat = 0;
#[doc = "< 32 bit per channel, 4 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R32G32B32A32_TYPELESS: SurfaceFormat = 1;
#[doc = "< 32 bit per channel, 4 channel uint format"]
pub const FFX_SURFACE_FORMAT_R32G32B32A32_UINT: SurfaceFormat = 2;
#[doc = "< 32 bit per channel, 4 channel float format"]
pub const FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT: SurfaceFormat = 3;
#[doc = "< 16 bit per channel, 4 channel float format"]
pub const FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT: SurfaceFormat = 4;
#[doc = "< 32 bit per channel, 3 channel float format"]
pub const FFX_SURFACE_FORMAT_R32G32B32_FLOAT: SurfaceFormat = 5;
#[doc = "< 32 bit per channel, 2 channel float format"]
pub const FFX_SURFACE_FORMAT_R32G32_FLOAT: SurfaceFormat = 6;
#[doc = "< 8 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R8_UINT: SurfaceFormat = 7;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R32_UINT: SurfaceFormat = 8;
#[doc = "<  8 bit per channel, 4 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_TYPELESS: SurfaceFormat = 9;
#[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_UNORM: SurfaceFormat = 10;
#[doc = "<  8 bit per channel, 4 channel signed normalized format"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_SNORM: SurfaceFormat = 11;
#[doc = "<  8 bit per channel, 4 channel srgb normalized"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_SRGB: SurfaceFormat = 12;
#[doc = "<  8 bit per channel, 4 channel typeless format"]
pub const FFX_SURFACE_FORMAT_B8G8R8A8_TYPELESS: SurfaceFormat = 13;
#[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_B8G8R8A8_UNORM: SurfaceFormat = 14;
#[doc = "<  8 bit per channel, 4 channel srgb normalized"]
pub const FFX_SURFACE_FORMAT_B8G8R8A8_SRGB: SurfaceFormat = 15;
#[doc = "< 32 bit 3 channel float format"]
pub const FFX_SURFACE_FORMAT_R11G11B10_FLOAT: SurfaceFormat = 16;
#[doc = "< 10 bit per 3 channel, 2 bit for 1 channel normalized format"]
pub const FFX_SURFACE_FORMAT_R10G10B10A2_UNORM: SurfaceFormat = 17;
#[doc = "< 16 bit per channel, 2 channel float format"]
pub const FFX_SURFACE_FORMAT_R16G16_FLOAT: SurfaceFormat = 18;
#[doc = "< 16 bit per channel, 2 channel unsigned int format"]
pub const FFX_SURFACE_FORMAT_R16G16_UINT: SurfaceFormat = 19;
#[doc = "< 16 bit per channel, 2 channel signed int format"]
pub const FFX_SURFACE_FORMAT_R16G16_SINT: SurfaceFormat = 20;
#[doc = "< 16 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R16_FLOAT: SurfaceFormat = 21;
#[doc = "< 16 bit per channel, 1 channel unsigned int format"]
pub const FFX_SURFACE_FORMAT_R16_UINT: SurfaceFormat = 22;
#[doc = "< 16 bit per channel, 1 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R16_UNORM: SurfaceFormat = 23;
#[doc = "< 16 bit per channel, 1 channel signed normalized format"]
pub const FFX_SURFACE_FORMAT_R16_SNORM: SurfaceFormat = 24;
#[doc = "<  8 bit per channel, 1 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8_UNORM: SurfaceFormat = 25;
#[doc = "<  8 bit per channel, 2 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8G8_UNORM: SurfaceFormat = 26;
#[doc = "<  8 bit per channel, 2 channel unsigned integer format"]
pub const FFX_SURFACE_FORMAT_R8G8_UINT: SurfaceFormat = 27;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R32_FLOAT: SurfaceFormat = 28;
#[doc = "<  9 bit per channel, 5 bit exponent format"]
pub const FFX_SURFACE_FORMAT_R9G9B9E5_SHAREDEXP: SurfaceFormat = 29;
#[doc = "< 16 bit per channel, 4 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R16G16B16A16_TYPELESS: SurfaceFormat = 30;
#[doc = "< 32 bit per channel, 2 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R32G32_TYPELESS: SurfaceFormat = 31;
#[doc = "< 10 bit per 3 channel, 2 bit for 1 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R10G10B10A2_TYPELESS: SurfaceFormat = 32;
#[doc = "< 16 bit per channel, 2 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R16G16_TYPELESS: SurfaceFormat = 33;
#[doc = "< 16 bit per channel, 1 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R16_TYPELESS: SurfaceFormat = 34;
#[doc = "<  8 bit per channel, 1 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R8_TYPELESS: SurfaceFormat = 35;
#[doc = "<  8 bit per channel, 2 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R8G8_TYPELESS: SurfaceFormat = 36;
#[doc = "< 32 bit per channel, 1 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R32_TYPELESS: SurfaceFormat = 37;
#[doc = " An enumeration of surface formats. Needs to match enum FfxApiSurfaceFormat\n\n @ingroup SDKTypes"]
pub type SurfaceFormat = ::std::os::raw::c_int;
pub const FFX_INDEX_TYPE_UINT32: IndexFormat = 0;
pub const FFX_INDEX_TYPE_UINT16: IndexFormat = 1;
pub type IndexFormat = ::std::os::raw::c_int;
impl ResourceUsage {
    #[doc = "< No usage flags indicate a resource is read only."]
    pub const FFX_RESOURCE_USAGE_READ_ONLY: ResourceUsage = ResourceUsage(0);
}
impl ResourceUsage {
    #[doc = "< Indicates a resource will be used as render target."]
    pub const FFX_RESOURCE_USAGE_RENDERTARGET: ResourceUsage = ResourceUsage(1);
}
impl ResourceUsage {
    #[doc = "< Indicates a resource will be used as UAV."]
    pub const FFX_RESOURCE_USAGE_UAV: ResourceUsage = ResourceUsage(2);
}
impl ResourceUsage {
    #[doc = "< Indicates a resource will be used as depth target."]
    pub const FFX_RESOURCE_USAGE_DEPTHTARGET: ResourceUsage = ResourceUsage(4);
}
impl ResourceUsage {
    #[doc = "< Indicates a resource will be used as indirect argument buffer"]
    pub const FFX_RESOURCE_USAGE_INDIRECT: ResourceUsage = ResourceUsage(8);
}
impl ResourceUsage {
    #[doc = "< Indicates a resource that will generate array views. Works on 2D and cubemap textures"]
    pub const FFX_RESOURCE_USAGE_ARRAYVIEW: ResourceUsage = ResourceUsage(16);
}
impl ResourceUsage {
    #[doc = "< Indicates a resource will be used as stencil target."]
    pub const FFX_RESOURCE_USAGE_STENCILTARGET: ResourceUsage = ResourceUsage(32);
}
impl ResourceUsage {
    #[doc = "< Indicates a resource that should specify optimal render target memory access flags (for console use)"]
    pub const FFX_RESOURCE_USAGE_DCC_RENDERTARGET: ResourceUsage = ResourceUsage(32768);
}
impl ::std::ops::BitOr<ResourceUsage> for ResourceUsage {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceUsage(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceUsage {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceUsage) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceUsage> for ResourceUsage {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceUsage(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceUsage {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceUsage) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of resource usage.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceUsage(pub ::std::os::raw::c_int);
impl ResourceStates {
    pub const COMMON: ResourceStates = ResourceStates(1);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be used as UAV."]
    pub const UNORDERED_ACCESS: ResourceStates = ResourceStates(2);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be read by compute shaders."]
    pub const COMPUTE_READ: ResourceStates = ResourceStates(4);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be read by pixel shaders."]
    pub const PIXEL_READ: ResourceStates = ResourceStates(8);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be read by pixel or compute shaders."]
    pub const PIXEL_COMPUTE_READ: ResourceStates = ResourceStates(12);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be used as source in a copy command."]
    pub const COPY_SRC: ResourceStates = ResourceStates(16);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be used as destination in a copy command."]
    pub const COPY_DEST: ResourceStates = ResourceStates(32);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in generic (slow) read state."]
    pub const GENERIC_READ: ResourceStates = ResourceStates(20);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be used as an indirect command argument"]
    pub const INDIRECT_ARGUMENT: ResourceStates = ResourceStates(64);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be used to present to the swap chain"]
    pub const PRESENT: ResourceStates = ResourceStates(128);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be used as render target"]
    pub const RENDER_TARGET: ResourceStates = ResourceStates(256);
}
impl ResourceStates {
    #[doc = "< Indicates a resource is in the state to be used as depth attachment"]
    pub const DEPTH_ATTACHEMENT: ResourceStates = ResourceStates(512);
}
impl ::std::ops::BitOr<ResourceStates> for ResourceStates {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceStates(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceStates {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceStates) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceStates> for ResourceStates {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceStates(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceStates {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceStates) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of resource states.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceStates(pub ::std::os::raw::c_int);
#[doc = "< A resource with a single dimension."]
pub const FFX_RESOURCE_DIMENSION_TEXTURE_1D: ResourceDimension = 0;
#[doc = "< A resource with two dimensions."]
pub const FFX_RESOURCE_DIMENSION_TEXTURE_2D: ResourceDimension = 1;
#[doc = " An enumeration of surface dimensions.\n\n @ingroup SDKTypes"]
pub type ResourceDimension = ::std::os::raw::c_int;
#[doc = "< A resource view on a buffer."]
pub const FFX_RESOURCE_VIEW_DIMENSION_BUFFER: ResourceViewDimension = 0;
#[doc = "< A resource view on a single dimension."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_1D: ResourceViewDimension = 1;
#[doc = "< A resource view on a single dimensional array."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_1D_ARRAY: ResourceViewDimension = 2;
#[doc = "< A resource view on two dimensions."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_2D: ResourceViewDimension = 3;
#[doc = "< A resource view on two dimensional array."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_2D_ARRAY: ResourceViewDimension = 4;
#[doc = "< A resource view on three dimensions."]
pub const FFX_RESOURCE_VIEW_DIMENSION_TEXTURE_3D: ResourceViewDimension = 5;
#[doc = " An enumeration of resource view dimensions.\n\n @ingroup SDKTypes"]
pub type ResourceViewDimension = ::std::os::raw::c_int;
impl ResourceFlags {
    #[doc = "< No flags."]
    pub const FFX_RESOURCE_FLAGS_NONE: ResourceFlags = ResourceFlags(0);
}
impl ResourceFlags {
    #[doc = "< A bit indicating a resource does not need to persist across frames."]
    pub const FFX_RESOURCE_FLAGS_ALIASABLE: ResourceFlags = ResourceFlags(1);
}
impl ResourceFlags {
    #[doc = "< Special case flag used internally when importing resources that require additional setup"]
    pub const FFX_RESOURCE_FLAGS_UNDEFINED: ResourceFlags = ResourceFlags(2);
}
impl ::std::ops::BitOr<ResourceFlags> for ResourceFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceFlags> for ResourceFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of surface dimensions.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceFlags(pub ::std::os::raw::c_int);
#[doc = "< The resource view is an unordered access view (UAV)."]
pub const FFX_RESOURCE_VIEW_UNORDERED_ACCESS: ResourceViewType = 0;
#[doc = "< The resource view is a shader resource view (SRV)."]
pub const FFX_RESOURCE_VIEW_SHADER_READ: ResourceViewType = 1;
#[doc = " An enumeration of all resource view types.\n\n @ingroup SDKTypes"]
pub type ResourceViewType = ::std::os::raw::c_int;
#[doc = "< Point sampling."]
pub const FFX_FILTER_TYPE_MINMAGMIP_POINT: FilterType = 0;
#[doc = "< Sampling with interpolation."]
pub const FFX_FILTER_TYPE_MINMAGMIP_LINEAR: FilterType = 1;
#[doc = "< Use linear interpolation for minification and magnification; use point sampling for mip-level sampling."]
pub const FFX_FILTER_TYPE_MINMAGLINEARMIP_POINT: FilterType = 2;
#[doc = " The type of filtering to perform when reading a texture.\n\n @ingroup SDKTypes"]
pub type FilterType = ::std::os::raw::c_int;
#[doc = "< Wrap when reading texture."]
pub const FFX_ADDRESS_MODE_WRAP: AddressMode = 0;
#[doc = "< Mirror when reading texture."]
pub const FFX_ADDRESS_MODE_MIRROR: AddressMode = 1;
#[doc = "< Clamp when reading texture."]
pub const FFX_ADDRESS_MODE_CLAMP: AddressMode = 2;
#[doc = "< Border color when reading texture."]
pub const FFX_ADDRESS_MODE_BORDER: AddressMode = 3;
#[doc = "< Mirror once when reading texture."]
pub const FFX_ADDRESS_MODE_MIRROR_ONCE: AddressMode = 4;
#[doc = " The address mode used when reading a texture.\n\n @ingroup SDKTypes"]
pub type AddressMode = ::std::os::raw::c_int;
#[doc = "< Shader model 5.1."]
pub const FFX_SHADER_MODEL_5_1: ShaderModel = 0;
#[doc = "< Shader model 6.0."]
pub const FFX_SHADER_MODEL_6_0: ShaderModel = 1;
#[doc = "< Shader model 6.1."]
pub const FFX_SHADER_MODEL_6_1: ShaderModel = 2;
#[doc = "< Shader model 6.2."]
pub const FFX_SHADER_MODEL_6_2: ShaderModel = 3;
#[doc = "< Shader model 6.3."]
pub const FFX_SHADER_MODEL_6_3: ShaderModel = 4;
#[doc = "< Shader model 6.4."]
pub const FFX_SHADER_MODEL_6_4: ShaderModel = 5;
#[doc = "< Shader model 6.5."]
pub const FFX_SHADER_MODEL_6_5: ShaderModel = 6;
#[doc = "< Shader model 6.6."]
pub const FFX_SHADER_MODEL_6_6: ShaderModel = 7;
#[doc = "< Shader model 6.7."]
pub const FFX_SHADER_MODEL_6_7: ShaderModel = 8;
#[doc = " An enumeration of all supported shader models.\n\n @ingroup SDKTypes"]
pub type ShaderModel = ::std::os::raw::c_int;
#[doc = "< The resource is a buffer."]
pub const FFX_RESOURCE_TYPE_BUFFER: ResourceType = 0;
#[doc = "< The resource is a 1-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE1D: ResourceType = 1;
#[doc = "< The resource is a 2-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE2D: ResourceType = 2;
#[doc = "< The resource is a cube map."]
pub const FFX_RESOURCE_TYPE_TEXTURE_CUBE: ResourceType = 3;
#[doc = "< The resource is a 3-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE3D: ResourceType = 4;
#[doc = "\n @ingroup SDKTypes"]
pub type ResourceType = ::std::os::raw::c_int;
#[doc = "< Local memory."]
pub const FFX_HEAP_TYPE_DEFAULT: HeapType = 0;
#[doc = "< Heap used for uploading resources."]
pub const FFX_HEAP_TYPE_UPLOAD: HeapType = 1;
#[doc = "< Heap used for reading back resources."]
pub const FFX_HEAP_TYPE_READBACK: HeapType = 2;
#[doc = " An enumeration for different heap types\n\n @ingroup SDKTypes"]
pub type HeapType = ::std::os::raw::c_int;
#[doc = "< The GPU job is performing a floating-point clear."]
pub const FFX_GPU_JOB_CLEAR_FLOAT: GpuJobType = 0;
#[doc = "< The GPU job is performing a copy."]
pub const FFX_GPU_JOB_COPY: GpuJobType = 1;
#[doc = "< The GPU job is performing a compute dispatch."]
pub const FFX_GPU_JOB_COMPUTE: GpuJobType = 2;
#[doc = "< The GPU job is performing a barrier."]
pub const FFX_GPU_JOB_BARRIER: GpuJobType = 3;
#[doc = "< The GPU job is performing a floating-point clear."]
pub const FFX_GPU_JOB_DISCARD: GpuJobType = 4;
#[doc = " An enumeration for different render job types\n\n @ingroup SDKTypes"]
pub type GpuJobType = ::std::os::raw::c_int;
pub const FFX_DESCRIPTOR_TEXTURE_SRV: DescriptorType = 0;
pub const FFX_DESCRIPTOR_BUFFER_SRV: DescriptorType = 1;
pub const FFX_DESCRIPTOR_TEXTURE_UAV: DescriptorType = 2;
pub const FFX_DESCRIPTOR_BUFFER_UAV: DescriptorType = 3;
#[doc = " An enumeration for various descriptor types\n\n @ingroup SDKTypes"]
pub type DescriptorType = ::std::os::raw::c_int;
#[doc = " An enumeration for various descriptor types\n\n @ingroup SDKTypes"]
pub use self::DescriptorType as DescriptiorType;
pub const FFX_BIND_PIXEL_SHADER_STAGE: BindStage = 1;
pub const FFX_BIND_VERTEX_SHADER_STAGE: BindStage = 2;
pub const FFX_BIND_COMPUTE_SHADER_STAGE: BindStage = 4;
#[doc = " An enumeration for view binding stages\n\n @ingroup SDKTypes"]
pub type BindStage = ::std::os::raw::c_int;
pub const FFX_BARRIER_TYPE_TRANSITION: BarrierType = 0;
pub const FFX_BARRIER_TYPE_UAV: BarrierType = 1;
#[doc = " An enumeration for barrier types\n\n @ingroup SDKTypes"]
pub type BarrierType = ::std::os::raw::c_int;
pub type MessageCallback =
    ::std::option::Option<unsafe extern "C" fn(type_: u32, message: *const u16)>;
pub const FFX_MESSAGE_TYPE_ERROR: MsgType = 0;
pub const FFX_MESSAGE_TYPE_WARNING: MsgType = 1;
pub const FFX_MESSAGE_TYPE_COUNT: MsgType = 2;
#[doc = " An enumeration for message types that can be passed\n\n @ingroup SDKTypes"]
pub type MsgType = ::std::os::raw::c_int;
#[doc = "< FidelityFX Super Resolution v2"]
pub const FFX_EFFECT_FSR2: Effect = 0;
#[doc = "< FidelityFX Super Resolution"]
pub const FFX_EFFECT_FSR1: Effect = 1;
#[doc = "< FidelityFX Single Pass Downsampler"]
pub const FFX_EFFECT_SPD: Effect = 2;
#[doc = "< FidelityFX Blur"]
pub const FFX_EFFECT_BLUR: Effect = 3;
#[doc = "< FidelityFX Breadcrumbs"]
pub const FFX_EFFECT_BREADCRUMBS: Effect = 4;
#[doc = "< FidelityFX Brixelizer"]
pub const FFX_EFFECT_BRIXELIZER: Effect = 5;
#[doc = "< FidelityFX Brixelizer GI"]
pub const FFX_EFFECT_BRIXELIZER_GI: Effect = 6;
#[doc = "< FidelityFX Combined Adaptive Compute Ambient Occlusion"]
pub const FFX_EFFECT_CACAO: Effect = 7;
#[doc = "< FidelityFX Contrast Adaptive Sharpening"]
pub const FFX_EFFECT_CAS: Effect = 8;
#[doc = "< FidelityFX Denoiser"]
pub const FFX_EFFECT_DENOISER: Effect = 9;
#[doc = "< FidelityFX Lens"]
pub const FFX_EFFECT_LENS: Effect = 10;
#[doc = "< FidelityFX Parallel Sort"]
pub const FFX_EFFECT_PARALLEL_SORT: Effect = 11;
#[doc = "< FidelityFX Stochastic Screen Space Reflections"]
pub const FFX_EFFECT_SSSR: Effect = 12;
#[doc = "< FidelityFX Variable Shading"]
pub const FFX_EFFECT_VARIABLE_SHADING: Effect = 13;
#[doc = "< FidelityFX Luma Preserving Mapper"]
pub const FFX_EFFECT_LPM: Effect = 14;
#[doc = "< FidelityFX Depth of Field"]
pub const FFX_EFFECT_DOF: Effect = 15;
#[doc = "< FidelityFX Classifier"]
pub const FFX_EFFECT_CLASSIFIER: Effect = 16;
#[doc = "< FidelityFX Super Resolution v3"]
pub const FFX_EFFECT_FSR3UPSCALER: Effect = 17;
#[doc = "< FidelityFX Frame Interpolation, part of FidelityFX Super Resolution v3"]
pub const FFX_EFFECT_FRAMEINTERPOLATION: Effect = 18;
#[doc = "< FidelityFX Optical Flow, part of FidelityFX Super Resolution v3"]
pub const FFX_EFFECT_OPTICALFLOW: Effect = 19;
#[doc = "< FidelityFX Shared resources effect ID"]
pub const FFX_EFFECT_SHAREDRESOURCES: Effect = 127;
#[doc = "< FidelityFX Shared backend context used with DLL API"]
pub const FFX_EFFECT_SHAREDAPIBACKEND: Effect = 128;
#[doc = " An enumeration of all the effects which constitute the FidelityFX SDK.\n\n Dictates what effect shader blobs to fetch for pipeline creation\n\n @ingroup SDKTypes"]
pub type Effect = ::std::os::raw::c_int;
pub const FFX_BACKBUFFER_TRANSFER_FUNCTION_SRGB: BackbufferTransferFunction = 0;
pub const FFX_BACKBUFFER_TRANSFER_FUNCTION_PQ: BackbufferTransferFunction = 1;
pub const FFX_BACKBUFFER_TRANSFER_FUNCTION_SCRGB: BackbufferTransferFunction = 2;
pub type BackbufferTransferFunction = ::std::os::raw::c_int;
#[doc = " A typedef representing the graphics device.\n\n @ingroup SDKTypes"]
pub type Device = *mut ::std::os::raw::c_void;
pub type CommandQueue = *mut ::std::os::raw::c_void;
pub type Swapchain = *mut ::std::os::raw::c_void;
#[doc = " A typedef representing a command list or command buffer.\n\n @ingroup SDKTypes"]
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct CommandList(pub *mut ::std::os::raw::c_void);
#[doc = " A typedef for a root signature.\n\n @ingroup SDKTypes"]
pub type RootSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a command signature, used for indirect workloads\n\n @ingroup SDKTypes"]
pub type CommandSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a pipeline state object.\n\n @ingroup SDKTypes"]
pub type Pipeline = *mut ::std::os::raw::c_void;
#[doc = " Allocate block of memory.\n\n The callback function for requesting memory of provided size.\n <c><i>size</i></c> cannot be 0.\n\n @param [in]  size               Size in bytes of memory to allocate.\n\n @retval\n NULL                            The operation failed.\n @retval\n Anything else                   The operation completed successfully.\n\n @ingroup SDKTypes"]
pub type AllocFunc =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
#[doc = " Reallocate block of memory.\n\n The callback function for reallocating provided block of memory to new location\n with specified size. When provided with <c><i>NULL</i></c> as <c><i>ptr</i></c>\n then it should behave as <c><i>FfxBreadcrumbsAllocFunc</i></c>.\n If the operation failed then contents of <c><i>ptr</i></c>\n cannot be changed. <c><i>size</i></c> cannot be 0.\n\n @param [in]  ptr                A pointer to previous block of memory.\n @param [in]  size               Size in bytes of memory to allocate.\n\n @retval\n NULL                            The operation failed.\n @retval\n Anything else                   The operation completed successfully.\n\n @ingroup SDKTypes"]
pub type ReallocFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Free block of memory.\n\n The callback function for freeing provided block of memory.\n <c><i>ptr</i></c> cannot be <c><i>NULL</i></c>.\n\n @param [in]  ptr                A pointer to block of memory.\n\n @ingroup SDKTypes"]
pub type FreeFunc = ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
#[doc = " A structure encapsulating a set of allocation callbacks.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AllocationCallbacks {
    #[doc = "< Callback for allocating memory in the library."]
    pub fpAlloc: AllocFunc,
    #[doc = "< Callback for reallocating memory in the library."]
    pub fpRealloc: ReallocFunc,
    #[doc = "< Callback for freeing allocated memory in the library."]
    pub fpFree: FreeFunc,
}
#[doc = " A structure encapsulating the bindless descriptor configuration of an effect.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EffectBindlessConfig {
    #[doc = "< Maximum number of texture SRVs needed in the bindless table."]
    pub maxTextureSrvs: u32,
    #[doc = "< Maximum number of buffer SRVs needed in the bindless table."]
    pub maxBufferSrvs: u32,
    #[doc = "< Maximum number of texture UAVs needed in the bindless table."]
    pub maxTextureUavs: u32,
    #[doc = "< Maximum number of buffer UAVs needed in the bindless table."]
    pub maxBufferUavs: u32,
}
#[doc = " A structure encapsulating a collection of device capabilities.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceCapabilities {
    #[doc = "< The maximum shader model supported by the device."]
    pub maximumSupportedShaderModel: ShaderModel,
    #[doc = "< The minimum supported wavefront width."]
    pub waveLaneCountMin: u32,
    #[doc = "< The maximum supported wavefront width."]
    pub waveLaneCountMax: u32,
    #[doc = "< The device supports FP16 in hardware."]
    pub fp16Supported: bool,
    #[doc = "< The device supports ray tracing."]
    pub raytracingSupported: bool,
    #[doc = "< The device supports AMD coherent memory."]
    pub deviceCoherentMemorySupported: bool,
    #[doc = "< The device supports dedicated allocations for resources."]
    pub dedicatedAllocationSupported: bool,
    #[doc = "< The device supports AMD buffer markers."]
    pub bufferMarkerSupported: bool,
    #[doc = "< The device supports extended synchronization mechanism."]
    pub extendedSynchronizationSupported: bool,
    #[doc = "< The device supports shader storage buffer array non uniform indexing."]
    pub shaderStorageBufferArrayNonUniformIndexing: bool,
}
impl Default for DeviceCapabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a 2-dimensional point, using 32bit unsigned integers.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Dimensions2D {
    #[doc = "< The width of a 2-dimensional range."]
    pub width: u32,
    #[doc = "< The height of a 2-dimensional range."]
    pub height: u32,
}
#[doc = " A structure encapsulating a 2-dimensional point.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: i32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: i32,
}
#[doc = " A structure encapsulating a 2-dimensional rect.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Rect2D {
    #[doc = "< Left most coordinate"]
    pub left: i32,
    #[doc = "< Top most coordinate"]
    pub top: i32,
    #[doc = "< Rect width"]
    pub width: i32,
    #[doc = "< Rect height"]
    pub height: i32,
}
#[doc = " A structure encapsulating a 2-dimensional set of floating point coordinates.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FloatCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: f32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: f32,
}
#[doc = " A structure describing a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResourceDescription {
    #[doc = "< The type of the resource."]
    pub type_: ResourceType,
    #[doc = "< The surface format."]
    pub format: SurfaceFormat,
    pub __bindgen_anon_1: ResourceDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ResourceDescription__bindgen_ty_2,
    pub __bindgen_anon_3: ResourceDescription__bindgen_ty_3,
    #[doc = "< Number of mips (or 0 for full mipchain)."]
    pub mipCount: u32,
    #[doc = "< A set of <c><i>FfxResourceFlags</i></c> flags."]
    pub flags: ResourceFlags,
    #[doc = "< Resource usage flags."]
    pub usage: ResourceUsage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_1 {
    #[doc = "< The width of the texture resource."]
    pub width: u32,
    #[doc = "< The size of the buffer resource."]
    pub size: u32,
}
impl Default for ResourceDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_2 {
    #[doc = "< The height of the texture resource."]
    pub height: u32,
    #[doc = "< The stride of the buffer resource."]
    pub stride: u32,
}
impl Default for ResourceDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_3 {
    #[doc = "< The depth of the texture resource."]
    pub depth: u32,
    #[doc = "< The alignment of the buffer resource."]
    pub alignment: u32,
}
impl Default for ResourceDescription__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An outward facing structure containing a resource\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Resource {
    #[doc = "< pointer to the resource."]
    pub resource: *mut ::std::os::raw::c_void,
    pub description: ResourceDescription,
    pub state: ResourceStates,
    #[doc = "< (optional) Resource name."]
    pub name: [u16; 64usize],
}
impl Default for Resource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a static resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StaticResourceDescription {
    #[doc = "< The resource to register."]
    pub resource: *const Resource,
    #[doc = "< The type of descriptor to create."]
    pub descriptorType: DescriptorType,
    #[doc = "< The destination index of the descriptor within the static table."]
    pub descriptorIndex: u32,
    pub __bindgen_anon_1: StaticResourceDescription__bindgen_ty_1,
    #[doc = "< The buffer size in bytes."]
    pub bufferSize: u32,
    #[doc = "< The buffer stride in bytes."]
    pub bufferStride: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union StaticResourceDescription__bindgen_ty_1 {
    #[doc = "< The buffer offset in bytes."]
    pub bufferOffset: u32,
    #[doc = "< The mip of the texture resource to create a UAV for."]
    pub textureUavMip: u32,
}
impl Default for StaticResourceDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for StaticResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a constant buffer allocation.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConstantAllocation {
    #[doc = "< The resource representing the constant buffer resource."]
    pub resource: Resource,
    #[doc = "< The binding handle for the constant buffer"]
    pub handle: UInt64,
}
impl Default for ConstantAllocation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a constant buffer allocation.\n\n @ingroup SDKTypes"]
pub type RootConstantAllocation = ConstantAllocation;
#[doc = " A function definition for a constant buffer allocation callback\n\n Used to provide a constant buffer allocator to the calling backend\n\n @param [in] data                       The constant buffer data.\n @param [in] dataSize                   The size of the constant buffer data.\n\n\n @ingroup SDKTypes"]
pub type ConstantBufferAllocator = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, dataSize: UInt64) -> ConstantAllocation,
>;
#[doc = " Information about single AMD FidelityFX Breadcrumbs Library GPU memory block.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BreadcrumbsBlockData {
    #[doc = "< Pointer to CPU mapped GPU buffer memory."]
    pub memory: *mut ::std::os::raw::c_void,
    #[doc = "< GPU memory block handle."]
    pub heap: *mut ::std::os::raw::c_void,
    #[doc = "< GPU buffer handle for memory block."]
    pub buffer: *mut ::std::os::raw::c_void,
    #[doc = "< GPU address of memory block."]
    pub baseAddress: u64,
    #[doc = "< Index of next marker to be saved in memory block."]
    pub nextMarker: u32,
}
impl Default for BreadcrumbsBlockData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An internal structure containing a handle to a resource and resource views\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResourceInternal {
    #[doc = "< The index of the resource."]
    pub internalIndex: i32,
}
pub const FFX_RESOURCE_INIT_DATA_TYPE_INVALID: ResourceInitDataType = 0;
pub const FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED: ResourceInitDataType = 1;
pub const FFX_RESOURCE_INIT_DATA_TYPE_BUFFER: ResourceInitDataType = 2;
pub const FFX_RESOURCE_INIT_DATA_TYPE_VALUE: ResourceInitDataType = 3;
#[doc = " An enumeration for resource init data types that can be passed\n\n @ingroup SDKTypes"]
pub type ResourceInitDataType = ::std::os::raw::c_int;
#[doc = " An structure housing all that is needed for resource initialization\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResourceInitData {
    #[doc = "< Indicates that the resource will be initialized from a buffer or a value, or stay uninitialized."]
    pub type_: ResourceInitDataType,
    #[doc = "< The size, in bytes, of the resource that needed be initialized."]
    pub size: usize,
    pub __bindgen_anon_1: ResourceInitData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceInitData__bindgen_ty_1 {
    #[doc = "< The buffer used to initialize the resource."]
    pub buffer: *mut ::std::os::raw::c_void,
    #[doc = "< Indicates that the resource will be filled up with this value."]
    pub value: ::std::os::raw::c_uchar,
}
impl Default for ResourceInitData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ResourceInitData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An internal structure housing all that is needed for backend resource descriptions\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternalResourceDescription {
    #[doc = "< Resource identifier"]
    pub id: u32,
    #[doc = "< Name to set to the resource for easier debugging"]
    pub name: *const u16,
    #[doc = "< The type of resource (see <c><i>FfxResourceType</i></c>)"]
    pub type_: ResourceType,
    #[doc = "< Resource usage flags (see <c><i>FfxResourceUsage</i></c>)"]
    pub usage: ResourceUsage,
    #[doc = "< The resource format to use"]
    pub format: SurfaceFormat,
    #[doc = "< The width (textures) or size (buffers) of the resource"]
    pub width: u32,
    #[doc = "< The height (textures) or stride (buffers) of the resource"]
    pub height: u32,
    #[doc = "< Mip count (textures) of the resource"]
    pub mipCount: u32,
    #[doc = "< Resource flags (see <c><i>FfxResourceFlags</i></c>)"]
    pub flags: ResourceFlags,
    #[doc = "< Resource initialization definition (see <c><i>FfxResourceInitData</i></c>)"]
    pub initData: ResourceInitData,
}
impl Default for InternalResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure defining the view to create\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ViewDescription {
    #[doc = "< Indicates that the view is a UAV."]
    pub uavView: bool,
    #[doc = "< The view dimension to map"]
    pub viewDimension: ResourceViewDimension,
    pub __bindgen_anon_1: ViewDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ViewDescription__bindgen_ty_2,
    #[doc = "< The first slice to map to, (-1) for default first slice"]
    pub firstSlice: i32,
    pub name: [u16; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ViewDescription__bindgen_ty_1 {
    #[doc = "< The mip level of the view, (-1) for default"]
    pub mipLevel: i32,
    #[doc = "< The first element of a buffer view, (-1) for default"]
    pub firstElement: i32,
}
impl Default for ViewDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ViewDescription__bindgen_ty_2 {
    #[doc = "< The array size of the view, (-1) for full depth/array size"]
    pub arraySize: i32,
    #[doc = "< The number of elements in a buffer view, (-1) for full depth/array size"]
    pub elementCount: i32,
}
impl Default for ViewDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ViewDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}s_FfxViewDescInit"]
    pub static mut s_ViewDescInit: ViewDescription;
}
#[doc = " A structure defining a resource bind point\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceBinding {
    #[doc = "< The slot into which to bind the resource"]
    pub slotIndex: u32,
    #[doc = "< The resource offset for mip/array access"]
    pub arrayIndex: u32,
    #[doc = "< A unique resource identifier representing an internal resource index"]
    pub resourceIdentifier: u32,
    #[doc = "< A debug name to help track the resource binding"]
    pub name: [u16; 64usize],
}
impl Default for ResourceBinding {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a single pass of an algorithm.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineState {
    #[doc = "< The pipelines rootSignature"]
    pub rootSignature: RootSignature,
    #[doc = "< The id of the effect pass this pipeline corresponds to"]
    pub passId: u32,
    #[doc = "< The command signature used for indirect workloads"]
    pub cmdSignature: CommandSignature,
    #[doc = "< The pipeline object"]
    pub pipeline: Pipeline,
    #[doc = "< Count of Texture UAVs used in this pipeline"]
    pub uavTextureCount: u32,
    #[doc = "< Count of Texture SRVs used in this pipeline"]
    pub srvTextureCount: u32,
    #[doc = "< Count of Buffer SRV used in this pipeline"]
    pub srvBufferCount: u32,
    #[doc = "< Count of Buffer UAVs used in this pipeline"]
    pub uavBufferCount: u32,
    #[doc = "< Count of static Texture SRVs used in this pipeline"]
    pub staticTextureSrvCount: u32,
    #[doc = "< Count of static Buffer SRVs used in this pipeline"]
    pub staticBufferSrvCount: u32,
    #[doc = "< Count of static Texture UAVs used in this pipeline"]
    pub staticTextureUavCount: u32,
    #[doc = "< Count of static Buffer UAVs used in this pipeline"]
    pub staticBufferUavCount: u32,
    #[doc = "< Count of constant buffers used in this pipeline"]
    pub constCount: u32,
    #[doc = "< Array of ResourceIdentifiers bound as texture UAVs"]
    pub uavTextureBindings: [ResourceBinding; 64usize],
    #[doc = "< Array of ResourceIdentifiers bound as texture SRVs"]
    pub srvTextureBindings: [ResourceBinding; 64usize],
    #[doc = "< Array of ResourceIdentifiers bound as buffer SRVs"]
    pub srvBufferBindings: [ResourceBinding; 64usize],
    #[doc = "< Array of ResourceIdentifiers bound as buffer UAVs"]
    pub uavBufferBindings: [ResourceBinding; 64usize],
    #[doc = "< Array of ResourceIdentifiers bound as CBs"]
    pub constantBufferBindings: [ResourceBinding; 3usize],
    #[doc = "< Pipeline name for debugging/profiling purposes"]
    pub name: [u16; 64usize],
}
impl Default for PipelineState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateResourceDescription {
    #[doc = "< The heap type to hold the resource, typically <c><i>FFX_HEAP_TYPE_DEFAULT</i></c>."]
    pub heapType: HeapType,
    #[doc = "< A resource description."]
    pub resourceDescription: ResourceDescription,
    #[doc = "< The initial resource state."]
    pub initialState: ResourceStates,
    #[doc = "< Name of the resource."]
    pub name: *const u16,
    #[doc = "< Internal resource ID."]
    pub id: u32,
    #[doc = "< A struct used to initialize the resource."]
    pub initData: ResourceInitData,
}
impl Default for CreateResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create sampler mappings\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerDescription {
    pub filter: FilterType,
    pub addressModeU: AddressMode,
    pub addressModeV: AddressMode,
    pub addressModeW: AddressMode,
    pub stage: BindStage,
}
impl Default for SamplerDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create root constant buffer mappings\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootConstantDescription {
    pub size: u32,
    pub stage: BindStage,
}
impl Default for RootConstantDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the description used to create a\n <c><i>FfxPipeline</i></c> structure.\n\n A pipeline is the name given to a shader and the collection of state that\n is required to dispatch it. In the context of the FidelityFX SDK and its architecture\n this means that a <c><i>FfxPipelineDescription</i></c> will map to either a\n monolithic object in an explicit API (such as a\n <c><i>PipelineStateObject</i></c> in DirectX 12). Or a shader and some\n ancillary API objects (in something like DirectX 11).\n\n The <c><i>contextFlags</i></c> field contains a copy of the flags passed\n to <c><i>ffxContextCreate</i></c> via the <c><i>flags</i></c> field of\n the <c><i>Ffx<Effect>InitializationParams</i></c> structure. These flags are\n used to determine which permutation of a pipeline for a specific\n <c><i>Ffx<Effect>Pass</i></c> should be used to implement the features required\n by each application, as well as to achieve the best performance on specific\n target hardware configurations.\n\n When using one of the provided backends for FidelityFX SDK (such as DirectX 12 or\n Vulkan) the data required to create a pipeline is compiled off line and\n included into the backend library that you are using. For cases where the\n backend interface is overridden by providing custom callback function\n implementations care should be taken to respect the contents of the\n <c><i>contextFlags</i></c> field in order to correctly support the options\n provided by the FidelityFX SDK, and achieve best performance.\n ///\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDescription {
    #[doc = "< A collection of <c><i>FfxInitializationFlagBits</i></c> which were passed to the context."]
    pub contextFlags: u32,
    #[doc = "< A collection of samplers to use when building the root signature for the pipeline"]
    pub samplers: *const SamplerDescription,
    #[doc = "< Number of samplers to create for the pipeline"]
    pub samplerCount: usize,
    #[doc = "< A collection of root constant descriptions to use when building the root signature for the pipeline"]
    pub rootConstants: *const RootConstantDescription,
    #[doc = "< Number of root constant buffers to create for the pipeline"]
    pub rootConstantBufferCount: u32,
    #[doc = "< Pipeline name with which to name the pipeline object"]
    pub name: [u16; 64usize],
    #[doc = "< The stage(s) for which this pipeline is being built"]
    pub stage: BindStage,
    #[doc = "< Whether this pipeline has an indirect workload"]
    pub indirectWorkload: u32,
    #[doc = "< For raster pipelines this contains the backbuffer format"]
    pub backbufferFormat: SurfaceFormat,
}
impl Default for PipelineDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a barrier\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BarrierDescription {
    #[doc = "< The resource representation"]
    pub resource: ResourceInternal,
    #[doc = "< The type of barrier to execute"]
    pub barrierType: BarrierType,
    #[doc = "< The initial state of the resource"]
    pub currentState: ResourceStates,
    #[doc = "< The new state of the resource after barrier"]
    pub newState: ResourceStates,
    #[doc = "< The subresource id to apply barrier operation to"]
    pub subResourceID: u32,
}
impl Default for BarrierDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing a constant buffer.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstantBuffer {
    #[doc = "< The size (expressed in 32-bit chunks) stored in data."]
    pub num32BitEntries: u32,
    #[doc = "< Pointer to constant buffer data"]
    pub data: *mut u32,
}
impl Default for ConstantBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing a shader resource view."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TextureSRV {
    #[doc = "< Resource corresponding to the shader resource view."]
    pub resource: ResourceInternal,
}
#[doc = " A structure containing a shader resource view."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BufferSRV {
    #[doc = "< Offset of resource to bind in bytes."]
    pub offset: u32,
    #[doc = "< Size of resource to bind in bytes."]
    pub size: u32,
    #[doc = "< Size of resource to bind in bytes."]
    pub stride: u32,
    #[doc = "< Resource corresponding to the shader resource view."]
    pub resource: ResourceInternal,
}
#[doc = " A structure containing a unordered access view."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TextureUAV {
    #[doc = "< Mip level of resource to bind."]
    pub mip: u32,
    #[doc = "< Resource corresponding to the unordered access view."]
    pub resource: ResourceInternal,
}
#[doc = " A structure containing a unordered access view."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BufferUAV {
    #[doc = "< Offset of resource to bind in bytes."]
    pub offset: u32,
    #[doc = "< Size of resource to bind in bytes."]
    pub size: u32,
    #[doc = "< Size of resource to bind in bytes."]
    pub stride: u32,
    #[doc = "< Resource corresponding to the unordered access view."]
    pub resource: ResourceInternal,
}
#[doc = " A structure describing a clear render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ClearFloatJobDescription {
    #[doc = "< The clear color of the resource."]
    pub color: [f32; 4usize],
    #[doc = "< The resource to be cleared."]
    pub target: ResourceInternal,
}
#[doc = " A structure describing a compute render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComputeJobDescription {
    #[doc = "< Compute pipeline for the render job."]
    pub pipeline: PipelineState,
    #[doc = "< Dispatch dimensions."]
    pub dimensions: [u32; 3usize],
    #[doc = "< Dispatch indirect cmd argument buffer"]
    pub cmdArgument: ResourceInternal,
    #[doc = "< Dispatch indirect offset within the cmd argument buffer"]
    pub cmdArgumentOffset: u32,
    #[doc = "< SRV texture resources to be bound in the compute job."]
    pub srvTextures: [TextureSRV; 64usize],
    #[doc = "< SRV buffer resources to be bound in the compute job."]
    pub srvBuffers: [BufferSRV; 64usize],
    #[doc = "< UAV texture resources to be bound in the compute job."]
    pub uavTextures: [TextureUAV; 64usize],
    #[doc = "< UAV buffer resources to be bound in the compute job."]
    pub uavBuffers: [BufferUAV; 64usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 3usize],
}
impl Default for ComputeJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RasterJobDescription {
    #[doc = "< Raster pipeline for the render job."]
    pub pipeline: PipelineState,
    pub numVertices: u32,
    pub renderTarget: ResourceInternal,
    #[doc = "< SRV texture resources to be bound in the compute job."]
    pub srvTextures: [TextureSRV; 64usize],
    #[doc = "< UAV texture resources to be bound in the compute job."]
    pub uavTextures: [TextureUAV; 64usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 3usize],
}
impl Default for RasterJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a copy render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CopyJobDescription {
    #[doc = "< Source resource for the copy."]
    pub src: ResourceInternal,
    #[doc = "< Offset into the source buffer in bytes."]
    pub srcOffset: u32,
    #[doc = "< Destination resource for the copy."]
    pub dst: ResourceInternal,
    #[doc = "< Offset into the destination buffer in bytes."]
    pub dstOffset: u32,
    #[doc = "< Number of bytes to copy (Set to 0 to copy entire buffer)."]
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DiscardJobDescription {
    #[doc = "< The resource to be discarded."]
    pub target: ResourceInternal,
}
#[doc = " A structure describing a single render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GpuJobDescription {
    #[doc = "< Type of the job."]
    pub jobType: GpuJobType,
    #[doc = "< Job label for markers"]
    pub jobLabel: [u16; 64usize],
    pub __bindgen_anon_1: GpuJobDescription__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GpuJobDescription__bindgen_ty_1 {
    #[doc = "< Clear job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_CLEAR_FLOAT</i></c>."]
    pub clearJobDescriptor: ClearFloatJobDescription,
    #[doc = "< Copy job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COPY</i></c>."]
    pub copyJobDescriptor: CopyJobDescription,
    #[doc = "< Compute job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COMPUTE</i></c>."]
    pub computeJobDescriptor: ComputeJobDescription,
    pub rasterJobDescriptor: RasterJobDescription,
    pub barrierDescriptor: BarrierDescription,
    pub discardJobDescriptor: DiscardJobDescription,
}
impl Default for GpuJobDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GpuJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A single shader blob and a description of its resources.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderBlob {
    #[doc = "< A pointer to the blob"]
    pub data: *const u8,
    #[doc = "< Size in bytes."]
    pub size: u32,
    #[doc = "< Number of CBs."]
    pub cbvCount: u32,
    #[doc = "< Number of SRV Textures."]
    pub srvTextureCount: u32,
    #[doc = "< Number of UAV Textures."]
    pub uavTextureCount: u32,
    #[doc = "< Number of SRV Buffers."]
    pub srvBufferCount: u32,
    #[doc = "< Number of UAV Buffers."]
    pub uavBufferCount: u32,
    #[doc = "< Number of Samplers."]
    pub samplerCount: u32,
    #[doc = "< Number of RT Acceleration structures."]
    pub rtAccelStructCount: u32,
    pub boundConstantBufferNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound ConstantBuffers."]
    pub boundConstantBuffers: *const u32,
    #[doc = "< Pointer to an array of bound ConstantBuffer resource counts"]
    pub boundConstantBufferCounts: *const u32,
    #[doc = "< Pointer to an array of bound ConstantBuffer resource spaces"]
    pub boundConstantBufferSpaces: *const u32,
    pub boundSRVTextureNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound SRV resources."]
    pub boundSRVTextures: *const u32,
    #[doc = "< Pointer to an array of bound SRV resource counts"]
    pub boundSRVTextureCounts: *const u32,
    #[doc = "< Pointer to an array of bound SRV resource spaces"]
    pub boundSRVTextureSpaces: *const u32,
    pub boundUAVTextureNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound UAV texture resources."]
    pub boundUAVTextures: *const u32,
    #[doc = "< Pointer to an array of bound UAV texture resource counts"]
    pub boundUAVTextureCounts: *const u32,
    #[doc = "< Pointer to an array of bound UAV texture resource spaces"]
    pub boundUAVTextureSpaces: *const u32,
    pub boundSRVBufferNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound SRV buffer resources."]
    pub boundSRVBuffers: *const u32,
    #[doc = "< Pointer to an array of bound SRV buffer resource counts"]
    pub boundSRVBufferCounts: *const u32,
    #[doc = "< Pointer to an array of bound SRV buffer resource spaces"]
    pub boundSRVBufferSpaces: *const u32,
    pub boundUAVBufferNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound UAV buffer resources."]
    pub boundUAVBuffers: *const u32,
    #[doc = "< Pointer to an array of bound UAV buffer resource counts"]
    pub boundUAVBufferCounts: *const u32,
    #[doc = "< Pointer to an array of bound UAV buffer resource spaces"]
    pub boundUAVBufferSpaces: *const u32,
    pub boundSamplerNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound sampler resources."]
    pub boundSamplers: *const u32,
    #[doc = "< Pointer to an array of bound sampler resource counts"]
    pub boundSamplerCounts: *const u32,
    #[doc = "< Pointer to an array of bound sampler resource spaces"]
    pub boundSamplerSpaces: *const u32,
    pub boundRTAccelerationStructureNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound UAV buffer resources."]
    pub boundRTAccelerationStructures: *const u32,
    #[doc = "< Pointer to an array of bound UAV buffer resource counts"]
    pub boundRTAccelerationStructureCounts: *const u32,
    #[doc = "< Pointer to an array of bound UAV buffer resource spaces"]
    pub boundRTAccelerationStructureSpaces: *const u32,
}
impl Default for ShaderBlob {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing the parameters passed from the\n presentation thread to the ui composition callback function.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentCallbackDescription {
    #[doc = "< The active device"]
    pub device: Device,
    #[doc = "< The command list on which to register render commands"]
    pub commandList: CommandList,
    #[doc = "< The backbuffer resource with scene information"]
    pub currentBackBuffer: Resource,
    #[doc = "< Optional UI texture (when doing backbuffer + ui blend)"]
    pub currentUI: Resource,
    #[doc = "< The swapchain target into which to render ui composition"]
    pub outputSwapChainBuffer: Resource,
    #[doc = "< Whether this is an interpolated or real frame"]
    pub isInterpolatedFrame: bool,
    #[doc = "< Toggles whether UI gets premultiplied alpha blending or not"]
    pub usePremulAlpha: bool,
    pub frameID: u64,
}
impl Default for PresentCallbackDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing the parameters to pass to frame generation passes.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameGenerationDispatchDescription {
    #[doc = "< The command list on which to register render commands"]
    pub commandList: CommandList,
    #[doc = "< The current presentation color, this will be used as interpolation source data."]
    pub presentColor: Resource,
    #[doc = "< Interpolation destination targets (1 for each frame in numInterpolatedFrames)"]
    pub outputs: [Resource; 4usize],
    #[doc = "< The number of frames to interpolate from the passed in color target"]
    pub numInterpolatedFrames: u32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The transfer function use to convert interpolation source color data to linear RGB."]
    pub backBufferTransferFunction: BackbufferTransferFunction,
    #[doc = "< Min and max luminance values, used when converting HDR colors to linear RGB"]
    pub minMaxLuminance: [f32; 2usize],
    #[doc = "< The area of the backbuffer that should be used for interpolation in case only a part of the screen is used e.g. due to movie bars"]
    pub interpolationRect: Rect2D,
    pub frameID: u64,
}
impl Default for FrameGenerationDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EffectMemoryUsage {
    pub totalUsageInBytes: u64,
    pub aliasableUsageInBytes: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SwapchainFramePacingTuning {
    pub safetyMarginInMs: f32,
    pub varianceFactor: f32,
    pub allowHybridSpin: bool,
    pub hybridSpinTime: u32,
    pub allowWaitForSingleObjectOnFence: bool,
}
#[doc = " The value of Pi.\n\n @ingroup Utils"]
pub const FFX_PI: f32 = 3.1415927410125732;
#[doc = " An epsilon value for floating point numbers.\n\n @ingroup Utils"]
pub const FFX_EPSILON: f32 = 0.0000009999999974752427;
#[doc = " A typedef for the callback function for assert printing.\n\n This can be used to re-route printing of assert messages from the FFX backend\n to another destination. For example instead of the default behaviour of printing\n the assert messages to the debugger's TTY the message can be re-routed to a\n MessageBox in a GUI application.\n\n @param [in] message                 The message generated by the assert.\n\n @ingroup Asserts"]
pub type AssertCallback =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Function to report an assert.\n\n @param [in] file                    The name of the file as a string.\n @param [in] line                    The index of the line in the file.\n @param [in] condition               The boolean condition that was tested.\n @param [in] msg                     The optional message to print.\n\n @returns\n Always returns true.\n\n @ingroup Asserts"]
    #[link_name = "\u{1}ffxAssertReport"]
    pub fn AssertReport(
        file: *const ::std::os::raw::c_char,
        line: i32,
        condition: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Provides the ability to set a callback for assert messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n\n @ingroup Asserts"]
    #[link_name = "\u{1}ffxAssertSetPrintingCallback"]
    pub fn AssertSetPrintingCallback(callback: AssertCallback);
}
#[doc = " Typedef for error codes returned from functions in the FidelityFX SDK.\n\n @ingroup Errors"]
pub type ErrorCode = i32;
#[doc = "< The operation completed successfully."]
pub const FFX_OK: ErrorCodes = 0;
#[doc = "< The operation failed due to an invalid pointer."]
pub const FFX_ERROR_INVALID_POINTER: ErrorCodes = -2147483648;
#[doc = "< The operation failed due to an invalid alignment."]
pub const FFX_ERROR_INVALID_ALIGNMENT: ErrorCodes = -2147483647;
#[doc = "< The operation failed due to an invalid size."]
pub const FFX_ERROR_INVALID_SIZE: ErrorCodes = -2147483646;
#[doc = "< The end of the file was encountered."]
pub const FFX_EOF: ErrorCodes = -2147483645;
#[doc = "< The operation failed because the specified path was invalid."]
pub const FFX_ERROR_INVALID_PATH: ErrorCodes = -2147483644;
#[doc = "< The operation failed because end of file was reached."]
pub const FFX_ERROR_EOF: ErrorCodes = -2147483643;
#[doc = "< The operation failed because of some malformed data."]
pub const FFX_ERROR_MALFORMED_DATA: ErrorCodes = -2147483642;
#[doc = "< The operation failed because it ran out memory."]
pub const FFX_ERROR_OUT_OF_MEMORY: ErrorCodes = -2147483641;
#[doc = "< The operation failed because the interface was not fully configured."]
pub const FFX_ERROR_INCOMPLETE_INTERFACE: ErrorCodes = -2147483640;
#[doc = "< The operation failed because of an invalid enumeration value."]
pub const FFX_ERROR_INVALID_ENUM: ErrorCodes = -2147483639;
#[doc = "< The operation failed because an argument was invalid."]
pub const FFX_ERROR_INVALID_ARGUMENT: ErrorCodes = -2147483638;
#[doc = "< The operation failed because a value was out of range."]
pub const FFX_ERROR_OUT_OF_RANGE: ErrorCodes = -2147483637;
#[doc = "< The operation failed because a device was null."]
pub const FFX_ERROR_NULL_DEVICE: ErrorCodes = -2147483636;
#[doc = "< The operation failed because the backend API returned an error code."]
pub const FFX_ERROR_BACKEND_API_ERROR: ErrorCodes = -2147483635;
#[doc = "< The operation failed because there was not enough memory."]
pub const FFX_ERROR_INSUFFICIENT_MEMORY: ErrorCodes = -2147483634;
#[doc = "< The operation failed because the wrong backend was linked."]
pub const FFX_ERROR_INVALID_VERSION: ErrorCodes = -2147483633;
#[doc = "< The operation failed because access to the resource was denied."]
pub const FFX_ERROR_ACCESS_DENIED: ErrorCodes = -2147483632;
#[doc = " Error codes and their meaning\n\n @ingroup Errors"]
pub type ErrorCodes = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Provides the ability to set a callback for print messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n\n @ingroup Messages"]
    #[link_name = "\u{1}ffxSetPrintMessageCallback"]
    pub fn SetPrintMessageCallback(callback: MessageCallback, debugLevel: u32);
}
extern "C" {
    #[doc = " Function to print a message.\n\n @param [in] type                    See FfxMsgType\n @param [in] message                 The message to print.\n\n @ingroup Messages"]
    #[link_name = "\u{1}ffxPrintMessage"]
    pub fn PrintMessage(type_: u32, message: *const u16);
}
#[doc = " Stand in type for FfxPass\n\n These will be defined for each effect individually (i.e. FfxFsr2Pass).\n They are used to fetch the proper blob index to build effect shaders\n\n @ingroup FfxInterface"]
pub type Pass = u32;
#[doc = " Get the SDK version of the backend context.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n\n @returns\n The SDK version a backend was built with.\n\n @ingroup FfxInterface"]
pub type GetSDKVersionFunc =
    ::std::option::Option<unsafe extern "C" fn(backendInterface: *mut Interface) -> VersionNumber>;
#[doc = " Get effect VRAM usage.\n\n Newer effects may require support that legacy versions of the SDK will not be\n able to provide. A version query is thus required to ensure an effect component\n will always be paired with a backend which will support all needed functionality.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n @param [in]  effectContextId                     The context space to be used for the effect in question.\n @param [out] outVramUsage                        The effect memory usage structure to fill out.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type GetEffectGpuMemoryUsageFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effectContextId: UInt32,
        outVramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode,
>;
#[doc = " Create and initialize the backend context.\n\n The callback function sets up the backend context for rendering.\n It will create or reference the device and create required internal data structures.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n @param [in]  effect                              The effect the context is being created for\n @param [in]  bindlessConfig                      A pointer to the bindless configuration, if required by the effect.\n @param [out] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreateBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effect: Effect,
        bindlessConfig: *mut EffectBindlessConfig,
        effectContextId: *mut UInt32,
    ) -> ErrorCode,
>;
#[doc = " Get a list of capabilities of the device.\n\n When creating an <c><i>FfxEffectContext</i></c> it is desirable for the FFX\n core implementation to be aware of certain characteristics of the platform\n that is being targetted. This is because some optimizations which FFX SDK\n attempts to perform are more effective on certain classes of hardware than\n others, or are not supported by older hardware. In order to avoid cases\n where optimizations actually have the effect of decreasing performance, or\n reduce the breadth of support provided by FFX SDK, the FFX interface queries the\n capabilities of the device to make such decisions.\n\n For target platforms with fixed hardware support you need not implement\n this callback function by querying the device, but instead may hardcore\n what features are available on the platform.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] outDeviceCapabilities              The device capabilities structure to fill out.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type GetDeviceCapabilitiesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        outDeviceCapabilities: *mut DeviceCapabilities,
    ) -> ErrorCode,
>;
#[doc = " Destroy the backend context and dereference the device.\n\n This function is called when the <c><i>FfxEffectContext</i></c> is destroyed.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, effectContextId: UInt32) -> ErrorCode,
>;
#[doc = " Create a resource.\n\n This callback is intended for the backend to create internal resources.\n\n Please note: It is also possible that the creation of resources might\n itself cause additional resources to be created by simply calling the\n <c><i>FfxCreateResourceFunc</i></c> function pointer again. This is\n useful when handling the initial creation of resources which must be\n initialized. The flow in such a case would be an initial call to create the\n CPU-side resource, another to create the GPU-side resource, and then a call\n to schedule a copy render job to move the data between the two. Typically\n this type of function call flow is only seen during the creation of an\n <c><i>FfxEffectContext</i></c>.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] createResourceDescription           A pointer to a <c><i>FfxCreateResourceDescription</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outResource                        A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreateResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        createResourceDescription: *const CreateResourceDescription,
        effectContextId: UInt32,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Register a resource in the backend for the current frame.\n\n Since the FfxInterface and the backends are not aware how many different\n resources will get passed in over time, it's not safe\n to register all resources simultaneously in the backend.\n Also passed resources may not be valid after the dispatch call.\n As a result it's safest to register them as FfxResourceInternal\n and clear them at the end of the dispatch call.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] inResource                          A pointer to a <c><i>FfxResource</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outResource                        A pointer to a <c><i>FfxResourceInternal</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type RegisterResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        inResource: *const Resource,
        effectContextId: UInt32,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Get an FfxResource from an FfxResourceInternal resource.\n\n At times it is necessary to create an FfxResource representation\n of an internally created resource in order to register it with a\n child effect context. This function sets up the FfxResource needed\n to register.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            The <c><i>FfxResourceInternal</i></c> for which to setup an FfxResource.\n\n @returns\n An FfxResource built from the internal resource\n\n @ingroup FfxInterface"]
pub type GetResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, resource: ResourceInternal) -> Resource,
>;
#[doc = " Unregister all temporary FfxResourceInternal from the backend.\n\n Unregister FfxResourceInternal referencing resources passed to\n a function as a parameter.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type UnregisterResourcesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        commandList: CommandList,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Register a resource in the static bindless table of the backend.\n\n A static resource will persist in their respective bindless table until it is\n overwritten by a different resource at the same index.\n The calling code must take care not to immediately register a new resource at an index\n that might be in use by an in-flight frame.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] desc                                A pointer to an <c><i>FfxStaticResourceDescription</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type RegisterStaticResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        desc: *const StaticResourceDescription,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Retrieve a <c><i>FfxResourceDescription</i></c> matching a\n <c><i>FfxResource</i></c> structure.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @returns\n A description of the resource.\n\n @ingroup FfxInterface"]
pub type GetResourceDescriptionFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
    ) -> ResourceDescription,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Map resource memory\n\n Maps the memory of the resource to a pointer and returns it.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n @param [out] ptr                                A pointer to the mapped memory.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type MapResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ErrorCode,
>;
#[doc = " Unmap resource memory\n\n Unmaps previously mapped memory of a resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type UnmapResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, resource: ResourceInternal) -> ErrorCode,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type StageConstantBufferDataFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        data: *mut ::std::os::raw::c_void,
        size: UInt32,
        constantBuffer: *mut ConstantBuffer,
    ) -> ErrorCode,
>;
#[doc = " Create a render pipeline.\n\n A rendering pipeline contains the shader as well as resource bindpoints\n and samplers.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] pass                                The identifier for the pass.\n @param [in] pipelineDescription                 A pointer to a <c><i>FfxPipelineDescription</i></c> describing the pipeline to be created.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outPipeline                        A pointer to a <c><i>FfxPipelineState</i></c> structure which should be populated.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreatePipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effect: Effect,
        pass: Pass,
        permutationOptions: u32,
        pipelineDescription: *const PipelineDescription,
        effectContextId: UInt32,
        outPipeline: *mut PipelineState,
    ) -> ErrorCode,
>;
pub type GetPermutationBlobByIndexFunc = ::std::option::Option<
    unsafe extern "C" fn(
        effectId: Effect,
        passId: Pass,
        bindStage: BindStage,
        permutationOptions: u32,
        outBlob: *mut ShaderBlob,
    ) -> ErrorCode,
>;
#[doc = " Destroy a render pipeline.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] pipeline                           A pointer to a <c><i>FfxPipelineState</i></c> structure which should be released.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyPipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        pipeline: *mut PipelineState,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Schedule a render job to be executed on the next call of\n <c><i>FfxExecuteGpuJobsFunc</i></c>.\n\n Render jobs can perform one of three different tasks: clear, copy or\n compute dispatches.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] job                                 A pointer to a <c><i>FfxGpuJobDescription</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type ScheduleGpuJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        job: *const GpuJobDescription,
    ) -> ErrorCode,
>;
#[doc = " Execute scheduled render jobs on the <c><i>comandList</i></c> provided.\n\n The recording of the graphics API commands should take place in this\n callback function, the render jobs which were previously enqueued (via\n callbacks made to <c><i>FfxScheduleGpuJobFunc</i></c>) should be\n processed in the order they were received. Advanced users might choose to\n reorder the rendering jobs, but should do so with care to respect the\n resource dependencies.\n\n Depending on the precise contents of <c><i>FfxDispatchDescription</i></c> a\n different number of render jobs might have previously been enqueued (for\n example if sharpening is toggled on and off).\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type ExecuteGpuJobsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        commandList: CommandList,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = "< A bit indicating that we use premultiplied alpha for UI composition"]
pub const FFX_UI_COMPOSITION_FLAG_USE_PREMUL_ALPHA: UiCompositionFlags = 1;
#[doc = "< A bit indicating that the swapchain should doublebuffer the UI resource"]
pub const FFX_UI_COMPOSITION_FLAG_ENABLE_INTERNAL_UI_DOUBLE_BUFFERING: UiCompositionFlags = 2;
pub type UiCompositionFlags = ::std::os::raw::c_int;
pub type PresentCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        params: *const PresentCallbackDescription,
        arg1: *mut ::std::os::raw::c_void,
    ) -> ErrorCode,
>;
pub type FrameGenerationDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        params: *const FrameGenerationDispatchDescription,
        arg1: *mut ::std::os::raw::c_void,
    ) -> ErrorCode,
>;
pub type WaitCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(fenceName: *mut u16, fenceValueToWaitFor: u64) -> ErrorCode,
>;
#[doc = " A structure representing the configuration options to pass to FrameInterpolationSwapChain\n\n @ingroup FfxInterface"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameGenerationConfig {
    #[doc = "< The <c><i>FfxSwapchain</i></c> to use with frame interpolation"]
    pub swapChain: Swapchain,
    #[doc = "< A UI composition callback to call when finalizing the frame image"]
    pub presentCallback: PresentCallbackFunc,
    #[doc = "< A pointer to be passed to the UI composition callback"]
    pub presentCallbackContext: *mut ::std::os::raw::c_void,
    #[doc = "< The frame generation callback to use to generate the interpolated frame"]
    pub frameGenerationCallback: FrameGenerationDispatchFunc,
    #[doc = "< A pointer to be passed to the frame generation callback"]
    pub frameGenerationCallbackContext: *mut ::std::os::raw::c_void,
    #[doc = "< Sets the state of frame generation. Set to false to disable frame generation"]
    pub frameGenerationEnabled: bool,
    #[doc = "< Sets the state of async workloads. Set to true to enable interpolation work on async compute"]
    pub allowAsyncWorkloads: bool,
    #[doc = "< Sets the state of async presentation (console only). Set to true to enable present from async command queue"]
    pub allowAsyncPresent: bool,
    #[doc = "< The hudless back buffer image to use for UI extraction from backbuffer resource"]
    pub HUDLessColor: Resource,
    #[doc = "< Flags"]
    pub flags: UInt32,
    #[doc = "< Set to true to only present interpolated frame"]
    pub onlyPresentInterpolated: bool,
    #[doc = "< Set the area in the backbuffer that will be interpolated"]
    pub interpolationRect: Rect2D,
    #[doc = "< A frame identifier used to synchronize resource usage in workloads"]
    pub frameID: u64,
    #[doc = "< Sets the state of pacing debug lines. Set to true to display debug lines"]
    pub drawDebugPacingLines: bool,
}
impl Default for FrameGenerationConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SwapChainConfigureFrameGenerationFunc =
    ::std::option::Option<unsafe extern "C" fn(config: *const FrameGenerationConfig) -> ErrorCode>;
#[doc = " Allocate AMD FidelityFX Breadcrumbs Library markers buffer.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] blockBytes                          Size in bytes of the buffer to be allocated.\n @param [out] blockData                          Output information about allocated AMD FidelityFX Breadcrumbs Library buffer. Filled only on success of operation.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type BreadcrumbsAllocBlockFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        blockBytes: u64,
        blockData: *mut BreadcrumbsBlockData,
    ) -> ErrorCode,
>;
#[doc = " Deallocate AMD FidelityFX Breadcrumbs Library markers buffer.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] blockData                          Information about buffer to be freed. All resource handles are cleared after this operation.\n\n @ingroup FfxInterface"]
pub type BreadcrumbsFreeBlockFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, blockData: *mut BreadcrumbsBlockData),
>;
#[doc = " Write marker to AMD FidelityFX Breadcrumbs Library buffer on the <c><i>comandList</i></c> provided.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         GPU command list to record marker writing command.\n @param [in] value                               Marker value to be written.\n @param [in] gpuLocation                         GPU destination address where marker will be written.\n @param [in] gpuBuffer                           Destination AMD FidelityFX Breadcrumbs Library buffer.\n @param [in] isBegin                             <c><i>true</i></c> for writing opening marker and <c><i>false</i></c> for ending marker.\n\n @ingroup FfxInterface"]
pub type BreadcrumbsWriteFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        commandList: CommandList,
        value: u32,
        gpuLocation: u64,
        gpuBuffer: *mut ::std::os::raw::c_void,
        isBegin: bool,
    ),
>;
#[doc = " Printing GPU specific info to the AMD FidelityFX Breadcrumbs Library status buffer.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] allocs                              A pointer to the allocation callbacks.\n @param [in] extendedInfo                        <c><i>true</i></c> if should print more verbose device info and <c><i>false</i></c> for standard output.\n @param [out] printBuffer                        String buffer for writing GPU info.\n @param [out] printSize                          Size of string buffer for writing GPU info.\n\n @ingroup FfxInterface"]
pub type BreadcrumbsPrintDeviceInfoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        allocs: *mut AllocationCallbacks,
        extendedInfo: bool,
        printBuffer: *mut *mut ::std::os::raw::c_char,
        printSize: *mut usize,
    ),
>;
#[doc = " Register a <b>Thread Safe</b> constant buffer allocator to be used by the backend.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] constantAllocator                   An <c><i>FfxConstantBufferAllocator</i></c> callback to be used by the backend.\n\n @ingroup FfxInterface"]
pub type RegisterConstantBufferAllocatorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        constantAllocator: ConstantBufferAllocator,
    ),
>;
#[doc = " A structure encapsulating the interface between the core implementation of\n the FfxInterface and any graphics API that it should ultimately call.\n\n This set of functions serves as an abstraction layer between FfxInterfae and the\n API used to implement it. While the FidelityFX SDK ships with backends for DirectX12 and\n Vulkan, it is possible to implement your own backend for other platforms\n which sit on top of your engine's own abstraction layer. For details on the\n expectations of what each function should do you should refer the\n description of the following function pointer types:\n   - <c><i>FfxCreateDeviceFunc</i></c>\n   - <c><i>FfxGetDeviceCapabilitiesFunc</i></c>\n   - <c><i>FfxDestroyDeviceFunc</i></c>\n   - <c><i>FfxCreateResourceFunc</i></c>\n   - <c><i>FfxRegisterResourceFunc</i></c>\n   - <c><i>FfxGetResourceFunc</i></c>\n   - <c><i>FfxUnregisterResourcesFunc</i></c>\n   - <c><i>FfxGetResourceDescriptionFunc</i></c>\n   - <c><i>FfxDestroyResourceFunc</i></c>\n   - <c><i>FfxCreatePipelineFunc</i></c>\n   - <c><i>FfxDestroyPipelineFunc</i></c>\n   - <c><i>FfxScheduleGpuJobFunc</i></c>\n   - <c><i>FfxExecuteGpuJobsFunc</i></c>\n   - <c><i>FfxBeginMarkerFunc</i></c>\n   - <c><i>FfxEndMarkerFunc</i></c>\n   - <c><i>FfxRegisterConstantBufferAllocatorFunc</i></c>\n\n Depending on the graphics API that is abstracted by the backend, it may be\n required that the backend is to some extent stateful. To ensure that\n applications retain full control to manage the memory used by the FidelityFX SDK, the\n <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields are\n provided. A backend should provide a means of specifying how much scratch\n memory is required for its internal implementation (e.g: via a function\n or constant value). The application is then responsible for allocating that\n memory and providing it when setting up the SDK backend. Backends provided\n with the FidelityFX SDK do not perform dynamic memory allocations, and instead\n sub-allocate all memory from the scratch buffers provided.\n\n The <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields\n should be populated according to the requirements of each backend. For\n example, if using the DirectX 12 backend you should call the\n <c><i>ffxGetScratchMemorySizeDX12</i></c> function. It is not required\n that custom backend implementations use a scratch buffer.\n\n Any functional addition to this interface mandates a version\n bump to ensure full functionality across effects and backends.\n\n @ingroup FfxInterface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Interface {
    #[doc = "< A callback function to query the SDK version."]
    pub fpGetSDKVersion: GetSDKVersionFunc,
    #[doc = "< A callback function to query effect Gpu memory usage"]
    pub fpGetEffectGpuMemoryUsage: GetEffectGpuMemoryUsageFunc,
    #[doc = "< A callback function to create and initialize the backend context."]
    pub fpCreateBackendContext: CreateBackendContextFunc,
    #[doc = "< A callback function to query device capabilites."]
    pub fpGetDeviceCapabilities: GetDeviceCapabilitiesFunc,
    #[doc = "< A callback function to destroy the backendcontext. This also dereferences the device."]
    pub fpDestroyBackendContext: DestroyBackendContextFunc,
    #[doc = "< A callback function to create a resource."]
    pub fpCreateResource: CreateResourceFunc,
    #[doc = "< A callback function to register an external resource."]
    pub fpRegisterResource: RegisterResourceFunc,
    #[doc = "< A callback function to convert an internal resource to external resource type"]
    pub fpGetResource: GetResourceFunc,
    #[doc = "< A callback function to unregister external resource."]
    pub fpUnregisterResources: UnregisterResourcesFunc,
    #[doc = "< A callback function to register a static resource."]
    pub fpRegisterStaticResource: RegisterStaticResourceFunc,
    #[doc = "< A callback function to retrieve a resource description."]
    pub fpGetResourceDescription: GetResourceDescriptionFunc,
    #[doc = "< A callback function to destroy a resource."]
    pub fpDestroyResource: DestroyResourceFunc,
    #[doc = "< A callback function to map a resource."]
    pub fpMapResource: MapResourceFunc,
    #[doc = "< A callback function to unmap a resource."]
    pub fpUnmapResource: UnmapResourceFunc,
    #[doc = "< A callback function to copy constant buffer data into staging memory."]
    pub fpStageConstantBufferDataFunc: StageConstantBufferDataFunc,
    #[doc = "< A callback function to create a render or compute pipeline."]
    pub fpCreatePipeline: CreatePipelineFunc,
    #[doc = "< A callback function to destroy a render or compute pipeline."]
    pub fpDestroyPipeline: DestroyPipelineFunc,
    #[doc = "< A callback function to schedule a render job."]
    pub fpScheduleGpuJob: ScheduleGpuJobFunc,
    #[doc = "< A callback function to execute all queued render jobs."]
    pub fpExecuteGpuJobs: ExecuteGpuJobsFunc,
    #[doc = "< A callback function to allocate block of memory for AMD FidelityFX Breadcrumbs Library buffer."]
    pub fpBreadcrumbsAllocBlock: BreadcrumbsAllocBlockFunc,
    #[doc = "< A callback function to free AMD FidelityFX Breadcrumbs Library buffer."]
    pub fpBreadcrumbsFreeBlock: BreadcrumbsFreeBlockFunc,
    #[doc = "< A callback function to write marker into AMD FidelityFX Breadcrumbs Library."]
    pub fpBreadcrumbsWrite: BreadcrumbsWriteFunc,
    #[doc = "< A callback function to print active GPU info for AMD FidelityFX Breadcrumbs Library log."]
    pub fpBreadcrumbsPrintDeviceInfo: BreadcrumbsPrintDeviceInfoFunc,
    pub fpGetPermutationBlobByIndex: GetPermutationBlobByIndexFunc,
    #[doc = "< A callback function to configure swap chain present callback."]
    pub fpSwapChainConfigureFrameGeneration: SwapChainConfigureFrameGenerationFunc,
    #[doc = "< A callback function to register a custom <b>Thread Safe</b> constant buffer allocator."]
    pub fpRegisterConstantBufferAllocator: RegisterConstantBufferAllocatorFunc,
    #[doc = "< A preallocated buffer for memory utilized internally by the backend."]
    pub scratchBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the buffer pointed to by <c><i>scratchBuffer</i></c>."]
    pub scratchBufferSize: usize,
    #[doc = "< A backend specific device"]
    pub device: Device,
}
impl Default for Interface {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< A pass which prepares game inputs for later passes"]
pub const FFX_FSR3UPSCALER_PASS_PREPARE_INPUTS: Fsr3UpscalerPass = 0;
#[doc = "< A pass which generates the luminance mipmap chain for the current frame."]
pub const FFX_FSR3UPSCALER_PASS_LUMA_PYRAMID: Fsr3UpscalerPass = 1;
#[doc = "< A pass which generates the shading change detection mipmap chain for the current frame."]
pub const FFX_FSR3UPSCALER_PASS_SHADING_CHANGE_PYRAMID: Fsr3UpscalerPass = 2;
#[doc = "< A pass which estimates shading changes for the current frame"]
pub const FFX_FSR3UPSCALER_PASS_SHADING_CHANGE: Fsr3UpscalerPass = 3;
#[doc = "< A pass which prepares accumulation relevant information"]
pub const FFX_FSR3UPSCALER_PASS_PREPARE_REACTIVITY: Fsr3UpscalerPass = 4;
#[doc = "< A pass which estimates temporal instability of the luminance changes."]
pub const FFX_FSR3UPSCALER_PASS_LUMA_INSTABILITY: Fsr3UpscalerPass = 5;
#[doc = "< A pass which performs upscaling."]
pub const FFX_FSR3UPSCALER_PASS_ACCUMULATE: Fsr3UpscalerPass = 6;
#[doc = "< A pass which performs upscaling when sharpening is used."]
pub const FFX_FSR3UPSCALER_PASS_ACCUMULATE_SHARPEN: Fsr3UpscalerPass = 7;
#[doc = "< A pass which performs sharpening."]
pub const FFX_FSR3UPSCALER_PASS_RCAS: Fsr3UpscalerPass = 8;
#[doc = "< A pass which draws some internal resources, for debugging purposes"]
pub const FFX_FSR3UPSCALER_PASS_DEBUG_VIEW: Fsr3UpscalerPass = 9;
#[doc = "< An optional pass to generate a reactive mask."]
pub const FFX_FSR3UPSCALER_PASS_GENERATE_REACTIVE: Fsr3UpscalerPass = 10;
#[doc = "< DEPRECATED - NO LONGER SUPPORTED"]
pub const FFX_FSR3UPSCALER_PASS_TCR_AUTOGENERATE: Fsr3UpscalerPass = 11;
#[doc = "< The number of passes performed by FSR3."]
pub const FFX_FSR3UPSCALER_PASS_COUNT: Fsr3UpscalerPass = 12;
#[doc = " An enumeration of all the passes which constitute the FSR3 algorithm.\n\n FSR3 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr3UpscalerScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr3UpscalerPass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR3\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR3UPSCALER_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR3UPSCALER_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr3UpscalerContext</i></c> is created and the\n precise contents of <c><i>FfxFsr3UpscalerDispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr3UpscalerContextDispatch</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerPass = ::std::os::raw::c_int;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.0x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_NATIVEAA: Fsr3UpscalerQualityMode = 0;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_QUALITY: Fsr3UpscalerQualityMode = 1;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_BALANCED: Fsr3UpscalerQualityMode = 2;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_PERFORMANCE: Fsr3UpscalerQualityMode = 3;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
pub const FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE: Fsr3UpscalerQualityMode = 4;
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 3 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR3. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerQualityMode = ::std::os::raw::c_int;
#[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
pub const FFX_FSR3UPSCALER_ENABLE_HIGH_DYNAMIC_RANGE: Fsr3UpscalerInitializationFlagBits = 1;
#[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
pub const FFX_FSR3UPSCALER_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS:
    Fsr3UpscalerInitializationFlagBits = 2;
#[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
pub const FFX_FSR3UPSCALER_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION:
    Fsr3UpscalerInitializationFlagBits = 4;
#[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
pub const FFX_FSR3UPSCALER_ENABLE_DEPTH_INVERTED: Fsr3UpscalerInitializationFlagBits = 8;
#[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
pub const FFX_FSR3UPSCALER_ENABLE_DEPTH_INFINITE: Fsr3UpscalerInitializationFlagBits = 16;
#[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
pub const FFX_FSR3UPSCALER_ENABLE_AUTO_EXPOSURE: Fsr3UpscalerInitializationFlagBits = 32;
#[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
pub const FFX_FSR3UPSCALER_ENABLE_DYNAMIC_RESOLUTION: Fsr3UpscalerInitializationFlagBits = 64;
#[doc = "< This value is deprecated, but remains in order to aid upgrading from older versions of FSR3."]
pub const FFX_FSR3UPSCALER_ENABLE_TEXTURE1D_USAGE: Fsr3UpscalerInitializationFlagBits = 128;
#[doc = "< A bit indicating that the runtime should check some API values and report issues."]
pub const FFX_FSR3UPSCALER_ENABLE_DEBUG_CHECKING: Fsr3UpscalerInitializationFlagBits = 256;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr3UpscalerContext</i></c>. See <c><i>FfxFsr3UpscalerContextDescription</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerInitializationFlagBits = ::std::os::raw::c_int;
#[doc = " Pass a string message\n\n Used for debug messages.\n\n @param [in] type                       The type of message.\n @param [in] message                    A string message to pass.\n\n\n @ingroup ffxFsr3Upscaler"]
pub type Fsr3UpscalerMessage =
    ::std::option::Option<unsafe extern "C" fn(type_: MsgType, message: *const u16)>;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 3 upscaling.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3UpscalerContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr3UpscalerInitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the output resolution targeted by the upscaling process."]
    pub maxUpscaleSize: Dimensions2D,
    #[doc = "< A pointer to a function that can receive messages from the runtime."]
    pub fpMessage: Fsr3UpscalerMessage,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
}
impl Default for Fsr3UpscalerContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< A bit indicating that the interpolated output resource will contain debug views with relevant information."]
pub const FFX_FSR3UPSCALER_DISPATCH_DRAW_DEBUG_VIEW: Fsr3UpscalerDispatchFlags = 1;
pub type Fsr3UpscalerDispatchFlags = ::std::os::raw::c_int;
pub const FFX_FSR3UPSCALER_CONFIGURE_UPSCALE_KEY_FVELOCITYFACTOR: Fsr3UpscalerConfigureKey = 0;
pub const FFX_FSR3UPSCALER_CONFIGURE_UPSCALE_KEY_FREACTIVENESSSCALE: Fsr3UpscalerConfigureKey = 1;
pub const FFX_FSR3UPSCALER_CONFIGURE_UPSCALE_KEY_FSHADINGCHANGESCALE: Fsr3UpscalerConfigureKey = 2;
pub const FFX_FSR3UPSCALER_CONFIGURE_UPSCALE_KEY_FACCUMULATIONADDEDPERFRAME:
    Fsr3UpscalerConfigureKey = 3;
pub const FFX_FSR3UPSCALER_CONFIGURE_UPSCALE_KEY_FMINDISOCCLUSIONACCUMULATION:
    Fsr3UpscalerConfigureKey = 4;
pub type Fsr3UpscalerConfigureKey = ::std::os::raw::c_int;
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 3.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3UpscalerDispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR3UPSCALER_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit dilated depth and share with following effects."]
    pub dilatedDepth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit dilated motion vectors and share with following effects."]
    pub dilatedMotionVectors: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> allocated as described in <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> that is used to emit reconstructed previous nearest depth and share with following effects."]
    pub reconstructedPrevNearestDepth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub output: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< The resolution that the upscaler will output."]
    pub upscaleSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< combination of FfxFsr3UpscalerDispatchFlags"]
    pub flags: u32,
}
impl Default for Fsr3UpscalerDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3UpscalerGenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for Fsr3UpscalerGenerateReactiveDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the resource descriptions for shared resources for this effect.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3UpscalerSharedResourceDescriptions {
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>reconstructedPrevNearestDepth</i></c> shared resource."]
    pub reconstructedPrevNearestDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedDepth</i></c> shared resource."]
    pub dilatedDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedMotionVectors</i></c> shared resource."]
    pub dilatedMotionVectors: CreateResourceDescription,
}
impl Default for Fsr3UpscalerSharedResourceDescriptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 3 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3UpscalerContext</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup ffxFsr3Upscaler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3UpscalerContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for Fsr3UpscalerContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 3 context from the parameters\n programmed to the <c><i>FfxFsr3UpscalerCreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3UpscalerContext</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3UpscalerContext</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3UpscalerDispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3UpscalerContext</i></c> is created, you should use the\n <c><i>ffxFsr3UpscalerContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3UpscalerContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3UpscalerContext</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3UpscalerContextDestroy</i></c>.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure to populate.\n @param [in]  pContextDescription     A pointer to a <c><i>FfxFsr3UpscalerContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3UpscalerContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextCreate"]
    pub fn Fsr3UpscalerContextCreate(
        pContext: *mut Fsr3UpscalerContext,
        pContextDescription: *const Fsr3UpscalerContextDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Provides the descriptions for shared resources that must be allocated for this effect.\n\n @param [in] context\t\t\t\t\tA pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [out] SharedResources\t\tA pointer to a <c><i>FfxFsr3UpscalerSharedResourceDescriptions</i></c> to populate.\n\n @returns\n FFX_OK\t\t\t\t\t\t\t\tThe operation completed successfully.\n @returns\n Anything else\t\t\t\t\t\tThe operation failed.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetSharedResourceDescriptions"]
    pub fn Fsr3UpscalerGetSharedResourceDescriptions(
        context: *mut Fsr3UpscalerContext,
        SharedResources: *mut Fsr3UpscalerSharedResourceDescriptions,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Get GPU memory usage of the FidelityFX Super Resolution context.\n\n @param [in]  pContext                A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [out] pVramUsage              A pointer to a <c><i>FfxEffectMemoryUsage</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>vramUsage</i></c> were <c><i>NULL</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextGetGpuMemoryUsage"]
    pub fn Fsr3UpscalerContextGetGpuMemoryUsage(
        pContext: *mut Fsr3UpscalerContext,
        pVramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 3.\n\n FSR3 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr3UpscalerContextDispatch</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr3UpscalerContext</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr3UpscalerContext</i></c> correctly\n programming the <c><i>FfxFsr3UpscalerDispatchDescription</i></c> is key to ensuring\n the correct operation of FSR3. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR3 provides the\n <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c> and\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchDescription</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR3.\n\n @param [in] pContext                 A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [in] pDispatchDescription     A pointer to a <c><i>FfxFsr3UpscalerDispatchDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchDescription.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextDispatch"]
    pub fn Fsr3UpscalerContextDispatch(
        pContext: *mut Fsr3UpscalerContext,
        pDispatchDescription: *const Fsr3UpscalerDispatchDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] pContext                 A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [in] pParams                  A pointer to a <c><i>FfxFsr3UpscalerGenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextGenerateReactiveMask"]
    pub fn Fsr3UpscalerContextGenerateReactiveMask(
        pContext: *mut Fsr3UpscalerContext,
        pParams: *const Fsr3UpscalerGenerateReactiveDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] pContext                A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerContextDestroy"]
    pub fn Fsr3UpscalerContextDestroy(pContext: *mut Fsr3UpscalerContext) -> ErrorCode;
}
extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetUpscaleRatioFromQualityMode"]
    pub fn Fsr3UpscalerGetUpscaleRatioFromQualityMode(qualityMode: Fsr3UpscalerQualityMode) -> f32;
}
extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr3UpscalerGetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] pRenderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] pRenderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetRenderResolutionFromQualityMode"]
    pub fn Fsr3UpscalerGetRenderResolutionFromQualityMode(
        pRenderWidth: *mut u32,
        pRenderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: Fsr3UpscalerQualityMode,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR3UPSCALER_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetJitterPhaseCount"]
    pub fn Fsr3UpscalerGetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR3 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR3 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr3UpscalerGetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr3UpscalerGetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr3UpscalerGetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr3UpscalerDispatchParameters</i></c> structure in order to inform FSR3\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr3UpscalerGetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] pOutX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] pOutY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr3UpscalerGetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetJitterOffset"]
    pub fn Fsr3UpscalerGetJitterOffset(
        pOutX: *mut f32,
        pOutY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerResourceIsNull"]
    pub fn Fsr3UpscalerResourceIsNull(resource: Resource) -> bool;
}
extern "C" {
    #[doc = " Queries the effect version number.\n\n @returns\n The SDK version the effect was built with.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerGetEffectVersion"]
    pub fn Fsr3UpscalerGetEffectVersion() -> VersionNumber;
}
extern "C" {
    #[doc = " Override upscaler constant buffer value after upscaler context creation.\n\n @param [in] context                  A pointer to a <c><i>FfxFsr3UpscalerContext</i></c> structure.\n @param [in] key                      A key from <c><i>FfxFsr3UpscalerConfigureKey</i></c> enum\n @param [in] valuePtr                 A pointer to value to pass to shader in Constant Buffer. See Fsr3UpscalerConstants\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid FfxFsr3UpscalerConfigureKey was specified.\n @retval\n FFX_ERROR_INVALID_POINTER           <c><i>pContext</c></i> was NULL.\n\n @ingroup ffxFsr3Upscaler"]
    #[link_name = "\u{1}ffxFsr3UpscalerSetConstant"]
    pub fn Fsr3UpscalerSetConstant(
        context: *mut Fsr3UpscalerContext,
        key: Fsr3UpscalerConfigureKey,
        valuePtr: *mut ::std::os::raw::c_void,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Set global debug message settings\n\n @param [in] fpMessage                A <c><i>ffxMessageCallback</i></ci>\n @param [in] debugLevel               An unsigned integer. Unimplemented.\n @retval\n FFX_OK                               The operation completed successfully.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFsr3UpscalerSetGlobalDebugMessage"]
    pub fn Fsr3UpscalerSetGlobalDebugMessage(
        fpMessage: MessageCallback,
        debugLevel: u32,
    ) -> ErrorCode;
}
pub const FFX_FRAMEINTERPOLATION_PASS_RECONSTRUCT_AND_DILATE: FrameInterpolationPass = 0;
pub const FFX_FRAMEINTERPOLATION_PASS_SETUP: FrameInterpolationPass = 1;
pub const FFX_FRAMEINTERPOLATION_PASS_RECONSTRUCT_PREV_DEPTH: FrameInterpolationPass = 2;
pub const FFX_FRAMEINTERPOLATION_PASS_GAME_MOTION_VECTOR_FIELD: FrameInterpolationPass = 3;
pub const FFX_FRAMEINTERPOLATION_PASS_OPTICAL_FLOW_VECTOR_FIELD: FrameInterpolationPass = 4;
pub const FFX_FRAMEINTERPOLATION_PASS_DISOCCLUSION_MASK: FrameInterpolationPass = 5;
pub const FFX_FRAMEINTERPOLATION_PASS_INTERPOLATION: FrameInterpolationPass = 6;
pub const FFX_FRAMEINTERPOLATION_PASS_INPAINTING_PYRAMID: FrameInterpolationPass = 7;
pub const FFX_FRAMEINTERPOLATION_PASS_INPAINTING: FrameInterpolationPass = 8;
pub const FFX_FRAMEINTERPOLATION_PASS_GAME_VECTOR_FIELD_INPAINTING_PYRAMID: FrameInterpolationPass =
    9;
pub const FFX_FRAMEINTERPOLATION_PASS_DEBUG_VIEW: FrameInterpolationPass = 10;
#[doc = "< The number of passes performed by FrameInterpolation."]
pub const FFX_FRAMEINTERPOLATION_PASS_COUNT: FrameInterpolationPass = 11;
#[doc = " An enumeration of all the passes which constitute the FSR3 algorithm.\n\n FSR3 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr3ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr3Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR3\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR3_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR3_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr3Context</i></c> is created and the\n precise contents of <c><i>FfxFsr3DispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr3ContextDispatch</i></c>.\n\n @ingroup FRAMEINTERPOLATIONFRAMEINTERPOLATION"]
pub type FrameInterpolationPass = ::std::os::raw::c_int;
#[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_DEPTH_INVERTED: FrameInterpolationInitializationFlagBits =
    1;
#[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_DEPTH_INFINITE: FrameInterpolationInitializationFlagBits =
    2;
#[doc = "< A bit indicating that the backend should use 1D textures."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_TEXTURE1D_USAGE: FrameInterpolationInitializationFlagBits =
    4;
#[doc = "< A bit indicating that HDR values are present in the imaging pipeline."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_HDR_COLOR_INPUT: FrameInterpolationInitializationFlagBits =
    8;
#[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS:
    FrameInterpolationInitializationFlagBits = 16;
pub const FFX_FRAMEINTERPOLATION_ENABLE_JITTER_MOTION_VECTORS:
    FrameInterpolationInitializationFlagBits = 32;
pub const FFX_FRAMEINTERPOLATION_ENABLE_ASYNC_SUPPORT: FrameInterpolationInitializationFlagBits =
    64;
#[doc = "< A bit indicating that the runtime should check some API values and report issues."]
pub const FFX_FRAMEINTERPOLATION_ENABLE_DEBUG_CHECKING: FrameInterpolationInitializationFlagBits =
    128;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFrameInterpolationContext</i></c>. See <c><i>FfxFrameInterpolationContextDescription</i></c>.\n\n @ingroup FRAMEINTERPOLATIONFRAMEINTERPOLATION"]
pub type FrameInterpolationInitializationFlagBits = ::std::os::raw::c_int;
#[doc = " A structure encapsulating the parameters required to initialize\n FidelityFX Frameinterpolation.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FrameInterpolationContextDescription {
    #[doc = "< A collection of <c><i>FfxFrameInterpolationInitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution"]
    pub displaySize: Dimensions2D,
    #[doc = "< the format of the backbuffer"]
    pub backBufferFormat: SurfaceFormat,
    #[doc = "< the format of the texture that will store the interpolation source for the next frame. Can be different than the backbuffer one, especially when using hudless"]
    pub previousInterpolationSourceFormat: SurfaceFormat,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
}
impl Default for FrameInterpolationContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the resource descriptions for shared resources for this effect.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameInterpolationSharedResourceDescriptions {
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>reconstructedPrevNearestDepth</i></c> shared resource."]
    pub reconstructedPrevNearestDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedDepth</i></c> shared resource."]
    pub dilatedDepth: CreateResourceDescription,
    #[doc = "< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>dilatedMotionVectors</i></c> shared resource."]
    pub dilatedMotionVectors: CreateResourceDescription,
}
impl Default for FrameInterpolationSharedResourceDescriptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 2 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3Context</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup FRAMEINTERPOLATION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FrameInterpolationContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for FrameInterpolationContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 2 context from the parameters\n programmed to the <c><i>FfxFsr3CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3Context</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3Context</i></c> is created, you should use the\n <c><i>ffxFsr3ContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr3ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationContextCreate"]
    pub fn FrameInterpolationContextCreate(
        context: *mut FrameInterpolationContext,
        contextDescription: *mut FrameInterpolationContextDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationContextGetGpuMemoryUsage"]
    pub fn FrameInterpolationContextGetGpuMemoryUsage(
        pContext: *mut FrameInterpolationContext,
        vramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationGetSharedResourceDescriptions"]
    pub fn FrameInterpolationGetSharedResourceDescriptions(
        pContext: *mut FrameInterpolationContext,
        SharedResources: *mut FrameInterpolationSharedResourceDescriptions,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxSharedContextGetGpuMemoryUsage"]
    pub fn SharedContextGetGpuMemoryUsage(
        backendInterfaceShared: *mut Interface,
        vramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameInterpolationPrepareDescription {
    #[doc = "< combination of FfxFrameInterpolationDispatchFlags"]
    pub flags: u32,
    #[doc = "< The <c><i>FfxCommandList</i></c> to record frame interpolation commands into."]
    pub commandList: CommandList,
    #[doc = "< The dimensions used to render game content, dilatedDepth, dilatedMotionVectors are expected to be of ths size."]
    pub renderSize: Dimensions2D,
    #[doc = "< The subpixel jitter offset applied to the camera.     jitter;"]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors.     motionVectorScale;"]
    pub motionVectorScale: FloatCoords2D,
    pub frameTimeDelta: f32,
    pub cameraNear: f32,
    pub cameraFar: f32,
    pub viewSpaceToMetersFactor: f32,
    pub cameraFovAngleVertical: f32,
    #[doc = "< The depth buffer data"]
    pub depth: Resource,
    #[doc = "< The motion vector data"]
    pub motionVectors: Resource,
    pub frameID: u64,
    #[doc = "< The dilated depth buffer data"]
    pub dilatedDepth: Resource,
    #[doc = "< The dilated motion vector data"]
    pub dilatedMotionVectors: Resource,
    #[doc = "< The reconstructed depth buffer data"]
    pub reconstructedPrevDepth: Resource,
    #[doc = "< The camera position in world space"]
    pub cameraPosition: Float32x3,
    #[doc = "< The camera up normalized vector in world space."]
    pub cameraUp: Float32x3,
    #[doc = "< The camera right normalized vector in world space."]
    pub cameraRight: Float32x3,
    #[doc = "< The camera forward normalized vector in world space."]
    pub cameraForward: Float32x3,
}
impl Default for FrameInterpolationPrepareDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationPrepare"]
    pub fn FrameInterpolationPrepare(
        context: *mut FrameInterpolationContext,
        params: *const FrameInterpolationPrepareDescription,
    ) -> ErrorCode;
}
#[doc = "< A bit indicating that the debug tear lines will be drawn to the interpolated output."]
pub const FFX_FRAMEINTERPOLATION_DISPATCH_DRAW_DEBUG_TEAR_LINES: FrameInterpolationDispatchFlags =
    1;
#[doc = "< A bit indicating that the debug reset indicators will be drawn to the generated output."]
pub const FFX_FRAMEINTERPOLATION_DISPATCH_DRAW_DEBUG_RESET_INDICATORS:
    FrameInterpolationDispatchFlags = 2;
#[doc = "< A bit indicating that the interpolated output resource will contain debug views with relevant information."]
pub const FFX_FRAMEINTERPOLATION_DISPATCH_DRAW_DEBUG_VIEW: FrameInterpolationDispatchFlags = 4;
#[doc = "< A bit indicating that the debug pacing lines will be drawn to the generated output."]
pub const FFX_FRAMEINTERPOLATION_DISPATCH_DRAW_DEBUG_PACING_LINES: FrameInterpolationDispatchFlags =
    8;
pub const FFX_FRAMEINTERPOLATION_DISPATCH_RESERVED_1: FrameInterpolationDispatchFlags = 16;
pub const FFX_FRAMEINTERPOLATION_DISPATCH_RESERVED_2: FrameInterpolationDispatchFlags = 32;
pub type FrameInterpolationDispatchFlags = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameInterpolationDispatchDescription {
    #[doc = "< combination of FfxFrameInterpolationDispatchFlags"]
    pub flags: u32,
    #[doc = "< The <c><i>FfxCommandList</i></c> to record frame interpolation commands into."]
    pub commandList: CommandList,
    #[doc = "< The destination output dimensions"]
    pub displaySize: Dimensions2D,
    #[doc = "< The dimensions used to render game content, dilatedDepth, dilatedMotionVectors are expected to be of ths size."]
    pub renderSize: Dimensions2D,
    #[doc = "< The current presentation color, if currentBackBuffer_HUDLess is not used, this will be used as interpolation source data."]
    pub currentBackBuffer: Resource,
    #[doc = "< The current presentation color without HUD content, when use it will be used as interpolation source data."]
    pub currentBackBuffer_HUDLess: Resource,
    #[doc = "< The output resource where to store the interpolated result."]
    pub output: Resource,
    #[doc = "< The area of the backbuffer that should be used for interpolation in case only a part of the screen is used e.g. due to movie bars"]
    pub interpolationRect: Rect2D,
    #[doc = "< The optical flow motion vectors (see example computation in the FfxOpticalFlow effect)"]
    pub opticalFlowVector: Resource,
    #[doc = "< The optical flow scene change detection data"]
    pub opticalFlowSceneChangeDetection: Resource,
    #[doc = "< The optical flow motion vector resource dimensions"]
    pub opticalFlowBufferSize: Dimensions2D,
    #[doc = "< The optical flow motion vector scale factor, used to scale resoure values into [0.0,1.0] range."]
    pub opticalFlowScale: FloatCoords2D,
    #[doc = "< The optical flow block dimension size"]
    pub opticalFlowBlockSize: ::std::os::raw::c_int,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The unit to scale view space coordinates to meters."]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The transfer function use to convert interpolation source color data to linear RGB."]
    pub backBufferTransferFunction: BackbufferTransferFunction,
    #[doc = "< Min and max luminance values, used when converting HDR colors to linear RGB"]
    pub minMaxLuminance: [f32; 2usize],
    #[doc = "< Identifier used to select internal resources when async support is enabled. Must increment by exactly one (1) for each frame. Any non-exactly-one difference will reset the frame generation logic."]
    pub frameID: u64,
    #[doc = "< The dilated depth buffer data"]
    pub dilatedDepth: Resource,
    #[doc = "< The dilated motion vector data"]
    pub dilatedMotionVectors: Resource,
    #[doc = "< The reconstructed depth buffer data"]
    pub reconstructedPrevDepth: Resource,
    #[doc = "< A resource containing distortion offset data used when distortion post effects are enabled."]
    pub distortionField: Resource,
}
impl Default for FrameInterpolationDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}ffxFrameInterpolationDispatch"]
    pub fn FrameInterpolationDispatch(
        context: *mut FrameInterpolationContext,
        params: *const FrameInterpolationDispatchDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationContextDestroy"]
    pub fn FrameInterpolationContextDestroy(context: *mut FrameInterpolationContext) -> ErrorCode;
}
extern "C" {
    #[doc = " Queries the effect version number.\n\n @returns\n The SDK version the effect was built with.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationGetEffectVersion"]
    pub fn FrameInterpolationGetEffectVersion() -> VersionNumber;
}
extern "C" {
    #[doc = " Set global debug message settings\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup FRAMEINTERPOLATION"]
    #[link_name = "\u{1}ffxFrameInterpolationSetGlobalDebugMessage"]
    pub fn FrameInterpolationSetGlobalDebugMessage(
        fpMessage: MessageCallback,
        debugLevel: u32,
    ) -> ErrorCode;
}
pub const FFX_OPTICALFLOW_PASS_PREPARE_LUMA: OpticalflowPass = 0;
pub const FFX_OPTICALFLOW_PASS_GENERATE_OPTICAL_FLOW_INPUT_PYRAMID: OpticalflowPass = 1;
pub const FFX_OPTICALFLOW_PASS_GENERATE_SCD_HISTOGRAM: OpticalflowPass = 2;
pub const FFX_OPTICALFLOW_PASS_COMPUTE_SCD_DIVERGENCE: OpticalflowPass = 3;
pub const FFX_OPTICALFLOW_PASS_COMPUTE_OPTICAL_FLOW_ADVANCED_V5: OpticalflowPass = 4;
pub const FFX_OPTICALFLOW_PASS_FILTER_OPTICAL_FLOW_V5: OpticalflowPass = 5;
pub const FFX_OPTICALFLOW_PASS_SCALE_OPTICAL_FLOW_ADVANCED_V5: OpticalflowPass = 6;
pub const FFX_OPTICALFLOW_PASS_COUNT: OpticalflowPass = 7;
#[doc = " An enumeration of all the passes which constitute the OpticalFlow algorithm.\n\n @ingroup ffxOpticalflow"]
pub type OpticalflowPass = ::std::os::raw::c_int;
pub const FFX_OPTICALFLOW_ENABLE_TEXTURE1D_USAGE: OpticalflowInitializationFlagBits = 1;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxOpticalflowContext</i></c>. See <c><i>FfxOpticalflowDispatchDescription</i></c>.\n\n @ingroup ffxOpticalflow"]
pub type OpticalflowInitializationFlagBits = ::std::os::raw::c_int;
#[doc = " A structure encapsulating the parameters required to initialize\n FidelityFX OpticalFlow.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpticalflowContextDescription {
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterface: Interface,
    #[doc = "< A collection of <c><i>FfxOpticalflowInitializationFlagBits</i></c>."]
    pub flags: u32,
    pub resolution: Dimensions2D,
}
impl Default for OpticalflowContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Opticalflow.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpticalflowDispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the input color buffer"]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output motion buffer"]
    pub opticalFlowVector: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output scene change detection buffer"]
    pub opticalFlowSCD: Resource,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    pub backbufferTransferFunction: ::std::os::raw::c_int,
    pub minMaxLuminance: FloatCoords2D,
}
impl Default for OpticalflowDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OpticalflowSharedResourceDescriptions {
    pub opticalFlowVector: CreateResourceDescription,
    pub opticalFlowSCD: CreateResourceDescription,
}
impl Default for OpticalflowSharedResourceDescriptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX OpticalFlow context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by OpticalFlow.\n\n The <c><i>FfxOpticalflowContext</i></c> object should have a lifetime matching\n your use of OpticalFlow. Before destroying the OpticalFlow context care should be taken\n to ensure the GPU is not accessing the resources created or used by OpticalFlow.\n It is therefore recommended that the GPU is idle before destroying OpticalFlow\n OpticalFlow context.\n\n @ingroup ffxOpticalflow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpticalflowContext {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 131072usize],
}
impl Default for OpticalflowContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX OpticalFlow context from the parameters\n programmed to the <c><i>FfxOpticalflowContextDescription</i></c> structure.\n\n The context structure is the main object used to interact with the OpticalFlow\n API, and is responsible for the management of the internal resources used\n by the OpticalFlow algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by OpticalFlow's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxOpticalflowContext</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxOpticalflowContext</i></c> how match the configuration of your\n application as well as the intended use of OpticalFlow. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxOpticalflowContextDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how OpticalFlow should be integerated into an application.\n\n When the <c><i>FfxOpticalflowContext</i></c> is created, you should use the\n <c><i>ffxOpticalflowContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxOpticalflowContextDispatch</i></c> for more details.\n\n The <c><i>FfxOpticalflowContext</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or OpticalFlow is\n disabled by a user. To destroy the OpticalFlow context you should call\n <c><i>ffxOpticalflowContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxOpticalflowContext</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxOpticalflowContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxOpticalflowContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup ffxOpticalflow"]
    #[link_name = "\u{1}ffxOpticalflowContextCreate"]
    pub fn OpticalflowContextCreate(
        context: *mut OpticalflowContext,
        contextDescription: *mut OpticalflowContextDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxOpticalflowContextGetGpuMemoryUsage"]
    pub fn OpticalflowContextGetGpuMemoryUsage(
        pContext: *mut OpticalflowContext,
        vramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxOpticalflowGetSharedResourceDescriptions"]
    pub fn OpticalflowGetSharedResourceDescriptions(
        context: *mut OpticalflowContext,
        SharedResources: *mut OpticalflowSharedResourceDescriptions,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxOpticalflowContextDispatch"]
    pub fn OpticalflowContextDispatch(
        context: *mut OpticalflowContext,
        dispatchDescription: *const OpticalflowDispatchDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX OpticalFlow context.\n\n @param [out] context                A pointer to a <c><i>FfxOpticalflowContext</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup ffxOpticalflow"]
    #[link_name = "\u{1}ffxOpticalflowContextDestroy"]
    pub fn OpticalflowContextDestroy(context: *mut OpticalflowContext) -> ErrorCode;
}
extern "C" {
    #[doc = " Queries the effect version number.\n\n @returns\n The SDK version the effect was built with.\n\n @ingroup ffxOpticalflow"]
    #[link_name = "\u{1}ffxOpticalflowGetEffectVersion"]
    pub fn OpticalflowGetEffectVersion() -> VersionNumber;
}
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
pub const FFX_FSR3_QUALITY_MODE_QUALITY: Fsr3QualityMode = 1;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
pub const FFX_FSR3_QUALITY_MODE_BALANCED: Fsr3QualityMode = 2;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
pub const FFX_FSR3_QUALITY_MODE_PERFORMANCE: Fsr3QualityMode = 3;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
pub const FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE: Fsr3QualityMode = 4;
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 2 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR3. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup FSR3"]
pub type Fsr3QualityMode = ::std::os::raw::c_int;
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating if the input color data provided to all inputs is using a high-dynamic range."]
    pub const FFX_FSR3_ENABLE_HIGH_DYNAMIC_RANGE: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(1);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
    pub const FFX_FSR3_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(2);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
    pub const FFX_FSR3_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(4);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const FFX_FSR3_ENABLE_DEPTH_INVERTED: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(8);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const FFX_FSR3_ENABLE_DEPTH_INFINITE: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(16);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
    pub const FFX_FSR3_ENABLE_AUTO_EXPOSURE: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(32);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
    pub const FFX_FSR3_ENABLE_DYNAMIC_RESOLUTION: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(64);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< This value is deprecated, but remains in order to aid upgrading from older versions of FSR3."]
    pub const FFX_FSR3_ENABLE_TEXTURE1D_USAGE: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(128);
}
impl Fsr3InitializationFlagBits {
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const FFX_FSR3_ENABLE_DEBUG_CHECKING: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(256);
}
impl Fsr3InitializationFlagBits {
    pub const FFX_FSR3_ENABLE_UPSCALING_ONLY: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(512);
}
impl Fsr3InitializationFlagBits {
    #[doc = ", A bit indicating that the context will only be used for upscaling"]
    pub const FFX_FSR3_ENABLE_HDR_UPSCALE_SDR_FINALOUTPUT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(1024);
}
impl Fsr3InitializationFlagBits {
    #[doc = ", A bit indicating if the input color data provided to UPSCALE is using a high-dynamic range, final output SDR."]
    pub const FFX_FSR3_ENABLE_SDR_UPSCALE_HDR_FINALOUTPUT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(2048);
}
impl Fsr3InitializationFlagBits {
    #[doc = ", A bit indicating if the input color data provided to UPSCALE is using SDR, final output is high-dynamic range."]
    pub const FFX_FSR3_ENABLE_ASYNC_WORKLOAD_SUPPORT: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(4096);
}
impl Fsr3InitializationFlagBits {
    #[doc = ", A bit indicating if the input color data provided to UPSCALE is using SDR, final output is high-dynamic range."]
    pub const FFX_FSR3_ENABLE_INTERPOLATION_ONLY: Fsr3InitializationFlagBits =
        Fsr3InitializationFlagBits(8192);
}
impl ::std::ops::BitOr<Fsr3InitializationFlagBits> for Fsr3InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        Fsr3InitializationFlagBits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for Fsr3InitializationFlagBits {
    #[inline]
    fn bitor_assign(&mut self, rhs: Fsr3InitializationFlagBits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<Fsr3InitializationFlagBits> for Fsr3InitializationFlagBits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Fsr3InitializationFlagBits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for Fsr3InitializationFlagBits {
    #[inline]
    fn bitand_assign(&mut self, rhs: Fsr3InitializationFlagBits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr3Context</i></c>. See <c><i>FfxFsr3ContextDescription</i></c>.\n\n @ingroup FSR3"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Fsr3InitializationFlagBits(pub ::std::os::raw::c_int);
#[doc = "< A bit indicating that the debug tear lines will be drawn to the interpolated output."]
pub const FFX_FSR3_FRAME_GENERATION_FLAG_DRAW_DEBUG_TEAR_LINES: Fsr3FrameGenerationFlags = 1;
#[doc = "< A bit indicating that the interpolated output resource will contain debug views with relevant information."]
pub const FFX_FSR3_FRAME_GENERATION_FLAG_DRAW_DEBUG_VIEW: Fsr3FrameGenerationFlags = 4;
#[doc = "< A bit indicating that the debug pacing lines will be drawn to the generated output."]
pub const FFX_FSR3_FRAME_GENERATION_FLAG_DRAW_DEBUG_PACING_LINES: Fsr3FrameGenerationFlags = 8;
pub type Fsr3FrameGenerationFlags = ::std::os::raw::c_int;
#[doc = "< A bit indicating that the upscaled output resource will contain debug views with relevant information."]
pub const FFX_FSR3_UPSCALER_FLAG_DRAW_DEBUG_VIEW: Fsr3UpscalingFlags = 1;
pub type Fsr3UpscalingFlags = ::std::os::raw::c_int;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 3 upscaling.\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3ContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr3InitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub maxUpscaleSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the frame interpolation process."]
    pub displaySize: Dimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceSharedResources: Interface,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceUpscaling: Interface,
    #[doc = "< A set of pointers to the backend implementation for FidelityFX SDK"]
    pub backendInterfaceFrameInterpolation: Interface,
    #[doc = "< A pointer to a function that can receive messages from the runtime."]
    pub fpMessage: Fsr3UpscalerMessage,
    #[doc = "< The format of the swapchain surface"]
    pub backBufferFormat: SurfaceFormat,
}
impl Default for Fsr3ContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 3.\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3DispatchUpscaleDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub upscaleOutput: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< The resolution that the upscaler will output."]
    pub upscaleSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< combination of FfxFsr3UpscalingFlags"]
    pub flags: u32,
    pub frameID: u64,
}
impl Default for Fsr3DispatchUpscaleDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3DispatchFrameGenerationPrepareDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    pub frameTimeDelta: f32,
    pub cameraNear: f32,
    pub cameraFar: f32,
    pub viewSpaceToMetersFactor: f32,
    pub cameraFovAngleVertical: f32,
    pub frameID: u64,
}
impl Default for Fsr3DispatchFrameGenerationPrepareDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[link_name = "\u{1}ffxFsr3DispatchFrameGeneration"]
    pub fn Fsr3DispatchFrameGeneration(
        desc: *const FrameGenerationDispatchDescription,
    ) -> ErrorCode;
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Fsr3GenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR3 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for Fsr3GenerateReactiveDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 3 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR3.\n\n The <c><i>FfxFsr3Context</i></c> object should have a lifetime matching\n your use of FSR3. Before destroying the FSR3 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR3.\n It is therefore recommended that the GPU is idle before destroying the\n FSR3 context.\n\n @ingroup FSR3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fsr3Context {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 524288usize],
}
impl Default for Fsr3Context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 3 context from the parameters\n programmed to the <c><i>FfxFsr3CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR3\n API, and is responsible for the management of the internal resources used\n by the FSR3 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR3's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr3Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr3Context</i></c> how match the configuration of your\n application as well as the intended use of FSR3. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr3DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR3 should be integerated into an application.\n\n When the <c><i>FfxFsr3Context</i></c> is created, you should use the\n <c><i>ffxFsr3ContextDispatch</i></c> function each frame where FSR3\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr3ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr3Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR3 upscaling is\n disabled by a user. To destroy the FSR3 context you should call\n <c><i>ffxFsr3ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr3ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr3ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextCreate"]
    pub fn Fsr3ContextCreate(
        context: *mut Fsr3Context,
        contextDescription: *mut Fsr3ContextDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxFsr3ContextGetGpuMemoryUsage"]
    pub fn Fsr3ContextGetGpuMemoryUsage(
        pContext: *mut Fsr3Context,
        pUpscalerUsage: *mut EffectMemoryUsage,
        pOpticalFlowUsage: *mut EffectMemoryUsage,
        pFrameGenerationUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 3 Upscaling.\n\n FSR3 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr3ContextDispatchUpscale</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr3Context</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr3Context</i></c> correctly\n programming the <c><i>dispatchParams</i></c> is key to ensuring\n the correct operation of FSR3. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR3 provides the\n <c><i>ffxFsr3GetJitterPhaseCount</i></c> and\n <c><i>ffxFsr3GetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchParams</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr3GetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR3.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr3Context</i></c> structure.\n @param [in] dispatchParams     A pointer to a <c><i>FfxFsr3DispatchUpscaleDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchParams</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchParams.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextDispatchUpscale"]
    pub fn Fsr3ContextDispatchUpscale(
        context: *mut Fsr3Context,
        dispatchParams: *const Fsr3DispatchUpscaleDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxFsr3ContextDispatchFrameGenerationPrepare"]
    pub fn Fsr3ContextDispatchFrameGenerationPrepare(
        context: *mut Fsr3Context,
        dispatchParams: *const Fsr3DispatchFrameGenerationPrepareDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxFsr3SkipPresent"]
    pub fn Fsr3SkipPresent(context: *mut Fsr3Context) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr3Context</i></c> structure.\n @param [in] params                  A pointer to a <c><i>FfxFsr3GenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextGenerateReactiveMask"]
    pub fn Fsr3ContextGenerateReactiveMask(
        context: *mut Fsr3Context,
        params: *const Fsr3GenerateReactiveDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[link_name = "\u{1}ffxFsr3ConfigureFrameGeneration"]
    pub fn Fsr3ConfigureFrameGeneration(
        context: *mut Fsr3Context,
        config: *const FrameGenerationConfig,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr3Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ContextDestroy"]
    pub fn Fsr3ContextDestroy(context: *mut Fsr3Context) -> ErrorCode;
}
extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR3_QUALITY_MODE_NATIVEAA</i></c>          | 1.0x\n <c><i>FFX_FSR3_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR3_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR3_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetUpscaleRatioFromQualityMode"]
    pub fn Fsr3GetUpscaleRatioFromQualityMode(qualityMode: Fsr3QualityMode) -> f32;
}
extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr3GetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] renderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] renderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetRenderResolutionFromQualityMode"]
    pub fn Fsr3GetRenderResolutionFromQualityMode(
        renderWidth: *mut u32,
        renderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: Fsr3QualityMode,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr3GetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR3_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR3_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR3_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR3_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetJitterPhaseCount"]
    pub fn Fsr3GetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR3 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR3 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr3GetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr3GetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr3GetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr3GetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr3GetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr3GetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr3GetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr3GetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr3DispatchParameters</i></c> structure in order to inform FSR3\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr3GetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] outX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] outY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr3GetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetJitterOffset"]
    pub fn Fsr3GetJitterOffset(
        outX: *mut f32,
        outY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR3_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3ResourceIsNull"]
    pub fn Fsr3ResourceIsNull(resource: Resource) -> bool;
}
extern "C" {
    #[doc = " Queries the effect version number.\n\n @returns\n The SDK version the effect was built with.\n\n @ingroup FSR3"]
    #[link_name = "\u{1}ffxFsr3GetEffectVersion"]
    pub fn Fsr3GetEffectVersion() -> VersionNumber;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
