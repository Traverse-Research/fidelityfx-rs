/* automatically generated by rust-bindgen 0.72.1 */

pub const SDK_DEFAULT_CONTEXT_SIZE: u32 = 131072;
pub const MAX_NUM_SRVS: u32 = 64;
pub const MAX_NUM_UAVS: u32 = 64;
pub const MAX_NUM_CONST_BUFFERS: u32 = 3;
pub const RESOURCE_NAME_SIZE: u32 = 64;
pub const MAX_QUEUED_FRAMES: u32 = 4;
pub const MAX_RESOURCE_COUNT: u32 = 512;
pub const MAX_PASS_COUNT: u32 = 50;
pub const RING_BUFFER_DESCRIPTOR_COUNT: u32 = 102400;
pub const BUFFER_SIZE: u32 = 4096;
pub const CONSTANT_BUFFER_RING_BUFFER_SIZE: u32 = 819200;
pub const MAX_BARRIERS: u32 = 128;
pub const MAX_GPU_JOBS: u32 = 256;
pub const MAX_SAMPLERS: u32 = 16;
pub const UNSPECIFIED_VERSION: u32 = 4294946048;
pub const MAXIMUM_PATH: u32 = 260;
pub const SDK_VERSION_MAJOR: u32 = 1;
pub const SDK_VERSION_MINOR: u32 = 1;
pub const SDK_VERSION_PATCH: u32 = 4;
#[doc = " A typedef for version numbers returned from functions in the FidelityFX SDK.\n\n @ingroup CPUTypes"]
pub type VersionNumber = u32;
#[doc = " A typedef for a boolean value.\n\n @ingroup CPUTypes"]
pub type Boolean = bool;
#[doc = " A typedef for a unsigned 8bit integer.\n\n @ingroup CPUTypes"]
pub type UInt8 = u8;
#[doc = " A typedef for a unsigned 16bit integer.\n\n @ingroup CPUTypes"]
pub type UInt16 = u16;
#[doc = " A typedef for a unsigned 32bit integer.\n\n @ingroup CPUTypes"]
pub type UInt32 = u32;
#[doc = " A typedef for a unsigned 64bit integer.\n\n @ingroup CPUTypes"]
pub type UInt64 = u64;
#[doc = " A typedef for a signed 8bit integer.\n\n @ingroup CPUTypes"]
pub type Int8 = i8;
#[doc = " A typedef for a signed 16bit integer.\n\n @ingroup CPUTypes"]
pub type Int16 = i16;
#[doc = " A typedef for a signed 32bit integer.\n\n @ingroup CPUTypes"]
pub type Int32 = i32;
#[doc = " A typedef for a signed 64bit integer.\n\n @ingroup CPUTypes"]
pub type Int64 = i64;
#[doc = " A typedef for a floating point value.\n\n @ingroup CPUTypes"]
pub type Float32 = f32;
#[doc = " A typedef for a 2-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x2 = [f32; 2usize];
#[doc = " A typedef for a 3-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x3 = [f32; 3usize];
#[doc = " A typedef for a 4-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x4 = [f32; 4usize];
#[doc = " A typedef for a 4x4 floating point matrix.\n\n @ingroup CPUTypes"]
pub type Float32x4x4 = [f32; 16usize];
#[doc = " A typedef for a 2-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x2 = [u32; 2usize];
#[doc = " A typedef for a 3-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x3 = [u32; 3usize];
#[doc = " A typedef for a 4-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x4 = [u32; 4usize];
#[doc = " A typedef for a 2-dimensional 32bit signed integer.\n\n @ingroup CPUTypes"]
pub type Int32x2 = [i32; 2usize];
#[doc = " A typedef for a 3-dimensional 32bit signed integer.\n\n @ingroup CPUTypes"]
pub type Int32x3 = [i32; 3usize];
#[doc = " A typedef for a 4-dimensional 32bit signed integer.\n\n @ingroup CPUTypes"]
pub type Int32x4 = [i32; 4usize];
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of surface formats. Needs to match enum FfxApiSurfaceFormat\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SurfaceFormat {
    #[doc = "< Unknown format"]
    UNKNOWN = 0,
    #[doc = "< 32 bit per channel, 4 channel typeless format"]
    R32G32B32A32_TYPELESS = 1,
    #[doc = "< 32 bit per channel, 4 channel uint format"]
    R32G32B32A32_UINT = 2,
    #[doc = "< 32 bit per channel, 4 channel float format"]
    R32G32B32A32_FLOAT = 3,
    #[doc = "< 16 bit per channel, 4 channel float format"]
    R16G16B16A16_FLOAT = 4,
    #[doc = "< 32 bit per channel, 3 channel float format"]
    R32G32B32_FLOAT = 5,
    #[doc = "< 32 bit per channel, 2 channel float format"]
    R32G32_FLOAT = 6,
    #[doc = "< 8 bit per channel, 1 channel float format"]
    R8_UINT = 7,
    #[doc = "< 32 bit per channel, 1 channel float format"]
    R32_UINT = 8,
    #[doc = "<  8 bit per channel, 4 channel typeless format"]
    R8G8B8A8_TYPELESS = 9,
    #[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
    R8G8B8A8_UNORM = 10,
    #[doc = "<  8 bit per channel, 4 channel signed normalized format"]
    R8G8B8A8_SNORM = 11,
    #[doc = "<  8 bit per channel, 4 channel srgb normalized"]
    R8G8B8A8_SRGB = 12,
    #[doc = "<  8 bit per channel, 4 channel typeless format"]
    B8G8R8A8_TYPELESS = 13,
    #[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
    B8G8R8A8_UNORM = 14,
    #[doc = "<  8 bit per channel, 4 channel srgb normalized"]
    B8G8R8A8_SRGB = 15,
    #[doc = "< 32 bit 3 channel float format"]
    R11G11B10_FLOAT = 16,
    #[doc = "< 10 bit per 3 channel, 2 bit for 1 channel normalized format"]
    R10G10B10A2_UNORM = 17,
    #[doc = "< 16 bit per channel, 2 channel float format"]
    R16G16_FLOAT = 18,
    #[doc = "< 16 bit per channel, 2 channel unsigned int format"]
    R16G16_UINT = 19,
    #[doc = "< 16 bit per channel, 2 channel signed int format"]
    R16G16_SINT = 20,
    #[doc = "< 16 bit per channel, 1 channel float format"]
    R16_FLOAT = 21,
    #[doc = "< 16 bit per channel, 1 channel unsigned int format"]
    R16_UINT = 22,
    #[doc = "< 16 bit per channel, 1 channel unsigned normalized format"]
    R16_UNORM = 23,
    #[doc = "< 16 bit per channel, 1 channel signed normalized format"]
    R16_SNORM = 24,
    #[doc = "<  8 bit per channel, 1 channel unsigned normalized format"]
    R8_UNORM = 25,
    #[doc = "<  8 bit per channel, 2 channel unsigned normalized format"]
    R8G8_UNORM = 26,
    #[doc = "<  8 bit per channel, 2 channel unsigned integer format"]
    R8G8_UINT = 27,
    #[doc = "< 32 bit per channel, 1 channel float format"]
    R32_FLOAT = 28,
    #[doc = "<  9 bit per channel, 5 bit exponent format"]
    R9G9B9E5_SHAREDEXP = 29,
    #[doc = "< 16 bit per channel, 4 channel typeless format"]
    R16G16B16A16_TYPELESS = 30,
    #[doc = "< 32 bit per channel, 2 channel typeless format"]
    R32G32_TYPELESS = 31,
    #[doc = "< 10 bit per 3 channel, 2 bit for 1 channel typeless format"]
    R10G10B10A2_TYPELESS = 32,
    #[doc = "< 16 bit per channel, 2 channel typeless format"]
    R16G16_TYPELESS = 33,
    #[doc = "< 16 bit per channel, 1 channel typeless format"]
    R16_TYPELESS = 34,
    #[doc = "<  8 bit per channel, 1 channel typeless format"]
    R8_TYPELESS = 35,
    #[doc = "<  8 bit per channel, 2 channel typeless format"]
    R8G8_TYPELESS = 36,
    #[doc = "< 32 bit per channel, 1 channel typeless format"]
    R32_TYPELESS = 37,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IndexFormat {
    INDEX_TYPE_UINT32 = 0,
    INDEX_TYPE_UINT16 = 1,
}
impl ResourceUsage {
    #[doc = "< No usage flags indicate a resource is read only."]
    pub const READ_ONLY: ResourceUsage = ResourceUsage(0);
    #[doc = "< Indicates a resource will be used as render target."]
    pub const RENDERTARGET: ResourceUsage = ResourceUsage(1);
    #[doc = "< Indicates a resource will be used as UAV."]
    pub const UAV: ResourceUsage = ResourceUsage(2);
    #[doc = "< Indicates a resource will be used as depth target."]
    pub const DEPTHTARGET: ResourceUsage = ResourceUsage(4);
    #[doc = "< Indicates a resource will be used as indirect argument buffer"]
    pub const INDIRECT: ResourceUsage = ResourceUsage(8);
    #[doc = "< Indicates a resource that will generate array views. Works on 2D and cubemap textures"]
    pub const ARRAYVIEW: ResourceUsage = ResourceUsage(16);
    #[doc = "< Indicates a resource will be used as stencil target."]
    pub const STENCILTARGET: ResourceUsage = ResourceUsage(32);
    #[doc = "< Indicates a resource that should specify optimal render target memory access flags (for console use)"]
    pub const DCC_RENDERTARGET: ResourceUsage = ResourceUsage(32768);
}
impl ::std::ops::BitOr<ResourceUsage> for ResourceUsage {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceUsage(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceUsage {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceUsage) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceUsage> for ResourceUsage {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceUsage(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceUsage {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceUsage) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of resource usage.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceUsage(pub ::std::os::raw::c_int);
impl ResourceStates {
    pub const COMMON: ResourceStates = ResourceStates(1);
    #[doc = "< Indicates a resource is in the state to be used as UAV."]
    pub const UNORDERED_ACCESS: ResourceStates = ResourceStates(2);
    #[doc = "< Indicates a resource is in the state to be read by compute shaders."]
    pub const COMPUTE_READ: ResourceStates = ResourceStates(4);
    #[doc = "< Indicates a resource is in the state to be read by pixel shaders."]
    pub const PIXEL_READ: ResourceStates = ResourceStates(8);
    #[doc = "< Indicates a resource is in the state to be read by pixel or compute shaders."]
    pub const PIXEL_COMPUTE_READ: ResourceStates = ResourceStates(12);
    #[doc = "< Indicates a resource is in the state to be used as source in a copy command."]
    pub const COPY_SRC: ResourceStates = ResourceStates(16);
    #[doc = "< Indicates a resource is in the state to be used as destination in a copy command."]
    pub const COPY_DEST: ResourceStates = ResourceStates(32);
    #[doc = "< Indicates a resource is in generic (slow) read state."]
    pub const GENERIC_READ: ResourceStates = ResourceStates(20);
    #[doc = "< Indicates a resource is in the state to be used as an indirect command argument"]
    pub const INDIRECT_ARGUMENT: ResourceStates = ResourceStates(64);
    #[doc = "< Indicates a resource is in the state to be used to present to the swap chain"]
    pub const PRESENT: ResourceStates = ResourceStates(128);
    #[doc = "< Indicates a resource is in the state to be used as render target"]
    pub const RENDER_TARGET: ResourceStates = ResourceStates(256);
    #[doc = "< Indicates a resource is in the state to be used as depth attachment"]
    pub const DEPTH_ATTACHEMENT: ResourceStates = ResourceStates(512);
}
impl ::std::ops::BitOr<ResourceStates> for ResourceStates {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceStates(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceStates {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceStates) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceStates> for ResourceStates {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceStates(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceStates {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceStates) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of resource states.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceStates(pub ::std::os::raw::c_int);
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of surface dimensions.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceDimension {
    #[doc = "< A resource with a single dimension."]
    TEXTURE_1D = 0,
    #[doc = "< A resource with two dimensions."]
    TEXTURE_2D = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of resource view dimensions.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceViewDimension {
    #[doc = "< A resource view on a buffer."]
    BUFFER = 0,
    #[doc = "< A resource view on a single dimension."]
    TEXTURE_1D = 1,
    #[doc = "< A resource view on a single dimensional array."]
    TEXTURE_1D_ARRAY = 2,
    #[doc = "< A resource view on two dimensions."]
    TEXTURE_2D = 3,
    #[doc = "< A resource view on two dimensional array."]
    TEXTURE_2D_ARRAY = 4,
    #[doc = "< A resource view on three dimensions."]
    TEXTURE_3D = 5,
}
impl ResourceFlags {
    #[doc = "< No flags."]
    pub const NONE: ResourceFlags = ResourceFlags(0);
    #[doc = "< A bit indicating a resource does not need to persist across frames."]
    pub const ALIASABLE: ResourceFlags = ResourceFlags(1);
    #[doc = "< Special case flag used internally when importing resources that require additional setup"]
    pub const UNDEFINED: ResourceFlags = ResourceFlags(2);
}
impl ::std::ops::BitOr<ResourceFlags> for ResourceFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceFlags> for ResourceFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of surface dimensions.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceFlags(pub ::std::os::raw::c_int);
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all resource view types.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceViewType {
    #[doc = "< The resource view is an unordered access view (UAV)."]
    UNORDERED_ACCESS = 0,
    #[doc = "< The resource view is a shader resource view (SRV)."]
    SHADER_READ = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " The type of filtering to perform when reading a texture.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FilterType {
    #[doc = "< Point sampling."]
    MINMAGMIP_POINT = 0,
    #[doc = "< Sampling with interpolation."]
    MINMAGMIP_LINEAR = 1,
    #[doc = "< Use linear interpolation for minification and magnification; use point sampling for mip-level sampling."]
    MINMAGLINEARMIP_POINT = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " The address mode used when reading a texture.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AddressMode {
    #[doc = "< Wrap when reading texture."]
    WRAP = 0,
    #[doc = "< Mirror when reading texture."]
    MIRROR = 1,
    #[doc = "< Clamp when reading texture."]
    CLAMP = 2,
    #[doc = "< Border color when reading texture."]
    BORDER = 3,
    #[doc = "< Mirror once when reading texture."]
    MIRROR_ONCE = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all supported shader models.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ShaderModel {
    #[doc = "< Shader model 5.1."]
    _5_1 = 0,
    #[doc = "< Shader model 6.0."]
    _6_0 = 1,
    #[doc = "< Shader model 6.1."]
    _6_1 = 2,
    #[doc = "< Shader model 6.2."]
    _6_2 = 3,
    #[doc = "< Shader model 6.3."]
    _6_3 = 4,
    #[doc = "< Shader model 6.4."]
    _6_4 = 5,
    #[doc = "< Shader model 6.5."]
    _6_5 = 6,
    #[doc = "< Shader model 6.6."]
    _6_6 = 7,
    #[doc = "< Shader model 6.7."]
    _6_7 = 8,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceType {
    #[doc = "< The resource is a buffer."]
    BUFFER = 0,
    #[doc = "< The resource is a 1-dimensional texture."]
    TEXTURE1D = 1,
    #[doc = "< The resource is a 2-dimensional texture."]
    TEXTURE2D = 2,
    #[doc = "< The resource is a cube map."]
    TEXTURE_CUBE = 3,
    #[doc = "< The resource is a 3-dimensional texture."]
    TEXTURE3D = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for different heap types\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HeapType {
    #[doc = "< Local memory."]
    DEFAULT = 0,
    #[doc = "< Heap used for uploading resources."]
    UPLOAD = 1,
    #[doc = "< Heap used for reading back resources."]
    READBACK = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for different render job types\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GpuJobType {
    #[doc = "< The GPU job is performing a floating-point clear."]
    CLEAR_FLOAT = 0,
    #[doc = "< The GPU job is performing a copy."]
    COPY = 1,
    #[doc = "< The GPU job is performing a compute dispatch."]
    COMPUTE = 2,
    #[doc = "< The GPU job is performing a barrier."]
    BARRIER = 3,
    #[doc = "< The GPU job is performing a floating-point clear."]
    DISCARD = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for various descriptor types\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DescriptorType {
    TEXTURE_SRV = 0,
    BUFFER_SRV = 1,
    TEXTURE_UAV = 2,
    BUFFER_UAV = 3,
}
#[doc = " An enumeration for various descriptor types\n\n @ingroup SDKTypes"]
pub use self::DescriptorType as DescriptiorType;
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for view binding stages\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BindStage {
    PIXEL_SHADER_STAGE = 1,
    VERTEX_SHADER_STAGE = 2,
    COMPUTE_SHADER_STAGE = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for barrier types\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BarrierType {
    TRANSITION = 0,
    UAV = 1,
}
pub type MessageCallback =
    ::std::option::Option<unsafe extern "C" fn(type_: u32, message: *const u16)>;
impl MsgType {
    pub const ERROR: MsgType = MsgType(0);
    pub const WARNING: MsgType = MsgType(1);
    pub const COUNT: MsgType = MsgType(2);
}
#[repr(transparent)]
#[doc = " An enumeration for message types that can be passed\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MsgType(pub ::std::os::raw::c_int);
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the effects which constitute the FidelityFX SDK.\n\n Dictates what effect shader blobs to fetch for pipeline creation\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Effect {
    #[doc = "< FidelityFX Super Resolution v2"]
    FSR2 = 0,
    #[doc = "< FidelityFX Super Resolution"]
    FSR1 = 1,
    #[doc = "< FidelityFX Single Pass Downsampler"]
    SPD = 2,
    #[doc = "< FidelityFX Blur"]
    BLUR = 3,
    #[doc = "< FidelityFX Breadcrumbs"]
    BREADCRUMBS = 4,
    #[doc = "< FidelityFX Brixelizer"]
    BRIXELIZER = 5,
    #[doc = "< FidelityFX Brixelizer GI"]
    BRIXELIZER_GI = 6,
    #[doc = "< FidelityFX Combined Adaptive Compute Ambient Occlusion"]
    CACAO = 7,
    #[doc = "< FidelityFX Contrast Adaptive Sharpening"]
    CAS = 8,
    #[doc = "< FidelityFX Denoiser"]
    DENOISER = 9,
    #[doc = "< FidelityFX Lens"]
    LENS = 10,
    #[doc = "< FidelityFX Parallel Sort"]
    PARALLEL_SORT = 11,
    #[doc = "< FidelityFX Stochastic Screen Space Reflections"]
    SSSR = 12,
    #[doc = "< FidelityFX Variable Shading"]
    VARIABLE_SHADING = 13,
    #[doc = "< FidelityFX Luma Preserving Mapper"]
    LPM = 14,
    #[doc = "< FidelityFX Depth of Field"]
    DOF = 15,
    #[doc = "< FidelityFX Classifier"]
    CLASSIFIER = 16,
    #[doc = "< FidelityFX Super Resolution v3"]
    FSR3UPSCALER = 17,
    #[doc = "< FidelityFX Frame Interpolation, part of FidelityFX Super Resolution v3"]
    FRAMEINTERPOLATION = 18,
    #[doc = "< FidelityFX Optical Flow, part of FidelityFX Super Resolution v3"]
    OPTICALFLOW = 19,
    #[doc = "< FidelityFX Shared resources effect ID"]
    SHAREDRESOURCES = 127,
    #[doc = "< FidelityFX Shared backend context used with DLL API"]
    SHAREDAPIBACKEND = 128,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BackbufferTransferFunction {
    SRGB = 0,
    PQ = 1,
    SCRGB = 2,
}
#[doc = " A typedef representing the graphics device.\n\n @ingroup SDKTypes"]
pub type Device = *mut ::std::os::raw::c_void;
pub type CommandQueue = *mut ::std::os::raw::c_void;
pub type Swapchain = *mut ::std::os::raw::c_void;
#[doc = " A typedef representing a command list or command buffer.\n\n @ingroup SDKTypes"]
pub type CommandList = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a root signature.\n\n @ingroup SDKTypes"]
pub type RootSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a command signature, used for indirect workloads\n\n @ingroup SDKTypes"]
pub type CommandSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a pipeline state object.\n\n @ingroup SDKTypes"]
pub type Pipeline = *mut ::std::os::raw::c_void;
#[doc = " Allocate block of memory.\n\n The callback function for requesting memory of provided size.\n <c><i>size</i></c> cannot be 0.\n\n @param [in]  size               Size in bytes of memory to allocate.\n\n @retval\n NULL                            The operation failed.\n @retval\n Anything else                   The operation completed successfully.\n\n @ingroup SDKTypes"]
pub type AllocFunc =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
#[doc = " Reallocate block of memory.\n\n The callback function for reallocating provided block of memory to new location\n with specified size. When provided with <c><i>NULL</i></c> as <c><i>ptr</i></c>\n then it should behave as <c><i>FfxBreadcrumbsAllocFunc</i></c>.\n If the operation failed then contents of <c><i>ptr</i></c>\n cannot be changed. <c><i>size</i></c> cannot be 0.\n\n @param [in]  ptr                A pointer to previous block of memory.\n @param [in]  size               Size in bytes of memory to allocate.\n\n @retval\n NULL                            The operation failed.\n @retval\n Anything else                   The operation completed successfully.\n\n @ingroup SDKTypes"]
pub type ReallocFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Free block of memory.\n\n The callback function for freeing provided block of memory.\n <c><i>ptr</i></c> cannot be <c><i>NULL</i></c>.\n\n @param [in]  ptr                A pointer to block of memory.\n\n @ingroup SDKTypes"]
pub type FreeFunc = ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
#[doc = " A structure encapsulating a set of allocation callbacks.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AllocationCallbacks {
    #[doc = "< Callback for allocating memory in the library."]
    pub fpAlloc: AllocFunc,
    #[doc = "< Callback for reallocating memory in the library."]
    pub fpRealloc: ReallocFunc,
    #[doc = "< Callback for freeing allocated memory in the library."]
    pub fpFree: FreeFunc,
}
#[doc = " A structure encapsulating the bindless descriptor configuration of an effect.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EffectBindlessConfig {
    #[doc = "< Maximum number of texture SRVs needed in the bindless table."]
    pub maxTextureSrvs: u32,
    #[doc = "< Maximum number of buffer SRVs needed in the bindless table."]
    pub maxBufferSrvs: u32,
    #[doc = "< Maximum number of texture UAVs needed in the bindless table."]
    pub maxTextureUavs: u32,
    #[doc = "< Maximum number of buffer UAVs needed in the bindless table."]
    pub maxBufferUavs: u32,
}
#[doc = " A structure encapsulating a collection of device capabilities.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceCapabilities {
    #[doc = "< The maximum shader model supported by the device."]
    pub maximumSupportedShaderModel: ShaderModel,
    #[doc = "< The minimum supported wavefront width."]
    pub waveLaneCountMin: u32,
    #[doc = "< The maximum supported wavefront width."]
    pub waveLaneCountMax: u32,
    #[doc = "< The device supports FP16 in hardware."]
    pub fp16Supported: bool,
    #[doc = "< The device supports ray tracing."]
    pub raytracingSupported: bool,
    #[doc = "< The device supports AMD coherent memory."]
    pub deviceCoherentMemorySupported: bool,
    #[doc = "< The device supports dedicated allocations for resources."]
    pub dedicatedAllocationSupported: bool,
    #[doc = "< The device supports AMD buffer markers."]
    pub bufferMarkerSupported: bool,
    #[doc = "< The device supports extended synchronization mechanism."]
    pub extendedSynchronizationSupported: bool,
    #[doc = "< The device supports shader storage buffer array non uniform indexing."]
    pub shaderStorageBufferArrayNonUniformIndexing: bool,
}
impl Default for DeviceCapabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a 2-dimensional point, using 32bit unsigned integers.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Dimensions2D {
    #[doc = "< The width of a 2-dimensional range."]
    pub width: u32,
    #[doc = "< The height of a 2-dimensional range."]
    pub height: u32,
}
#[doc = " A structure encapsulating a 2-dimensional point.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: i32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: i32,
}
#[doc = " A structure encapsulating a 2-dimensional rect.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Rect2D {
    #[doc = "< Left most coordinate"]
    pub left: i32,
    #[doc = "< Top most coordinate"]
    pub top: i32,
    #[doc = "< Rect width"]
    pub width: i32,
    #[doc = "< Rect height"]
    pub height: i32,
}
#[doc = " A structure encapsulating a 2-dimensional set of floating point coordinates.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FloatCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: f32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: f32,
}
#[doc = " A structure describing a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResourceDescription {
    #[doc = "< The type of the resource."]
    pub type_: ResourceType,
    #[doc = "< The surface format."]
    pub format: SurfaceFormat,
    pub __bindgen_anon_1: ResourceDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ResourceDescription__bindgen_ty_2,
    pub __bindgen_anon_3: ResourceDescription__bindgen_ty_3,
    #[doc = "< Number of mips (or 0 for full mipchain)."]
    pub mipCount: u32,
    #[doc = "< A set of <c><i>FfxResourceFlags</i></c> flags."]
    pub flags: ResourceFlags,
    #[doc = "< Resource usage flags."]
    pub usage: ResourceUsage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_1 {
    #[doc = "< The width of the texture resource."]
    pub width: u32,
    #[doc = "< The size of the buffer resource."]
    pub size: u32,
}
impl Default for ResourceDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_2 {
    #[doc = "< The height of the texture resource."]
    pub height: u32,
    #[doc = "< The stride of the buffer resource."]
    pub stride: u32,
}
impl Default for ResourceDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_3 {
    #[doc = "< The depth of the texture resource."]
    pub depth: u32,
    #[doc = "< The alignment of the buffer resource."]
    pub alignment: u32,
}
impl Default for ResourceDescription__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An outward facing structure containing a resource\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Resource {
    #[doc = "< pointer to the resource."]
    pub resource: *mut ::std::os::raw::c_void,
    pub description: ResourceDescription,
    pub state: ResourceStates,
    #[doc = "< (optional) Resource name."]
    pub name: [u16; 64usize],
}
impl Default for Resource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a static resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StaticResourceDescription {
    #[doc = "< The resource to register."]
    pub resource: *const Resource,
    #[doc = "< The type of descriptor to create."]
    pub descriptorType: DescriptorType,
    #[doc = "< The destination index of the descriptor within the static table."]
    pub descriptorIndex: u32,
    pub __bindgen_anon_1: StaticResourceDescription__bindgen_ty_1,
    #[doc = "< The buffer size in bytes."]
    pub bufferSize: u32,
    #[doc = "< The buffer stride in bytes."]
    pub bufferStride: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union StaticResourceDescription__bindgen_ty_1 {
    #[doc = "< The buffer offset in bytes."]
    pub bufferOffset: u32,
    #[doc = "< The mip of the texture resource to create a UAV for."]
    pub textureUavMip: u32,
}
impl Default for StaticResourceDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for StaticResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a constant buffer allocation.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ConstantAllocation {
    #[doc = "< The resource representing the constant buffer resource."]
    pub resource: Resource,
    #[doc = "< The binding handle for the constant buffer"]
    pub handle: UInt64,
}
impl Default for ConstantAllocation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a constant buffer allocation.\n\n @ingroup SDKTypes"]
pub type RootConstantAllocation = ConstantAllocation;
#[doc = " A function definition for a constant buffer allocation callback\n\n Used to provide a constant buffer allocator to the calling backend\n\n @param [in] data                       The constant buffer data.\n @param [in] dataSize                   The size of the constant buffer data.\n\n\n @ingroup SDKTypes"]
pub type ConstantBufferAllocator = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, dataSize: UInt64) -> ConstantAllocation,
>;
#[doc = " Information about single AMD FidelityFX Breadcrumbs Library GPU memory block.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BreadcrumbsBlockData {
    #[doc = "< Pointer to CPU mapped GPU buffer memory."]
    pub memory: *mut ::std::os::raw::c_void,
    #[doc = "< GPU memory block handle."]
    pub heap: *mut ::std::os::raw::c_void,
    #[doc = "< GPU buffer handle for memory block."]
    pub buffer: *mut ::std::os::raw::c_void,
    #[doc = "< GPU address of memory block."]
    pub baseAddress: u64,
    #[doc = "< Index of next marker to be saved in memory block."]
    pub nextMarker: u32,
}
impl Default for BreadcrumbsBlockData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An internal structure containing a handle to a resource and resource views\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResourceInternal {
    #[doc = "< The index of the resource."]
    pub internalIndex: i32,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for resource init data types that can be passed\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceInitDataType {
    INVALID = 0,
    UNINITIALIZED = 1,
    BUFFER = 2,
    VALUE = 3,
}
#[doc = " An structure housing all that is needed for resource initialization\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResourceInitData {
    #[doc = "< Indicates that the resource will be initialized from a buffer or a value, or stay uninitialized."]
    pub type_: ResourceInitDataType,
    #[doc = "< The size, in bytes, of the resource that needed be initialized."]
    pub size: usize,
    pub __bindgen_anon_1: ResourceInitData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceInitData__bindgen_ty_1 {
    #[doc = "< The buffer used to initialize the resource."]
    pub buffer: *mut ::std::os::raw::c_void,
    #[doc = "< Indicates that the resource will be filled up with this value."]
    pub value: ::std::os::raw::c_uchar,
}
impl Default for ResourceInitData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ResourceInitData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An internal structure housing all that is needed for backend resource descriptions\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternalResourceDescription {
    #[doc = "< Resource identifier"]
    pub id: u32,
    #[doc = "< Name to set to the resource for easier debugging"]
    pub name: *const u16,
    #[doc = "< The type of resource (see <c><i>FfxResourceType</i></c>)"]
    pub type_: ResourceType,
    #[doc = "< Resource usage flags (see <c><i>FfxResourceUsage</i></c>)"]
    pub usage: ResourceUsage,
    #[doc = "< The resource format to use"]
    pub format: SurfaceFormat,
    #[doc = "< The width (textures) or size (buffers) of the resource"]
    pub width: u32,
    #[doc = "< The height (textures) or stride (buffers) of the resource"]
    pub height: u32,
    #[doc = "< Mip count (textures) of the resource"]
    pub mipCount: u32,
    #[doc = "< Resource flags (see <c><i>FfxResourceFlags</i></c>)"]
    pub flags: ResourceFlags,
    #[doc = "< Resource initialization definition (see <c><i>FfxResourceInitData</i></c>)"]
    pub initData: ResourceInitData,
}
impl Default for InternalResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure defining the view to create\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ViewDescription {
    #[doc = "< Indicates that the view is a UAV."]
    pub uavView: bool,
    #[doc = "< The view dimension to map"]
    pub viewDimension: ResourceViewDimension,
    pub __bindgen_anon_1: ViewDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ViewDescription__bindgen_ty_2,
    #[doc = "< The first slice to map to, (-1) for default first slice"]
    pub firstSlice: i32,
    pub name: [u16; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ViewDescription__bindgen_ty_1 {
    #[doc = "< The mip level of the view, (-1) for default"]
    pub mipLevel: i32,
    #[doc = "< The first element of a buffer view, (-1) for default"]
    pub firstElement: i32,
}
impl Default for ViewDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ViewDescription__bindgen_ty_2 {
    #[doc = "< The array size of the view, (-1) for full depth/array size"]
    pub arraySize: i32,
    #[doc = "< The number of elements in a buffer view, (-1) for full depth/array size"]
    pub elementCount: i32,
}
impl Default for ViewDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ViewDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}s_FfxViewDescInit"]
    pub static mut s_ViewDescInit: ViewDescription;
}
#[doc = " A structure defining a resource bind point\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceBinding {
    #[doc = "< The slot into which to bind the resource"]
    pub slotIndex: u32,
    #[doc = "< The resource offset for mip/array access"]
    pub arrayIndex: u32,
    #[doc = "< A unique resource identifier representing an internal resource index"]
    pub resourceIdentifier: u32,
    #[doc = "< A debug name to help track the resource binding"]
    pub name: [u16; 64usize],
}
impl Default for ResourceBinding {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a single pass of an algorithm.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineState {
    #[doc = "< The pipelines rootSignature"]
    pub rootSignature: RootSignature,
    #[doc = "< The id of the effect pass this pipeline corresponds to"]
    pub passId: u32,
    #[doc = "< The command signature used for indirect workloads"]
    pub cmdSignature: CommandSignature,
    #[doc = "< The pipeline object"]
    pub pipeline: Pipeline,
    #[doc = "< Count of Texture UAVs used in this pipeline"]
    pub uavTextureCount: u32,
    #[doc = "< Count of Texture SRVs used in this pipeline"]
    pub srvTextureCount: u32,
    #[doc = "< Count of Buffer SRV used in this pipeline"]
    pub srvBufferCount: u32,
    #[doc = "< Count of Buffer UAVs used in this pipeline"]
    pub uavBufferCount: u32,
    #[doc = "< Count of static Texture SRVs used in this pipeline"]
    pub staticTextureSrvCount: u32,
    #[doc = "< Count of static Buffer SRVs used in this pipeline"]
    pub staticBufferSrvCount: u32,
    #[doc = "< Count of static Texture UAVs used in this pipeline"]
    pub staticTextureUavCount: u32,
    #[doc = "< Count of static Buffer UAVs used in this pipeline"]
    pub staticBufferUavCount: u32,
    #[doc = "< Count of constant buffers used in this pipeline"]
    pub constCount: u32,
    #[doc = "< Array of ResourceIdentifiers bound as texture UAVs"]
    pub uavTextureBindings: [ResourceBinding; 64usize],
    #[doc = "< Array of ResourceIdentifiers bound as texture SRVs"]
    pub srvTextureBindings: [ResourceBinding; 64usize],
    #[doc = "< Array of ResourceIdentifiers bound as buffer SRVs"]
    pub srvBufferBindings: [ResourceBinding; 64usize],
    #[doc = "< Array of ResourceIdentifiers bound as buffer UAVs"]
    pub uavBufferBindings: [ResourceBinding; 64usize],
    #[doc = "< Array of ResourceIdentifiers bound as CBs"]
    pub constantBufferBindings: [ResourceBinding; 3usize],
    #[doc = "< Pipeline name for debugging/profiling purposes"]
    pub name: [u16; 64usize],
}
impl Default for PipelineState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateResourceDescription {
    #[doc = "< The heap type to hold the resource, typically <c><i>FFX_HEAP_TYPE_DEFAULT</i></c>."]
    pub heapType: HeapType,
    #[doc = "< A resource description."]
    pub resourceDescription: ResourceDescription,
    #[doc = "< The initial resource state."]
    pub initialState: ResourceStates,
    #[doc = "< Name of the resource."]
    pub name: *const u16,
    #[doc = "< Internal resource ID."]
    pub id: u32,
    #[doc = "< A struct used to initialize the resource."]
    pub initData: ResourceInitData,
}
impl Default for CreateResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create sampler mappings\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerDescription {
    pub filter: FilterType,
    pub addressModeU: AddressMode,
    pub addressModeV: AddressMode,
    pub addressModeW: AddressMode,
    pub stage: BindStage,
}
impl Default for SamplerDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create root constant buffer mappings\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootConstantDescription {
    pub size: u32,
    pub stage: BindStage,
}
impl Default for RootConstantDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the description used to create a\n <c><i>FfxPipeline</i></c> structure.\n\n A pipeline is the name given to a shader and the collection of state that\n is required to dispatch it. In the context of the FidelityFX SDK and its architecture\n this means that a <c><i>FfxPipelineDescription</i></c> will map to either a\n monolithic object in an explicit API (such as a\n <c><i>PipelineStateObject</i></c> in DirectX 12). Or a shader and some\n ancillary API objects (in something like DirectX 11).\n\n The <c><i>contextFlags</i></c> field contains a copy of the flags passed\n to <c><i>ffxContextCreate</i></c> via the <c><i>flags</i></c> field of\n the <c><i>Ffx<Effect>InitializationParams</i></c> structure. These flags are\n used to determine which permutation of a pipeline for a specific\n <c><i>Ffx<Effect>Pass</i></c> should be used to implement the features required\n by each application, as well as to achieve the best performance on specific\n target hardware configurations.\n\n When using one of the provided backends for FidelityFX SDK (such as DirectX 12 or\n Vulkan) the data required to create a pipeline is compiled off line and\n included into the backend library that you are using. For cases where the\n backend interface is overridden by providing custom callback function\n implementations care should be taken to respect the contents of the\n <c><i>contextFlags</i></c> field in order to correctly support the options\n provided by the FidelityFX SDK, and achieve best performance.\n ///\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDescription {
    #[doc = "< A collection of <c><i>FfxInitializationFlagBits</i></c> which were passed to the context."]
    pub contextFlags: u32,
    #[doc = "< A collection of samplers to use when building the root signature for the pipeline"]
    pub samplers: *const SamplerDescription,
    #[doc = "< Number of samplers to create for the pipeline"]
    pub samplerCount: usize,
    #[doc = "< A collection of root constant descriptions to use when building the root signature for the pipeline"]
    pub rootConstants: *const RootConstantDescription,
    #[doc = "< Number of root constant buffers to create for the pipeline"]
    pub rootConstantBufferCount: u32,
    #[doc = "< Pipeline name with which to name the pipeline object"]
    pub name: [u16; 64usize],
    #[doc = "< The stage(s) for which this pipeline is being built"]
    pub stage: BindStage,
    #[doc = "< Whether this pipeline has an indirect workload"]
    pub indirectWorkload: u32,
    #[doc = "< For raster pipelines this contains the backbuffer format"]
    pub backbufferFormat: SurfaceFormat,
}
impl Default for PipelineDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a barrier\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BarrierDescription {
    #[doc = "< The resource representation"]
    pub resource: ResourceInternal,
    #[doc = "< The type of barrier to execute"]
    pub barrierType: BarrierType,
    #[doc = "< The initial state of the resource"]
    pub currentState: ResourceStates,
    #[doc = "< The new state of the resource after barrier"]
    pub newState: ResourceStates,
    #[doc = "< The subresource id to apply barrier operation to"]
    pub subResourceID: u32,
}
impl Default for BarrierDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing a constant buffer.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstantBuffer {
    #[doc = "< The size (expressed in 32-bit chunks) stored in data."]
    pub num32BitEntries: u32,
    #[doc = "< Pointer to constant buffer data"]
    pub data: *mut u32,
}
impl Default for ConstantBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing a shader resource view."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TextureSRV {
    #[doc = "< Resource corresponding to the shader resource view."]
    pub resource: ResourceInternal,
}
#[doc = " A structure containing a shader resource view."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BufferSRV {
    #[doc = "< Offset of resource to bind in bytes."]
    pub offset: u32,
    #[doc = "< Size of resource to bind in bytes."]
    pub size: u32,
    #[doc = "< Size of resource to bind in bytes."]
    pub stride: u32,
    #[doc = "< Resource corresponding to the shader resource view."]
    pub resource: ResourceInternal,
}
#[doc = " A structure containing a unordered access view."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TextureUAV {
    #[doc = "< Mip level of resource to bind."]
    pub mip: u32,
    #[doc = "< Resource corresponding to the unordered access view."]
    pub resource: ResourceInternal,
}
#[doc = " A structure containing a unordered access view."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BufferUAV {
    #[doc = "< Offset of resource to bind in bytes."]
    pub offset: u32,
    #[doc = "< Size of resource to bind in bytes."]
    pub size: u32,
    #[doc = "< Size of resource to bind in bytes."]
    pub stride: u32,
    #[doc = "< Resource corresponding to the unordered access view."]
    pub resource: ResourceInternal,
}
#[doc = " A structure describing a clear render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ClearFloatJobDescription {
    #[doc = "< The clear color of the resource."]
    pub color: [f32; 4usize],
    #[doc = "< The resource to be cleared."]
    pub target: ResourceInternal,
}
#[doc = " A structure describing a compute render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComputeJobDescription {
    #[doc = "< Compute pipeline for the render job."]
    pub pipeline: PipelineState,
    #[doc = "< Dispatch dimensions."]
    pub dimensions: [u32; 3usize],
    #[doc = "< Dispatch indirect cmd argument buffer"]
    pub cmdArgument: ResourceInternal,
    #[doc = "< Dispatch indirect offset within the cmd argument buffer"]
    pub cmdArgumentOffset: u32,
    #[doc = "< SRV texture resources to be bound in the compute job."]
    pub srvTextures: [TextureSRV; 64usize],
    #[doc = "< SRV buffer resources to be bound in the compute job."]
    pub srvBuffers: [BufferSRV; 64usize],
    #[doc = "< UAV texture resources to be bound in the compute job."]
    pub uavTextures: [TextureUAV; 64usize],
    #[doc = "< UAV buffer resources to be bound in the compute job."]
    pub uavBuffers: [BufferUAV; 64usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 3usize],
}
impl Default for ComputeJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RasterJobDescription {
    #[doc = "< Raster pipeline for the render job."]
    pub pipeline: PipelineState,
    pub numVertices: u32,
    pub renderTarget: ResourceInternal,
    #[doc = "< SRV texture resources to be bound in the compute job."]
    pub srvTextures: [TextureSRV; 64usize],
    #[doc = "< UAV texture resources to be bound in the compute job."]
    pub uavTextures: [TextureUAV; 64usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 3usize],
}
impl Default for RasterJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a copy render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CopyJobDescription {
    #[doc = "< Source resource for the copy."]
    pub src: ResourceInternal,
    #[doc = "< Offset into the source buffer in bytes."]
    pub srcOffset: u32,
    #[doc = "< Destination resource for the copy."]
    pub dst: ResourceInternal,
    #[doc = "< Offset into the destination buffer in bytes."]
    pub dstOffset: u32,
    #[doc = "< Number of bytes to copy (Set to 0 to copy entire buffer)."]
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DiscardJobDescription {
    #[doc = "< The resource to be discarded."]
    pub target: ResourceInternal,
}
#[doc = " A structure describing a single render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GpuJobDescription {
    #[doc = "< Type of the job."]
    pub jobType: GpuJobType,
    #[doc = "< Job label for markers"]
    pub jobLabel: [u16; 64usize],
    pub __bindgen_anon_1: GpuJobDescription__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GpuJobDescription__bindgen_ty_1 {
    #[doc = "< Clear job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_CLEAR_FLOAT</i></c>."]
    pub clearJobDescriptor: ClearFloatJobDescription,
    #[doc = "< Copy job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COPY</i></c>."]
    pub copyJobDescriptor: CopyJobDescription,
    #[doc = "< Compute job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COMPUTE</i></c>."]
    pub computeJobDescriptor: ComputeJobDescription,
    pub rasterJobDescriptor: RasterJobDescription,
    pub barrierDescriptor: BarrierDescription,
    pub discardJobDescriptor: DiscardJobDescription,
}
impl Default for GpuJobDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GpuJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A single shader blob and a description of its resources.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderBlob {
    #[doc = "< A pointer to the blob"]
    pub data: *const u8,
    #[doc = "< Size in bytes."]
    pub size: u32,
    #[doc = "< Number of CBs."]
    pub cbvCount: u32,
    #[doc = "< Number of SRV Textures."]
    pub srvTextureCount: u32,
    #[doc = "< Number of UAV Textures."]
    pub uavTextureCount: u32,
    #[doc = "< Number of SRV Buffers."]
    pub srvBufferCount: u32,
    #[doc = "< Number of UAV Buffers."]
    pub uavBufferCount: u32,
    #[doc = "< Number of Samplers."]
    pub samplerCount: u32,
    #[doc = "< Number of RT Acceleration structures."]
    pub rtAccelStructCount: u32,
    pub boundConstantBufferNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound ConstantBuffers."]
    pub boundConstantBuffers: *const u32,
    #[doc = "< Pointer to an array of bound ConstantBuffer resource counts"]
    pub boundConstantBufferCounts: *const u32,
    #[doc = "< Pointer to an array of bound ConstantBuffer resource spaces"]
    pub boundConstantBufferSpaces: *const u32,
    pub boundSRVTextureNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound SRV resources."]
    pub boundSRVTextures: *const u32,
    #[doc = "< Pointer to an array of bound SRV resource counts"]
    pub boundSRVTextureCounts: *const u32,
    #[doc = "< Pointer to an array of bound SRV resource spaces"]
    pub boundSRVTextureSpaces: *const u32,
    pub boundUAVTextureNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound UAV texture resources."]
    pub boundUAVTextures: *const u32,
    #[doc = "< Pointer to an array of bound UAV texture resource counts"]
    pub boundUAVTextureCounts: *const u32,
    #[doc = "< Pointer to an array of bound UAV texture resource spaces"]
    pub boundUAVTextureSpaces: *const u32,
    pub boundSRVBufferNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound SRV buffer resources."]
    pub boundSRVBuffers: *const u32,
    #[doc = "< Pointer to an array of bound SRV buffer resource counts"]
    pub boundSRVBufferCounts: *const u32,
    #[doc = "< Pointer to an array of bound SRV buffer resource spaces"]
    pub boundSRVBufferSpaces: *const u32,
    pub boundUAVBufferNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound UAV buffer resources."]
    pub boundUAVBuffers: *const u32,
    #[doc = "< Pointer to an array of bound UAV buffer resource counts"]
    pub boundUAVBufferCounts: *const u32,
    #[doc = "< Pointer to an array of bound UAV buffer resource spaces"]
    pub boundUAVBufferSpaces: *const u32,
    pub boundSamplerNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound sampler resources."]
    pub boundSamplers: *const u32,
    #[doc = "< Pointer to an array of bound sampler resource counts"]
    pub boundSamplerCounts: *const u32,
    #[doc = "< Pointer to an array of bound sampler resource spaces"]
    pub boundSamplerSpaces: *const u32,
    pub boundRTAccelerationStructureNames: *mut *const ::std::os::raw::c_char,
    #[doc = "< Pointer to an array of bound UAV buffer resources."]
    pub boundRTAccelerationStructures: *const u32,
    #[doc = "< Pointer to an array of bound UAV buffer resource counts"]
    pub boundRTAccelerationStructureCounts: *const u32,
    #[doc = "< Pointer to an array of bound UAV buffer resource spaces"]
    pub boundRTAccelerationStructureSpaces: *const u32,
}
impl Default for ShaderBlob {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing the parameters passed from the\n presentation thread to the ui composition callback function.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentCallbackDescription {
    #[doc = "< The active device"]
    pub device: Device,
    #[doc = "< The command list on which to register render commands"]
    pub commandList: CommandList,
    #[doc = "< The backbuffer resource with scene information"]
    pub currentBackBuffer: Resource,
    #[doc = "< Optional UI texture (when doing backbuffer + ui blend)"]
    pub currentUI: Resource,
    #[doc = "< The swapchain target into which to render ui composition"]
    pub outputSwapChainBuffer: Resource,
    #[doc = "< Whether this is an interpolated or real frame"]
    pub isInterpolatedFrame: bool,
    #[doc = "< Toggles whether UI gets premultiplied alpha blending or not"]
    pub usePremulAlpha: bool,
    pub frameID: u64,
}
impl Default for PresentCallbackDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing the parameters to pass to frame generation passes.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameGenerationDispatchDescription {
    #[doc = "< The command list on which to register render commands"]
    pub commandList: CommandList,
    #[doc = "< The current presentation color, this will be used as interpolation source data."]
    pub presentColor: Resource,
    #[doc = "< Interpolation destination targets (1 for each frame in numInterpolatedFrames)"]
    pub outputs: [Resource; 4usize],
    #[doc = "< The number of frames to interpolate from the passed in color target"]
    pub numInterpolatedFrames: u32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The transfer function use to convert interpolation source color data to linear RGB."]
    pub backBufferTransferFunction: BackbufferTransferFunction,
    #[doc = "< Min and max luminance values, used when converting HDR colors to linear RGB"]
    pub minMaxLuminance: [f32; 2usize],
    #[doc = "< The area of the backbuffer that should be used for interpolation in case only a part of the screen is used e.g. due to movie bars"]
    pub interpolationRect: Rect2D,
    pub frameID: u64,
}
impl Default for FrameGenerationDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EffectMemoryUsage {
    pub totalUsageInBytes: u64,
    pub aliasableUsageInBytes: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SwapchainFramePacingTuning {
    pub safetyMarginInMs: f32,
    pub varianceFactor: f32,
    pub allowHybridSpin: bool,
    pub hybridSpinTime: u32,
    pub allowWaitForSingleObjectOnFence: bool,
}
#[doc = " The value of Pi.\n\n @ingroup Utils"]
pub const PI: f32 = 3.1415927410125732;
#[doc = " An epsilon value for floating point numbers.\n\n @ingroup Utils"]
pub const EPSILON: f32 = 0.0000009999999974752427;
#[doc = " A typedef for the callback function for assert printing.\n\n This can be used to re-route printing of assert messages from the FFX backend\n to another destination. For example instead of the default behaviour of printing\n the assert messages to the debugger's TTY the message can be re-routed to a\n MessageBox in a GUI application.\n\n @param [in] message                 The message generated by the assert.\n\n @ingroup Asserts"]
pub type AssertCallback =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
unsafe extern "C" {
    #[doc = " Function to report an assert.\n\n @param [in] file                    The name of the file as a string.\n @param [in] line                    The index of the line in the file.\n @param [in] condition               The boolean condition that was tested.\n @param [in] msg                     The optional message to print.\n\n @returns\n Always returns true.\n\n @ingroup Asserts"]
    #[link_name = "\u{1}ffxAssertReport"]
    pub fn AssertReport(
        file: *const ::std::os::raw::c_char,
        line: i32,
        condition: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Provides the ability to set a callback for assert messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n\n @ingroup Asserts"]
    #[link_name = "\u{1}ffxAssertSetPrintingCallback"]
    pub fn AssertSetPrintingCallback(callback: AssertCallback);
}
impl ErrorCodes {
    #[doc = "< The operation completed successfully."]
    pub const OK: ErrorCodes = ErrorCodes(0);
    #[doc = "< The operation failed due to an invalid pointer."]
    pub const ERROR_INVALID_POINTER: ErrorCodes = ErrorCodes(-2147483648);
    #[doc = "< The operation failed due to an invalid alignment."]
    pub const ERROR_INVALID_ALIGNMENT: ErrorCodes = ErrorCodes(-2147483647);
    #[doc = "< The operation failed due to an invalid size."]
    pub const ERROR_INVALID_SIZE: ErrorCodes = ErrorCodes(-2147483646);
    #[doc = "< The end of the file was encountered."]
    pub const EOF: ErrorCodes = ErrorCodes(-2147483645);
    #[doc = "< The operation failed because the specified path was invalid."]
    pub const ERROR_INVALID_PATH: ErrorCodes = ErrorCodes(-2147483644);
    #[doc = "< The operation failed because end of file was reached."]
    pub const ERROR_EOF: ErrorCodes = ErrorCodes(-2147483643);
    #[doc = "< The operation failed because of some malformed data."]
    pub const ERROR_MALFORMED_DATA: ErrorCodes = ErrorCodes(-2147483642);
    #[doc = "< The operation failed because it ran out memory."]
    pub const ERROR_OUT_OF_MEMORY: ErrorCodes = ErrorCodes(-2147483641);
    #[doc = "< The operation failed because the interface was not fully configured."]
    pub const ERROR_INCOMPLETE_INTERFACE: ErrorCodes = ErrorCodes(-2147483640);
    #[doc = "< The operation failed because of an invalid enumeration value."]
    pub const ERROR_INVALID_ENUM: ErrorCodes = ErrorCodes(-2147483639);
    #[doc = "< The operation failed because an argument was invalid."]
    pub const ERROR_INVALID_ARGUMENT: ErrorCodes = ErrorCodes(-2147483638);
    #[doc = "< The operation failed because a value was out of range."]
    pub const ERROR_OUT_OF_RANGE: ErrorCodes = ErrorCodes(-2147483637);
    #[doc = "< The operation failed because a device was null."]
    pub const ERROR_NULL_DEVICE: ErrorCodes = ErrorCodes(-2147483636);
    #[doc = "< The operation failed because the backend API returned an error code."]
    pub const ERROR_BACKEND_API_ERROR: ErrorCodes = ErrorCodes(-2147483635);
    #[doc = "< The operation failed because there was not enough memory."]
    pub const ERROR_INSUFFICIENT_MEMORY: ErrorCodes = ErrorCodes(-2147483634);
    #[doc = "< The operation failed because the wrong backend was linked."]
    pub const ERROR_INVALID_VERSION: ErrorCodes = ErrorCodes(-2147483633);
    #[doc = "< The operation failed because access to the resource was denied."]
    pub const ERROR_ACCESS_DENIED: ErrorCodes = ErrorCodes(-2147483632);
}
#[repr(transparent)]
#[doc = " Error codes and their meaning\n\n @ingroup Errors"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ErrorCodes(pub ::std::os::raw::c_int);
unsafe extern "C" {
    #[doc = " Provides the ability to set a callback for print messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n\n @ingroup Messages"]
    #[link_name = "\u{1}ffxSetPrintMessageCallback"]
    pub fn SetPrintMessageCallback(callback: MessageCallback, debugLevel: u32);
}
unsafe extern "C" {
    #[doc = " Function to print a message.\n\n @param [in] type                    See FfxMsgType\n @param [in] message                 The message to print.\n\n @ingroup Messages"]
    #[link_name = "\u{1}ffxPrintMessage"]
    pub fn PrintMessage(type_: u32, message: *const u16);
}
#[doc = " Stand in type for FfxPass\n\n These will be defined for each effect individually (i.e. FfxFsr2Pass).\n They are used to fetch the proper blob index to build effect shaders\n\n @ingroup FfxInterface"]
pub type Pass = u32;
#[doc = " Get the SDK version of the backend context.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n\n @returns\n The SDK version a backend was built with.\n\n @ingroup FfxInterface"]
pub type GetSDKVersionFunc =
    ::std::option::Option<unsafe extern "C" fn(backendInterface: *mut Interface) -> VersionNumber>;
#[doc = " Get effect VRAM usage.\n\n Newer effects may require support that legacy versions of the SDK will not be\n able to provide. A version query is thus required to ensure an effect component\n will always be paired with a backend which will support all needed functionality.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n @param [in]  effectContextId                     The context space to be used for the effect in question.\n @param [out] outVramUsage                        The effect memory usage structure to fill out.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type GetEffectGpuMemoryUsageFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effectContextId: UInt32,
        outVramUsage: *mut EffectMemoryUsage,
    ) -> ErrorCode,
>;
#[doc = " Create and initialize the backend context.\n\n The callback function sets up the backend context for rendering.\n It will create or reference the device and create required internal data structures.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n @param [in]  effect                              The effect the context is being created for\n @param [in]  bindlessConfig                      A pointer to the bindless configuration, if required by the effect.\n @param [out] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreateBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effect: Effect,
        bindlessConfig: *mut EffectBindlessConfig,
        effectContextId: *mut UInt32,
    ) -> ErrorCode,
>;
#[doc = " Get a list of capabilities of the device.\n\n When creating an <c><i>FfxEffectContext</i></c> it is desirable for the FFX\n core implementation to be aware of certain characteristics of the platform\n that is being targetted. This is because some optimizations which FFX SDK\n attempts to perform are more effective on certain classes of hardware than\n others, or are not supported by older hardware. In order to avoid cases\n where optimizations actually have the effect of decreasing performance, or\n reduce the breadth of support provided by FFX SDK, the FFX interface queries the\n capabilities of the device to make such decisions.\n\n For target platforms with fixed hardware support you need not implement\n this callback function by querying the device, but instead may hardcore\n what features are available on the platform.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] outDeviceCapabilities              The device capabilities structure to fill out.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type GetDeviceCapabilitiesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        outDeviceCapabilities: *mut DeviceCapabilities,
    ) -> ErrorCode,
>;
#[doc = " Destroy the backend context and dereference the device.\n\n This function is called when the <c><i>FfxEffectContext</i></c> is destroyed.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, effectContextId: UInt32) -> ErrorCode,
>;
#[doc = " Create a resource.\n\n This callback is intended for the backend to create internal resources.\n\n Please note: It is also possible that the creation of resources might\n itself cause additional resources to be created by simply calling the\n <c><i>FfxCreateResourceFunc</i></c> function pointer again. This is\n useful when handling the initial creation of resources which must be\n initialized. The flow in such a case would be an initial call to create the\n CPU-side resource, another to create the GPU-side resource, and then a call\n to schedule a copy render job to move the data between the two. Typically\n this type of function call flow is only seen during the creation of an\n <c><i>FfxEffectContext</i></c>.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] createResourceDescription           A pointer to a <c><i>FfxCreateResourceDescription</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outResource                        A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreateResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        createResourceDescription: *const CreateResourceDescription,
        effectContextId: UInt32,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Register a resource in the backend for the current frame.\n\n Since the FfxInterface and the backends are not aware how many different\n resources will get passed in over time, it's not safe\n to register all resources simultaneously in the backend.\n Also passed resources may not be valid after the dispatch call.\n As a result it's safest to register them as FfxResourceInternal\n and clear them at the end of the dispatch call.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] inResource                          A pointer to a <c><i>FfxResource</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outResource                        A pointer to a <c><i>FfxResourceInternal</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type RegisterResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        inResource: *const Resource,
        effectContextId: UInt32,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Get an FfxResource from an FfxResourceInternal resource.\n\n At times it is necessary to create an FfxResource representation\n of an internally created resource in order to register it with a\n child effect context. This function sets up the FfxResource needed\n to register.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            The <c><i>FfxResourceInternal</i></c> for which to setup an FfxResource.\n\n @returns\n An FfxResource built from the internal resource\n\n @ingroup FfxInterface"]
pub type GetResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, resource: ResourceInternal) -> Resource,
>;
#[doc = " Unregister all temporary FfxResourceInternal from the backend.\n\n Unregister FfxResourceInternal referencing resources passed to\n a function as a parameter.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type UnregisterResourcesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        commandList: CommandList,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Register a resource in the static bindless table of the backend.\n\n A static resource will persist in their respective bindless table until it is\n overwritten by a different resource at the same index.\n The calling code must take care not to immediately register a new resource at an index\n that might be in use by an in-flight frame.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] desc                                A pointer to an <c><i>FfxStaticResourceDescription</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type RegisterStaticResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        desc: *const StaticResourceDescription,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Retrieve a <c><i>FfxResourceDescription</i></c> matching a\n <c><i>FfxResource</i></c> structure.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @returns\n A description of the resource.\n\n @ingroup FfxInterface"]
pub type GetResourceDescriptionFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
    ) -> ResourceDescription,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Map resource memory\n\n Maps the memory of the resource to a pointer and returns it.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n @param [out] ptr                                A pointer to the mapped memory.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type MapResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ErrorCode,
>;
#[doc = " Unmap resource memory\n\n Unmaps previously mapped memory of a resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type UnmapResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, resource: ResourceInternal) -> ErrorCode,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type StageConstantBufferDataFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        data: *mut ::std::os::raw::c_void,
        size: UInt32,
        constantBuffer: *mut ConstantBuffer,
    ) -> ErrorCode,
>;
#[doc = " Create a render pipeline.\n\n A rendering pipeline contains the shader as well as resource bindpoints\n and samplers.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] pass                                The identifier for the pass.\n @param [in] pipelineDescription                 A pointer to a <c><i>FfxPipelineDescription</i></c> describing the pipeline to be created.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outPipeline                        A pointer to a <c><i>FfxPipelineState</i></c> structure which should be populated.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreatePipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effect: Effect,
        pass: Pass,
        permutationOptions: u32,
        pipelineDescription: *const PipelineDescription,
        effectContextId: UInt32,
        outPipeline: *mut PipelineState,
    ) -> ErrorCode,
>;
pub type GetPermutationBlobByIndexFunc = ::std::option::Option<
    unsafe extern "C" fn(
        effectId: Effect,
        passId: Pass,
        bindStage: BindStage,
        permutationOptions: u32,
        outBlob: *mut ShaderBlob,
    ) -> ErrorCode,
>;
#[doc = " Destroy a render pipeline.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] pipeline                           A pointer to a <c><i>FfxPipelineState</i></c> structure which should be released.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyPipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        pipeline: *mut PipelineState,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Schedule a render job to be executed on the next call of\n <c><i>FfxExecuteGpuJobsFunc</i></c>.\n\n Render jobs can perform one of three different tasks: clear, copy or\n compute dispatches.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] job                                 A pointer to a <c><i>FfxGpuJobDescription</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type ScheduleGpuJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        job: *const GpuJobDescription,
    ) -> ErrorCode,
>;
#[doc = " Execute scheduled render jobs on the <c><i>comandList</i></c> provided.\n\n The recording of the graphics API commands should take place in this\n callback function, the render jobs which were previously enqueued (via\n callbacks made to <c><i>FfxScheduleGpuJobFunc</i></c>) should be\n processed in the order they were received. Advanced users might choose to\n reorder the rendering jobs, but should do so with care to respect the\n resource dependencies.\n\n Depending on the precise contents of <c><i>FfxDispatchDescription</i></c> a\n different number of render jobs might have previously been enqueued (for\n example if sharpening is toggled on and off).\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type ExecuteGpuJobsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        commandList: CommandList,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UiCompositionFlags {
    #[doc = "< A bit indicating that we use premultiplied alpha for UI composition"]
    FLAG_USE_PREMUL_ALPHA = 1,
    #[doc = "< A bit indicating that the swapchain should doublebuffer the UI resource"]
    FLAG_ENABLE_INTERNAL_UI_DOUBLE_BUFFERING = 2,
}
pub type PresentCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        params: *const PresentCallbackDescription,
        arg1: *mut ::std::os::raw::c_void,
    ) -> ErrorCode,
>;
pub type FrameGenerationDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        params: *const FrameGenerationDispatchDescription,
        arg1: *mut ::std::os::raw::c_void,
    ) -> ErrorCode,
>;
pub type WaitCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(fenceName: *mut u16, fenceValueToWaitFor: u64) -> ErrorCode,
>;
#[doc = " A structure representing the configuration options to pass to FrameInterpolationSwapChain\n\n @ingroup FfxInterface"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameGenerationConfig {
    #[doc = "< The <c><i>FfxSwapchain</i></c> to use with frame interpolation"]
    pub swapChain: Swapchain,
    #[doc = "< A UI composition callback to call when finalizing the frame image"]
    pub presentCallback: PresentCallbackFunc,
    #[doc = "< A pointer to be passed to the UI composition callback"]
    pub presentCallbackContext: *mut ::std::os::raw::c_void,
    #[doc = "< The frame generation callback to use to generate the interpolated frame"]
    pub frameGenerationCallback: FrameGenerationDispatchFunc,
    #[doc = "< A pointer to be passed to the frame generation callback"]
    pub frameGenerationCallbackContext: *mut ::std::os::raw::c_void,
    #[doc = "< Sets the state of frame generation. Set to false to disable frame generation"]
    pub frameGenerationEnabled: bool,
    #[doc = "< Sets the state of async workloads. Set to true to enable interpolation work on async compute"]
    pub allowAsyncWorkloads: bool,
    #[doc = "< Sets the state of async presentation (console only). Set to true to enable present from async command queue"]
    pub allowAsyncPresent: bool,
    #[doc = "< The hudless back buffer image to use for UI extraction from backbuffer resource"]
    pub HUDLessColor: Resource,
    #[doc = "< Flags"]
    pub flags: UInt32,
    #[doc = "< Set to true to only present interpolated frame"]
    pub onlyPresentInterpolated: bool,
    #[doc = "< Set the area in the backbuffer that will be interpolated"]
    pub interpolationRect: Rect2D,
    #[doc = "< A frame identifier used to synchronize resource usage in workloads"]
    pub frameID: u64,
    #[doc = "< Sets the state of pacing debug lines. Set to true to display debug lines"]
    pub drawDebugPacingLines: bool,
}
impl Default for FrameGenerationConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SwapChainConfigureFrameGenerationFunc =
    ::std::option::Option<unsafe extern "C" fn(config: *const FrameGenerationConfig) -> ErrorCode>;
#[doc = " Allocate AMD FidelityFX Breadcrumbs Library markers buffer.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] blockBytes                          Size in bytes of the buffer to be allocated.\n @param [out] blockData                          Output information about allocated AMD FidelityFX Breadcrumbs Library buffer. Filled only on success of operation.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type BreadcrumbsAllocBlockFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        blockBytes: u64,
        blockData: *mut BreadcrumbsBlockData,
    ) -> ErrorCode,
>;
#[doc = " Deallocate AMD FidelityFX Breadcrumbs Library markers buffer.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] blockData                          Information about buffer to be freed. All resource handles are cleared after this operation.\n\n @ingroup FfxInterface"]
pub type BreadcrumbsFreeBlockFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, blockData: *mut BreadcrumbsBlockData),
>;
#[doc = " Write marker to AMD FidelityFX Breadcrumbs Library buffer on the <c><i>comandList</i></c> provided.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         GPU command list to record marker writing command.\n @param [in] value                               Marker value to be written.\n @param [in] gpuLocation                         GPU destination address where marker will be written.\n @param [in] gpuBuffer                           Destination AMD FidelityFX Breadcrumbs Library buffer.\n @param [in] isBegin                             <c><i>true</i></c> for writing opening marker and <c><i>false</i></c> for ending marker.\n\n @ingroup FfxInterface"]
pub type BreadcrumbsWriteFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        commandList: CommandList,
        value: u32,
        gpuLocation: u64,
        gpuBuffer: *mut ::std::os::raw::c_void,
        isBegin: bool,
    ),
>;
#[doc = " Printing GPU specific info to the AMD FidelityFX Breadcrumbs Library status buffer.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] allocs                              A pointer to the allocation callbacks.\n @param [in] extendedInfo                        <c><i>true</i></c> if should print more verbose device info and <c><i>false</i></c> for standard output.\n @param [out] printBuffer                        String buffer for writing GPU info.\n @param [out] printSize                          Size of string buffer for writing GPU info.\n\n @ingroup FfxInterface"]
pub type BreadcrumbsPrintDeviceInfoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        allocs: *mut AllocationCallbacks,
        extendedInfo: bool,
        printBuffer: *mut *mut ::std::os::raw::c_char,
        printSize: *mut usize,
    ),
>;
#[doc = " Register a <b>Thread Safe</b> constant buffer allocator to be used by the backend.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] constantAllocator                   An <c><i>FfxConstantBufferAllocator</i></c> callback to be used by the backend.\n\n @ingroup FfxInterface"]
pub type RegisterConstantBufferAllocatorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        constantAllocator: ConstantBufferAllocator,
    ),
>;
#[doc = " A structure encapsulating the interface between the core implementation of\n the FfxInterface and any graphics API that it should ultimately call.\n\n This set of functions serves as an abstraction layer between FfxInterfae and the\n API used to implement it. While the FidelityFX SDK ships with backends for DirectX12 and\n Vulkan, it is possible to implement your own backend for other platforms\n which sit on top of your engine's own abstraction layer. For details on the\n expectations of what each function should do you should refer the\n description of the following function pointer types:\n   - <c><i>FfxCreateDeviceFunc</i></c>\n   - <c><i>FfxGetDeviceCapabilitiesFunc</i></c>\n   - <c><i>FfxDestroyDeviceFunc</i></c>\n   - <c><i>FfxCreateResourceFunc</i></c>\n   - <c><i>FfxRegisterResourceFunc</i></c>\n   - <c><i>FfxGetResourceFunc</i></c>\n   - <c><i>FfxUnregisterResourcesFunc</i></c>\n   - <c><i>FfxGetResourceDescriptionFunc</i></c>\n   - <c><i>FfxDestroyResourceFunc</i></c>\n   - <c><i>FfxCreatePipelineFunc</i></c>\n   - <c><i>FfxDestroyPipelineFunc</i></c>\n   - <c><i>FfxScheduleGpuJobFunc</i></c>\n   - <c><i>FfxExecuteGpuJobsFunc</i></c>\n   - <c><i>FfxBeginMarkerFunc</i></c>\n   - <c><i>FfxEndMarkerFunc</i></c>\n   - <c><i>FfxRegisterConstantBufferAllocatorFunc</i></c>\n\n Depending on the graphics API that is abstracted by the backend, it may be\n required that the backend is to some extent stateful. To ensure that\n applications retain full control to manage the memory used by the FidelityFX SDK, the\n <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields are\n provided. A backend should provide a means of specifying how much scratch\n memory is required for its internal implementation (e.g: via a function\n or constant value). The application is then responsible for allocating that\n memory and providing it when setting up the SDK backend. Backends provided\n with the FidelityFX SDK do not perform dynamic memory allocations, and instead\n sub-allocate all memory from the scratch buffers provided.\n\n The <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields\n should be populated according to the requirements of each backend. For\n example, if using the DirectX 12 backend you should call the\n <c><i>ffxGetScratchMemorySizeDX12</i></c> function. It is not required\n that custom backend implementations use a scratch buffer.\n\n Any functional addition to this interface mandates a version\n bump to ensure full functionality across effects and backends.\n\n @ingroup FfxInterface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Interface {
    #[doc = "< A callback function to query the SDK version."]
    pub fpGetSDKVersion: GetSDKVersionFunc,
    #[doc = "< A callback function to query effect Gpu memory usage"]
    pub fpGetEffectGpuMemoryUsage: GetEffectGpuMemoryUsageFunc,
    #[doc = "< A callback function to create and initialize the backend context."]
    pub fpCreateBackendContext: CreateBackendContextFunc,
    #[doc = "< A callback function to query device capabilites."]
    pub fpGetDeviceCapabilities: GetDeviceCapabilitiesFunc,
    #[doc = "< A callback function to destroy the backendcontext. This also dereferences the device."]
    pub fpDestroyBackendContext: DestroyBackendContextFunc,
    #[doc = "< A callback function to create a resource."]
    pub fpCreateResource: CreateResourceFunc,
    #[doc = "< A callback function to register an external resource."]
    pub fpRegisterResource: RegisterResourceFunc,
    #[doc = "< A callback function to convert an internal resource to external resource type"]
    pub fpGetResource: GetResourceFunc,
    #[doc = "< A callback function to unregister external resource."]
    pub fpUnregisterResources: UnregisterResourcesFunc,
    #[doc = "< A callback function to register a static resource."]
    pub fpRegisterStaticResource: RegisterStaticResourceFunc,
    #[doc = "< A callback function to retrieve a resource description."]
    pub fpGetResourceDescription: GetResourceDescriptionFunc,
    #[doc = "< A callback function to destroy a resource."]
    pub fpDestroyResource: DestroyResourceFunc,
    #[doc = "< A callback function to map a resource."]
    pub fpMapResource: MapResourceFunc,
    #[doc = "< A callback function to unmap a resource."]
    pub fpUnmapResource: UnmapResourceFunc,
    #[doc = "< A callback function to copy constant buffer data into staging memory."]
    pub fpStageConstantBufferDataFunc: StageConstantBufferDataFunc,
    #[doc = "< A callback function to create a render or compute pipeline."]
    pub fpCreatePipeline: CreatePipelineFunc,
    #[doc = "< A callback function to destroy a render or compute pipeline."]
    pub fpDestroyPipeline: DestroyPipelineFunc,
    #[doc = "< A callback function to schedule a render job."]
    pub fpScheduleGpuJob: ScheduleGpuJobFunc,
    #[doc = "< A callback function to execute all queued render jobs."]
    pub fpExecuteGpuJobs: ExecuteGpuJobsFunc,
    #[doc = "< A callback function to allocate block of memory for AMD FidelityFX Breadcrumbs Library buffer."]
    pub fpBreadcrumbsAllocBlock: BreadcrumbsAllocBlockFunc,
    #[doc = "< A callback function to free AMD FidelityFX Breadcrumbs Library buffer."]
    pub fpBreadcrumbsFreeBlock: BreadcrumbsFreeBlockFunc,
    #[doc = "< A callback function to write marker into AMD FidelityFX Breadcrumbs Library."]
    pub fpBreadcrumbsWrite: BreadcrumbsWriteFunc,
    #[doc = "< A callback function to print active GPU info for AMD FidelityFX Breadcrumbs Library log."]
    pub fpBreadcrumbsPrintDeviceInfo: BreadcrumbsPrintDeviceInfoFunc,
    pub fpGetPermutationBlobByIndex: GetPermutationBlobByIndexFunc,
    #[doc = "< A callback function to configure swap chain present callback."]
    pub fpSwapChainConfigureFrameGeneration: SwapChainConfigureFrameGenerationFunc,
    #[doc = "< A callback function to register a custom <b>Thread Safe</b> constant buffer allocator."]
    pub fpRegisterConstantBufferAllocator: RegisterConstantBufferAllocatorFunc,
    #[doc = "< A preallocated buffer for memory utilized internally by the backend."]
    pub scratchBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the buffer pointed to by <c><i>scratchBuffer</i></c>."]
    pub scratchBufferSize: usize,
    #[doc = "< A backend specific device"]
    pub device: Device,
}
impl Default for Interface {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
