/* automatically generated by rust-bindgen 0.72.1 */

pub const SDK_DEFAULT_CONTEXT_SIZE: u32 = 131072;
pub const MAX_NUM_SRVS: u32 = 16;
pub const MAX_NUM_UAVS: u32 = 16;
pub const MAX_NUM_CONST_BUFFERS: u32 = 3;
pub const MAX_CONST_SIZE: u32 = 256;
pub const RESOURCE_NAME_SIZE: u32 = 64;
pub const MAX_QUEUED_FRAMES: u32 = 4;
pub const MAX_RESOURCE_COUNT: u32 = 128;
pub const MAX_PASS_COUNT: u32 = 50;
pub const RING_BUFFER_SIZE: u32 = 25600;
pub const BUFFER_SIZE: u32 = 768;
pub const RING_BUFFER_MEM_BLOCK_SIZE: u32 = 19660800;
pub const MAX_BARRIERS: u32 = 16;
pub const MAX_GPU_JOBS: u32 = 64;
pub const MAX_SAMPLERS: u32 = 16;
pub const UNSPECIFIED_VERSION: u32 = 4294946048;
pub const MAXIMUM_PATH: u32 = 260;
pub const SDK_VERSION_MAJOR: u32 = 1;
pub const SDK_VERSION_MINOR: u32 = 0;
pub const SDK_VERSION_PATCH: u32 = 1;
#[doc = " A typedef for a boolean value.\n\n @ingroup CPUTypes"]
pub type Boolean = bool;
#[doc = " A typedef for a unsigned 8bit integer.\n\n @ingroup CPUTypes"]
pub type UInt8 = u8;
#[doc = " A typedef for a unsigned 16bit integer.\n\n @ingroup CPUTypes"]
pub type UInt16 = u16;
#[doc = " A typedef for a unsigned 32bit integer.\n\n @ingroup CPUTypes"]
pub type UInt32 = u32;
#[doc = " A typedef for a unsigned 64bit integer.\n\n @ingroup CPUTypes"]
pub type UInt64 = u64;
#[doc = " A typedef for a signed 8bit integer.\n\n @ingroup CPUTypes"]
pub type Int8 = i8;
#[doc = " A typedef for a signed 16bit integer.\n\n @ingroup CPUTypes"]
pub type Int16 = i16;
#[doc = " A typedef for a signed 32bit integer.\n\n @ingroup CPUTypes"]
pub type Int32 = i32;
#[doc = " A typedef for a signed 64bit integer.\n\n @ingroup CPUTypes"]
pub type Int64 = i64;
#[doc = " A typedef for a floating point value.\n\n @ingroup CPUTypes"]
pub type Float32 = f32;
#[doc = " A typedef for a 2-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x2 = [f32; 2usize];
#[doc = " A typedef for a 3-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x3 = [f32; 3usize];
#[doc = " A typedef for a 4-dimensional floating point value.\n\n @ingroup CPUTypes"]
pub type Float32x4 = [f32; 4usize];
#[doc = " A typedef for a 2-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x2 = [u32; 2usize];
#[doc = " A typedef for a 3-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x3 = [u32; 3usize];
#[doc = " A typedef for a 4-dimensional 32bit unsigned integer.\n\n @ingroup CPUTypes"]
pub type UInt32x4 = [u32; 4usize];
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of surface formats.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SurfaceFormat {
    #[doc = "< Unknown format"]
    UNKNOWN = 0,
    #[doc = "< 32 bit per channel, 4 channel typeless format"]
    R32G32B32A32_TYPELESS = 1,
    #[doc = "< 32 bit per channel, 4 channel uint format"]
    R32G32B32A32_UINT = 2,
    #[doc = "< 32 bit per channel, 4 channel float format"]
    R32G32B32A32_FLOAT = 3,
    #[doc = "< 16 bit per channel, 4 channel float format"]
    R16G16B16A16_FLOAT = 4,
    #[doc = "< 32 bit per channel, 2 channel float format"]
    R32G32_FLOAT = 5,
    #[doc = "< 8 bit per channel, 1 channel float format"]
    R8_UINT = 6,
    #[doc = "< 32 bit per channel, 1 channel float format"]
    R32_UINT = 7,
    #[doc = "< 10 bit per RGB channel with 2 bit alpha, 4 channel unsigned normalized format"]
    R10G10B10A2_UNORM = 8,
    #[doc = "<  8 bit per channel, 4 channel float format"]
    R8G8B8A8_TYPELESS = 9,
    #[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
    R8G8B8A8_UNORM = 10,
    #[doc = "<  8 bit per channel, 4 channel signed normalized format"]
    R8G8B8A8_SNORM = 11,
    #[doc = "<  8 bit per channel, 4 channel srgb normalized"]
    R8G8B8A8_SRGB = 12,
    #[doc = "< 32 bit 3 channel float format"]
    R11G11B10_FLOAT = 13,
    #[doc = "< 16 bit per channel, 2 channel float format"]
    R16G16_FLOAT = 14,
    #[doc = "< 16 bit per channel, 2 channel unsigned int format"]
    R16G16_UINT = 15,
    #[doc = "< 16 bit per channel, 2 channel signed int format"]
    R16G16_SINT = 16,
    #[doc = "< 16 bit per channel, 1 channel float format"]
    R16_FLOAT = 17,
    #[doc = "< 16 bit per channel, 1 channel unsigned int format"]
    R16_UINT = 18,
    #[doc = "< 16 bit per channel, 1 channel unsigned normalized format"]
    R16_UNORM = 19,
    #[doc = "< 16 bit per channel, 1 channel signed normalized format"]
    R16_SNORM = 20,
    #[doc = "<  8 bit per channel, 1 channel unsigned normalized format"]
    R8_UNORM = 21,
    #[doc = "<  8 bit per channel, 2 channel unsigned normalized format"]
    R8G8_UNORM = 22,
    #[doc = "<  8 bit per channel, 2 channel unsigned integer format"]
    R8G8_UINT = 23,
    #[doc = "< 32 bit per channel, 1 channel float format"]
    R32_FLOAT = 24,
}
impl ResourceUsage {
    #[doc = "< No usage flags indicate a resource is read only."]
    pub const READ_ONLY: ResourceUsage = ResourceUsage(0);
    #[doc = "< Indicates a resource will be used as render target."]
    pub const RENDERTARGET: ResourceUsage = ResourceUsage(1);
    #[doc = "< Indicates a resource will be used as UAV."]
    pub const UAV: ResourceUsage = ResourceUsage(2);
    #[doc = "< Indicates a resource will be used as depth target."]
    pub const DEPTHTARGET: ResourceUsage = ResourceUsage(4);
    #[doc = "< Indicates a resource will be used as indirect argument buffer"]
    pub const INDIRECT: ResourceUsage = ResourceUsage(8);
    #[doc = "< Indicates a resource that will generate array views. Works on 2D and cubemap textures"]
    pub const ARRAYVIEW: ResourceUsage = ResourceUsage(16);
}
impl ::std::ops::BitOr<ResourceUsage> for ResourceUsage {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceUsage(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceUsage {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceUsage) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceUsage> for ResourceUsage {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceUsage(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceUsage {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceUsage) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of resource usage.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceUsage(pub ::std::os::raw::c_int);
impl ResourceStates {
    pub const COMMON: ResourceStates = ResourceStates(1);
    #[doc = "< Indicates a resource is in the state to be used as UAV."]
    pub const UNORDERED_ACCESS: ResourceStates = ResourceStates(2);
    #[doc = "< Indicates a resource is in the state to be read by compute shaders."]
    pub const COMPUTE_READ: ResourceStates = ResourceStates(4);
    #[doc = "< Indicates a resource is in the state to be read by pixel shaders."]
    pub const PIXEL_READ: ResourceStates = ResourceStates(8);
    #[doc = "< Indicates a resource is in the state to be read by pixel or compute shaders."]
    pub const PIXEL_COMPUTE_READ: ResourceStates = ResourceStates(12);
    #[doc = "< Indicates a resource is in the state to be used as source in a copy command."]
    pub const COPY_SRC: ResourceStates = ResourceStates(16);
    #[doc = "< Indicates a resource is in the state to be used as destination in a copy command."]
    pub const COPY_DEST: ResourceStates = ResourceStates(32);
    #[doc = "< Indicates a resource is in generic (slow) read state."]
    pub const GENERIC_READ: ResourceStates = ResourceStates(20);
    #[doc = "< Indicates a resource is in the state to be used as an indirect command argument"]
    pub const INDIRECT_ARGUMENT: ResourceStates = ResourceStates(64);
    #[doc = "< Indicates a resource is in the state to be used to present to the swap chain"]
    pub const PRESENT: ResourceStates = ResourceStates(128);
    #[doc = "< Indicates a resource is in the state to be used as render target"]
    pub const RENDER_TARGET: ResourceStates = ResourceStates(256);
}
impl ::std::ops::BitOr<ResourceStates> for ResourceStates {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceStates(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceStates {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceStates) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceStates> for ResourceStates {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceStates(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceStates {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceStates) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of resource states.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceStates(pub ::std::os::raw::c_int);
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of surface dimensions.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceDimension {
    #[doc = "< A resource with a single dimension."]
    TEXTURE_1D = 0,
    #[doc = "< A resource with two dimensions."]
    TEXTURE_2D = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of resource view dimensions.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceViewDimension {
    #[doc = "< A resource view on a buffer."]
    BUFFER = 0,
    #[doc = "< A resource view on a single dimension."]
    TEXTURE_1D = 1,
    #[doc = "< A resource view on a single dimensional array."]
    TEXTURE_1D_ARRAY = 2,
    #[doc = "< A resource view on two dimensions."]
    TEXTURE_2D = 3,
    #[doc = "< A resource view on two dimensional array."]
    TEXTURE_2D_ARRAY = 4,
    #[doc = "< A resource view on three dimensions."]
    TEXTURE_3D = 5,
}
impl ResourceFlags {
    #[doc = "< No flags."]
    pub const NONE: ResourceFlags = ResourceFlags(0);
    #[doc = "< A bit indicating a resource does not need to persist across frames."]
    pub const ALIASABLE: ResourceFlags = ResourceFlags(1);
    #[doc = "< Special case flag used internally when importing resources that require additional setup"]
    pub const UNDEFINED: ResourceFlags = ResourceFlags(2);
}
impl ::std::ops::BitOr<ResourceFlags> for ResourceFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ResourceFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ResourceFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ResourceFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ResourceFlags> for ResourceFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ResourceFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ResourceFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ResourceFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " An enumeration of surface dimensions.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceFlags(pub ::std::os::raw::c_int);
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all resource view types.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceViewType {
    #[doc = "< The resource view is an unordered access view (UAV)."]
    UNORDERED_ACCESS = 0,
    #[doc = "< The resource view is a shader resource view (SRV)."]
    SHADER_READ = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " The type of filtering to perform when reading a texture.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FilterType {
    #[doc = "< Point sampling."]
    MINMAGMIP_POINT = 0,
    #[doc = "< Sampling with interpolation."]
    MINMAGMIP_LINEAR = 1,
    #[doc = "< Use linear interpolation for minification and magnification; use point sampling for mip-level sampling."]
    MINMAGLINEARMIP_POINT = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " The address mode used when reading a texture.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AddressMode {
    #[doc = "< Wrap when reading texture."]
    WRAP = 0,
    #[doc = "< Mirror when reading texture."]
    MIRROR = 1,
    #[doc = "< Clamp when reading texture."]
    CLAMP = 2,
    #[doc = "< Border color when reading texture."]
    BORDER = 3,
    #[doc = "< Mirror once when reading texture."]
    MIRROR_ONCE = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all supported shader models.\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ShaderModel {
    #[doc = "< Shader model 5.1."]
    _5_1 = 0,
    #[doc = "< Shader model 6.0."]
    _6_0 = 1,
    #[doc = "< Shader model 6.1."]
    _6_1 = 2,
    #[doc = "< Shader model 6.2."]
    _6_2 = 3,
    #[doc = "< Shader model 6.3."]
    _6_3 = 4,
    #[doc = "< Shader model 6.4."]
    _6_4 = 5,
    #[doc = "< Shader model 6.5."]
    _6_5 = 6,
    #[doc = "< Shader model 6.6."]
    _6_6 = 7,
    #[doc = "< Shader model 6.7."]
    _6_7 = 8,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = "\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceType {
    #[doc = "< The resource is a buffer."]
    BUFFER = 0,
    #[doc = "< The resource is a 1-dimensional texture."]
    TEXTURE1D = 1,
    #[doc = "< The resource is a 2-dimensional texture."]
    TEXTURE2D = 2,
    #[doc = "< The resource is a cube map."]
    TEXTURE_CUBE = 3,
    #[doc = "< The resource is a 3-dimensional texture."]
    TEXTURE3D = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for different heap types\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HeapType {
    #[doc = "< Local memory."]
    DEFAULT = 0,
    #[doc = "< Heap used for uploading resources."]
    UPLOAD = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for different render job types\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GpuJobType {
    #[doc = "< The GPU job is performing a floating-point clear."]
    CLEAR_FLOAT = 0,
    #[doc = "< The GPU job is performing a copy."]
    COPY = 1,
    #[doc = "< The GPU job is performing a compute dispatch."]
    COMPUTE = 2,
    #[doc = "< The GPU job is performing a barrier."]
    BARRIER = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for various descriptor types\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DescriptorType {
    TEXTURE_SRV = 0,
    BUFFER_SRV = 1,
    TEXTURE_UAV = 2,
    BUFFER_UAV = 3,
}
#[doc = " An enumeration for various descriptor types\n\n @ingroup SDKTypes"]
pub use self::DescriptorType as DescriptiorType;
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for view binding stages\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BindStage {
    PIXEL_SHADER_STAGE = 1,
    VERTEX_SHADER_STAGE = 2,
    COMPUTE_SHADER_STAGE = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration for barrier types\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BarrierType {
    TRANSITION = 0,
    UAV = 1,
}
impl MsgType {
    pub const ERROR: MsgType = MsgType(0);
    pub const WARNING: MsgType = MsgType(1);
    pub const COUNT: MsgType = MsgType(2);
}
#[repr(transparent)]
#[doc = " An enumeration for message types that can be passed\n\n @ingroup SDKTypes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MsgType(pub ::std::os::raw::c_int);
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of all the effects which constitute the FidelityFX SDK.\n\n Dictates what effect shader blobs to fetch for pipeline creation\n\n @ingroup FfxInterface"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Effect {
    #[doc = "< FidelityFX Super Resolution v2"]
    FSR2 = 0,
    #[doc = "< FidelityFX Super Resolution"]
    FSR1 = 1,
    #[doc = "< FidelityFX Single Pass Downsampler"]
    SPD = 2,
    #[doc = "< FidelityFX Blur"]
    BLUR = 3,
    #[doc = "< FidelityFX Combined Adaptive Compute Ambient Occlusion"]
    CACAO = 4,
    #[doc = "< FidelityFX Contrast Adaptive Sharpening"]
    CAS = 5,
    #[doc = "< FidelityFX Denoiser"]
    DENOISER = 6,
    #[doc = "< FidelityFX Lens"]
    LENS = 7,
    #[doc = "< FidelityFX Parallel Sort"]
    PARALLEL_SORT = 8,
    #[doc = "< FidelityFX Stochastic Screen Space Reflections"]
    SSSR = 9,
    #[doc = "< FidelityFX Variable Shading"]
    VARIABLE_SHADING = 10,
    #[doc = "< FidelityFX Luma Preserving Mapper"]
    LPM = 11,
    #[doc = "< FidelityFX Depth of Field"]
    DOF = 12,
    #[doc = "< FidelityFX Classifier"]
    CLASSIFIER = 13,
    #[doc = "< FidelityFX Super Resolution v3"]
    FSR3UPSCALER = 14,
    #[doc = "< FidelityFX Frame Interpolation, part of FidelityFX Super Resolution v3"]
    FRAMEINTERPOLATION = 15,
    #[doc = "< FidelityFX Optical Flow, part of FidelityFX Super Resolution v3"]
    OPTICALFLOW = 16,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BackbufferTransferFunction {
    SRGB = 0,
    PQ = 1,
    SCRGB = 2,
}
#[doc = " A typedef representing the graphics device.\n\n @ingroup SDKTypes"]
pub type Device = *mut ::std::os::raw::c_void;
pub type CommandQueue = *mut ::std::os::raw::c_void;
pub type Swapchain = *mut ::std::os::raw::c_void;
#[doc = " A typedef representing a command list or command buffer.\n\n @ingroup SDKTypes"]
pub type CommandList = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a root signature.\n\n @ingroup SDKTypes"]
pub type RootSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a command signature, used for indirect workloads\n\n @ingroup SDKTypes"]
pub type CommandSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a pipeline state object.\n\n @ingroup SDKTypes"]
pub type Pipeline = *mut ::std::os::raw::c_void;
#[doc = " A structure encapsulating a collection of device capabilities.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceCapabilities {
    #[doc = "< The minimum shader model supported by the device."]
    pub minimumSupportedShaderModel: ShaderModel,
    #[doc = "< The minimum supported wavefront width."]
    pub waveLaneCountMin: u32,
    #[doc = "< The maximum supported wavefront width."]
    pub waveLaneCountMax: u32,
    #[doc = "< The device supports FP16 in hardware."]
    pub fp16Supported: bool,
    #[doc = "< The device supports ray tracing."]
    pub raytracingSupported: bool,
}
impl Default for DeviceCapabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a 2-dimensional point, using 32bit unsigned integers.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Dimensions2D {
    #[doc = "< The width of a 2-dimensional range."]
    pub width: u32,
    #[doc = "< The height of a 2-dimensional range."]
    pub height: u32,
}
#[doc = " A structure encapsulating a 2-dimensional point.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: i32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: i32,
}
#[doc = " A structure encapsulating a 2-dimensional rect.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Rect2D {
    pub left: i32,
    pub top: i32,
    pub width: i32,
    pub height: i32,
}
#[doc = " A structure encapsulating a 2-dimensional set of floating point coordinates.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FloatCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: f32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: f32,
}
#[doc = " A structure describing a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResourceDescription {
    #[doc = "< The type of the resource."]
    pub type_: ResourceType,
    #[doc = "< The surface format."]
    pub format: SurfaceFormat,
    pub __bindgen_anon_1: ResourceDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ResourceDescription__bindgen_ty_2,
    pub __bindgen_anon_3: ResourceDescription__bindgen_ty_3,
    #[doc = "< Number of mips (or 0 for full mipchain)."]
    pub mipCount: u32,
    #[doc = "< A set of <c><i>FfxResourceFlags</i></c> flags."]
    pub flags: ResourceFlags,
    #[doc = "< Resource usage flags."]
    pub usage: ResourceUsage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_1 {
    #[doc = "< The width of the texture resource."]
    pub width: u32,
    #[doc = "< The size of the buffer resource."]
    pub size: u32,
}
impl Default for ResourceDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_2 {
    #[doc = "< The height of the texture resource."]
    pub height: u32,
    #[doc = "< The stride of the buffer resource."]
    pub stride: u32,
}
impl Default for ResourceDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_3 {
    #[doc = "< The depth of the texture resource."]
    pub depth: u32,
    #[doc = "< The alignment of the buffer resource."]
    pub alignment: u32,
}
impl Default for ResourceDescription__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An outward facing structure containing a resource\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Resource {
    #[doc = "< pointer to the resource."]
    pub resource: *mut ::std::os::raw::c_void,
    pub description: ResourceDescription,
    pub state: ResourceStates,
    #[doc = "< (optional) Resource name."]
    pub name: [u16; 64usize],
}
impl Default for Resource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An internal structure containing a handle to a resource and resource views\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResourceInternal {
    #[doc = "< The index of the resource."]
    pub internalIndex: i32,
}
#[doc = " An internal structure housing all that is needed for backend resource descriptions\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InternalResourceDescription {
    pub id: u32,
    pub name: *const u16,
    pub type_: ResourceType,
    pub usage: ResourceUsage,
    pub format: SurfaceFormat,
    pub width: u32,
    pub height: u32,
    pub mipCount: u32,
    pub flags: ResourceFlags,
    pub initDataSize: u32,
    pub initData: *mut ::std::os::raw::c_void,
}
impl Default for InternalResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure defining the view to create\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ViewDescription {
    #[doc = "< Indicates that the view is a UAV."]
    pub uavView: bool,
    #[doc = "< The view dimension to map"]
    pub viewDimension: ResourceViewDimension,
    pub __bindgen_anon_1: ViewDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ViewDescription__bindgen_ty_2,
    #[doc = "< The first slice to map to, (-1) for default first slice"]
    pub firstSlice: i32,
    pub name: [u16; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ViewDescription__bindgen_ty_1 {
    #[doc = "< The mip level of the view, (-1) for default"]
    pub mipLevel: i32,
    #[doc = "< The first element of a buffer view, (-1) for default"]
    pub firstElement: i32,
}
impl Default for ViewDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ViewDescription__bindgen_ty_2 {
    #[doc = "< The array size of the view, (-1) for full depth/array size"]
    pub arraySize: i32,
    #[doc = "< The number of elements in a buffer view, (-1) for full depth/array size"]
    pub elementCount: i32,
}
impl Default for ViewDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ViewDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[link_name = "\u{1}s_FfxViewDescInit"]
    pub static mut s_ViewDescInit: ViewDescription;
}
#[doc = " A structure defining a resource bind point\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceBinding {
    pub slotIndex: u32,
    pub resourceIdentifier: u32,
    pub bindCount: u32,
    pub name: [u16; 64usize],
}
impl Default for ResourceBinding {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a single pass of an algorithm.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineState {
    #[doc = "< The pipelines rootSignature"]
    pub rootSignature: RootSignature,
    #[doc = "< The command signature used for indirect workloads"]
    pub cmdSignature: CommandSignature,
    #[doc = "< The pipeline object"]
    pub pipeline: Pipeline,
    #[doc = "< Count of Texture UAVs used in this pipeline"]
    pub uavTextureCount: u32,
    #[doc = "< Count of Texture SRVs used in this pipeline"]
    pub srvTextureCount: u32,
    #[doc = "< Count of Buffer SRV used in this pipeline"]
    pub srvBufferCount: u32,
    #[doc = "< Count of Buffer UAVs used in this pipeline"]
    pub uavBufferCount: u32,
    #[doc = "< Count of constant buffers used in this pipeline"]
    pub constCount: u32,
    #[doc = "< Array of ResourceIdentifiers bound as texture UAVs"]
    pub uavTextureBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as texture SRVs"]
    pub srvTextureBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as buffer SRVs"]
    pub srvBufferBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as buffer UAVs"]
    pub uavBufferBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as CBs"]
    pub constantBufferBindings: [ResourceBinding; 3usize],
}
impl Default for PipelineState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CreateResourceDescription {
    #[doc = "< The heap type to hold the resource, typically <c><i>FFX_HEAP_TYPE_DEFAULT</i></c>."]
    pub heapType: HeapType,
    #[doc = "< A resource description."]
    pub resourceDescription: ResourceDescription,
    #[doc = "< The initial resource state."]
    pub initalState: ResourceStates,
    #[doc = "< Size of initial data buffer."]
    pub initDataSize: u32,
    #[doc = "< Buffer containing data to fill the resource."]
    pub initData: *mut ::std::os::raw::c_void,
    #[doc = "< Name of the resource."]
    pub name: *const u16,
    #[doc = "< Internal resource ID."]
    pub id: u32,
}
impl Default for CreateResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create sampler mappings\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SamplerDescription {
    pub filter: FilterType,
    pub addressModeU: AddressMode,
    pub addressModeV: AddressMode,
    pub addressModeW: AddressMode,
    pub stage: BindStage,
}
impl Default for SamplerDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create root constant buffer mappings\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootConstantDescription {
    pub size: u32,
    pub stage: BindStage,
}
impl Default for RootConstantDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the description used to create a\n <c><i>FfxPipeline</i></c> structure.\n\n A pipeline is the name given to a shader and the collection of state that\n is required to dispatch it. In the context of the FidelityFX SDK and its architecture\n this means that a <c><i>FfxPipelineDescription</i></c> will map to either a\n monolithic object in an explicit API (such as a\n <c><i>PipelineStateObject</i></c> in DirectX 12). Or a shader and some\n ancillary API objects (in something like DirectX 11).\n\n The <c><i>contextFlags</i></c> field contains a copy of the flags passed\n to <c><i>ffxContextCreate</i></c> via the <c><i>flags</i></c> field of\n the <c><i>Ffx<Effect>InitializationParams</i></c> structure. These flags are\n used to determine which permutation of a pipeline for a specific\n <c><i>Ffx<Effect>Pass</i></c> should be used to implement the features required\n by each application, as well as to achieve the best performance on specific\n target hardware configurations.\n\n When using one of the provided backends for FidelityFX SDK (such as DirectX 12 or\n Vulkan) the data required to create a pipeline is compiled off line and\n included into the backend library that you are using. For cases where the\n backend interface is overridden by providing custom callback function\n implementations care should be taken to respect the contents of the\n <c><i>contextFlags</i></c> field in order to correctly support the options\n provided by the FidelityFX SDK, and achieve best performance.\n ///\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDescription {
    #[doc = "< A collection of <c><i>FfxInitializationFlagBits</i></c> which were passed to the context."]
    pub contextFlags: u32,
    #[doc = "< A collection of samplers to use when building the root signature for the pipeline"]
    pub samplers: *const SamplerDescription,
    #[doc = "< Number of samplers to create for the pipeline"]
    pub samplerCount: usize,
    #[doc = "< A collection of root constant descriptions to use when building the root signature for the pipeline"]
    pub rootConstants: *const RootConstantDescription,
    #[doc = "< Number of root constant buffers to create for the pipeline"]
    pub rootConstantBufferCount: u32,
    #[doc = "< Pipeline name with which to name the pipeline object"]
    pub name: [u16; 64usize],
    #[doc = "< The stage(s) for which this pipeline is being built"]
    pub stage: BindStage,
    #[doc = "< Whether this pipeline has an indirect workload"]
    pub indirectWorkload: u32,
    #[doc = "< For raster pipelines this contains the backbuffer format"]
    pub backbufferFormat: SurfaceFormat,
}
impl Default for PipelineDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a barrier\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BarrierDescription {
    pub resource: ResourceInternal,
    pub barrierType: BarrierType,
    pub currentState: ResourceStates,
    pub newState: ResourceStates,
    pub subResourceID: u32,
}
impl Default for BarrierDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing a constant buffer.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstantBuffer {
    #[doc = "< The size (expressed in 32-bit chunks) stored in data."]
    pub num32BitEntries: u32,
    #[doc = "< Constant buffer data"]
    pub data: [u32; 256usize],
}
impl Default for ConstantBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a clear render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ClearFloatJobDescription {
    #[doc = "< The clear color of the resource."]
    pub color: [f32; 4usize],
    #[doc = "< The resource to be cleared."]
    pub target: ResourceInternal,
}
#[doc = " A structure describing a compute render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ComputeJobDescription {
    #[doc = "< Compute pipeline for the render job."]
    pub pipeline: PipelineState,
    #[doc = "< Dispatch dimensions."]
    pub dimensions: [u32; 3usize],
    #[doc = "< Dispatch indirect cmd argument buffer"]
    pub cmdArgument: ResourceInternal,
    #[doc = "< Dispatch indirect offset within the cmd argument buffer"]
    pub cmdArgumentOffset: u32,
    #[doc = "< SRV texture resources to be bound in the compute job."]
    pub srvTextures: [ResourceInternal; 16usize],
    pub srvTextureNames: [[u16; 64usize]; 16usize],
    #[doc = "< UAV texture resources to be bound in the compute job."]
    pub uavTextures: [ResourceInternal; 16usize],
    #[doc = "< Mip level of UAV texture resources to be bound in the compute job."]
    pub uavTextureMips: [u32; 16usize],
    pub uavTextureNames: [[u16; 64usize]; 16usize],
    #[doc = "< SRV buffer resources to be bound in the compute job."]
    pub srvBuffers: [ResourceInternal; 16usize],
    pub srvBufferNames: [[u16; 64usize]; 16usize],
    #[doc = "< UAV buffer resources to be bound in the compute job."]
    pub uavBuffers: [ResourceInternal; 16usize],
    pub uavBufferNames: [[u16; 64usize]; 16usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 3usize],
    pub cbNames: [[u16; 64usize]; 3usize],
}
impl Default for ComputeJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RasterJobDescription {
    #[doc = "< Raster pipeline for the render job."]
    pub pipeline: PipelineState,
    pub numVertices: u32,
    pub renderTarget: ResourceInternal,
    #[doc = "< SRV resources to be bound in the compute job."]
    pub srvTextures: [ResourceInternal; 16usize],
    pub srvTextureNames: [[u16; 64usize]; 16usize],
    #[doc = "< UAV resources to be bound in the compute job."]
    pub uavTextures: [ResourceInternal; 16usize],
    #[doc = "< Mip level of UAV resources to be bound in the compute job."]
    pub uavTextureMips: [u32; 16usize],
    pub uavTextureNames: [[u16; 64usize]; 16usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 3usize],
    pub cbNames: [[u16; 64usize]; 3usize],
}
impl Default for RasterJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a copy render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CopyJobDescription {
    #[doc = "< Source resource for the copy."]
    pub src: ResourceInternal,
    #[doc = "< Destination resource for the copy."]
    pub dst: ResourceInternal,
}
#[doc = " A structure describing a single render job.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GpuJobDescription {
    #[doc = "< Type of the job."]
    pub jobType: GpuJobType,
    pub __bindgen_anon_1: GpuJobDescription__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GpuJobDescription__bindgen_ty_1 {
    #[doc = "< Clear job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_CLEAR_FLOAT</i></c>."]
    pub clearJobDescriptor: ClearFloatJobDescription,
    #[doc = "< Copy job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COPY</i></c>."]
    pub copyJobDescriptor: CopyJobDescription,
    #[doc = "< Compute job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COMPUTE</i></c>."]
    pub computeJobDescriptor: ComputeJobDescription,
    pub rasterJobDescriptor: RasterJobDescription,
    pub barrierDescriptor: BarrierDescription,
}
impl Default for GpuJobDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GpuJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderBlob {
    pub data: *const u8,
    pub size: u32,
    pub cbvCount: u32,
    pub srvTextureCount: u32,
    pub uavTextureCount: u32,
    pub srvBufferCount: u32,
    pub uavBufferCount: u32,
    pub samplerCount: u32,
    pub rtAccelStructCount: u32,
    pub boundConstantBufferNames: *mut *const ::std::os::raw::c_char,
    pub boundConstantBuffers: *const u32,
    pub boundConstantBufferCounts: *const u32,
    pub boundSRVTextureNames: *mut *const ::std::os::raw::c_char,
    pub boundSRVTextures: *const u32,
    pub boundSRVTextureCounts: *const u32,
    pub boundUAVTextureNames: *mut *const ::std::os::raw::c_char,
    pub boundUAVTextures: *const u32,
    pub boundUAVTextureCounts: *const u32,
    pub boundSRVBufferNames: *mut *const ::std::os::raw::c_char,
    pub boundSRVBuffers: *const u32,
    pub boundSRVBufferCounts: *const u32,
    pub boundUAVBufferNames: *mut *const ::std::os::raw::c_char,
    pub boundUAVBuffers: *const u32,
    pub boundUAVBufferCounts: *const u32,
    pub boundSamplerNames: *mut *const ::std::os::raw::c_char,
    pub boundSamplers: *const u32,
    pub boundSamplerCounts: *const u32,
    pub boundRTAccelerationStructureNames: *mut *const ::std::os::raw::c_char,
    pub boundRTAccelerationStructures: *const u32,
    pub boundRTAccelerationStructureCounts: *const u32,
}
impl Default for ShaderBlob {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PresentCallbackDescription {
    pub device: Device,
    pub commandList: CommandList,
    pub currentBackBuffer: Resource,
    pub currentUI: Resource,
    pub outputSwapChainBuffer: Resource,
    pub isInterpolatedFrame: bool,
}
impl Default for PresentCallbackDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameGenerationDispatchDescription {
    pub commandList: CommandList,
    pub presentColor: Resource,
    pub outputs: [Resource; 4usize],
    pub numInterpolatedFrames: u32,
    pub reset: bool,
    pub backBufferTransferFunction: BackbufferTransferFunction,
    pub minMaxLuminance: [f32; 2usize],
}
impl Default for FrameGenerationDispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The value of Pi.\n\n @ingroup Utils"]
pub const PI: f32 = 3.1415927410125732;
#[doc = " An epsilon value for floating point numbers.\n\n @ingroup Utils"]
pub const EPSILON: f32 = 0.0000009999999974752427;
#[doc = " A typedef for the callback function for assert printing.\n\n This can be used to re-route printing of assert messages from the FFX backend\n to another destination. For example instead of the default behaviour of printing\n the assert messages to the debugger's TTY the message can be re-routed to a\n MessageBox in a GUI application.\n\n @param [in] message                 The message generated by the assert.\n\n @ingroup Asserts"]
pub type AssertCallback =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
unsafe extern "C" {
    #[doc = " Function to report an assert.\n\n @param [in] file                    The name of the file as a string.\n @param [in] line                    The index of the line in the file.\n @param [in] condition               The boolean condition that was tested.\n @param [in] msg                     The optional message to print.\n\n @returns\n Always returns true.\n\n @ingroup Asserts"]
    #[link_name = "\u{1}ffxAssertReport"]
    pub fn AssertReport(
        file: *const ::std::os::raw::c_char,
        line: i32,
        condition: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Provides the ability to set a callback for assert messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n\n @ingroup Asserts"]
    #[link_name = "\u{1}ffxAssertSetPrintingCallback"]
    pub fn AssertSetPrintingCallback(callback: AssertCallback);
}
impl ErrorCodes {
    #[doc = "< The operation completed successfully."]
    pub const OK: ErrorCodes = ErrorCodes(0);
    #[doc = "< The operation failed due to an invalid pointer."]
    pub const ERROR_INVALID_POINTER: ErrorCodes = ErrorCodes(-2147483648);
    #[doc = "< The operation failed due to an invalid alignment."]
    pub const ERROR_INVALID_ALIGNMENT: ErrorCodes = ErrorCodes(-2147483647);
    #[doc = "< The operation failed due to an invalid size."]
    pub const ERROR_INVALID_SIZE: ErrorCodes = ErrorCodes(-2147483646);
    #[doc = "< The end of the file was encountered."]
    pub const EOF: ErrorCodes = ErrorCodes(-2147483645);
    #[doc = "< The operation failed because the specified path was invalid."]
    pub const ERROR_INVALID_PATH: ErrorCodes = ErrorCodes(-2147483644);
    #[doc = "< The operation failed because end of file was reached."]
    pub const ERROR_EOF: ErrorCodes = ErrorCodes(-2147483643);
    #[doc = "< The operation failed because of some malformed data."]
    pub const ERROR_MALFORMED_DATA: ErrorCodes = ErrorCodes(-2147483642);
    #[doc = "< The operation failed because it ran out memory."]
    pub const ERROR_OUT_OF_MEMORY: ErrorCodes = ErrorCodes(-2147483641);
    #[doc = "< The operation failed because the interface was not fully configured."]
    pub const ERROR_INCOMPLETE_INTERFACE: ErrorCodes = ErrorCodes(-2147483640);
    #[doc = "< The operation failed because of an invalid enumeration value."]
    pub const ERROR_INVALID_ENUM: ErrorCodes = ErrorCodes(-2147483639);
    #[doc = "< The operation failed because an argument was invalid."]
    pub const ERROR_INVALID_ARGUMENT: ErrorCodes = ErrorCodes(-2147483638);
    #[doc = "< The operation failed because a value was out of range."]
    pub const ERROR_OUT_OF_RANGE: ErrorCodes = ErrorCodes(-2147483637);
    #[doc = "< The operation failed because a device was null."]
    pub const ERROR_NULL_DEVICE: ErrorCodes = ErrorCodes(-2147483636);
    #[doc = "< The operation failed because the backend API returned an error code."]
    pub const ERROR_BACKEND_API_ERROR: ErrorCodes = ErrorCodes(-2147483635);
    #[doc = "< The operation failed because there was not enough memory."]
    pub const ERROR_INSUFFICIENT_MEMORY: ErrorCodes = ErrorCodes(-2147483634);
}
#[repr(transparent)]
#[doc = " Error codes and their meaning\n\n @ingroup Errors"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ErrorCodes(pub ::std::os::raw::c_int);
#[doc = " Stand in type for FfxPass\n\n These will be defined for each effect individually (i.e. FfxFsr2Pass).\n They are used to fetch the proper blob index to build effect shaders\n\n @ingroup FfxInterface"]
pub type Pass = u32;
#[doc = " Get the SDK version of the backend context.\n\n Newer effects may require support that legacy versions of the SDK will not be\n able to provide. A version query is thus required to ensure an effect component\n will always be paired with a backend which will support all needed functionality.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n\n @returns\n The SDK version a backend was built with.\n\n @ingroup FfxInterface"]
pub type GetSDKVersionFunc =
    ::std::option::Option<unsafe extern "C" fn(backendInterface: *mut Interface) -> UInt32>;
#[doc = " Create and initialize the backend context.\n\n The callback function sets up the backend context for rendering.\n It will create or reference the device and create required internal data structures.\n\n @param [in]  backendInterface                    A pointer to the backend interface.\n @param [out] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreateBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effectContextId: *mut UInt32,
    ) -> ErrorCode,
>;
#[doc = " Get a list of capabilities of the device.\n\n When creating an <c><i>FfxEffectContext</i></c> it is desirable for the FFX\n core implementation to be aware of certain characteristics of the platform\n that is being targetted. This is because some optimizations which FFX SDK\n attempts to perform are more effective on certain classes of hardware than\n others, or are not supported by older hardware. In order to avoid cases\n where optimizations actually have the effect of decreasing performance, or\n reduce the breadth of support provided by FFX SDK, the FFX interface queries the\n capabilities of the device to make such decisions.\n\n For target platforms with fixed hardware support you need not implement\n this callback function by querying the device, but instead may hardcore\n what features are available on the platform.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] outDeviceCapabilities              The device capabilities structure to fill out.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type GetDeviceCapabilitiesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        outDeviceCapabilities: *mut DeviceCapabilities,
    ) -> ErrorCode,
>;
#[doc = " Destroy the backend context and dereference the device.\n\n This function is called when the <c><i>FfxEffectContext</i></c> is destroyed.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, effectContextId: UInt32) -> ErrorCode,
>;
#[doc = " Create a resource.\n\n This callback is intended for the backend to create internal resources.\n\n Please note: It is also possible that the creation of resources might\n itself cause additional resources to be created by simply calling the\n <c><i>FfxCreateResourceFunc</i></c> function pointer again. This is\n useful when handling the initial creation of resources which must be\n initialized. The flow in such a case would be an initial call to create the\n CPU-side resource, another to create the GPU-side resource, and then a call\n to schedule a copy render job to move the data between the two. Typically\n this type of function call flow is only seen during the creation of an\n <c><i>FfxEffectContext</i></c>.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] createResourceDescription           A pointer to a <c><i>FfxCreateResourceDescription</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outResource                        A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreateResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        createResourceDescription: *const CreateResourceDescription,
        effectContextId: UInt32,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Register a resource in the backend for the current frame.\n\n Since the FfxInterface and the backends are not aware how many different\n resources will get passed in over time, it's not safe\n to register all resources simultaneously in the backend.\n Also passed resources may not be valid after the dispatch call.\n As a result it's safest to register them as FfxResourceInternal\n and clear them at the end of the dispatch call.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] inResource                          A pointer to a <c><i>FfxResource</i></c>.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outResource                        A pointer to a <c><i>FfxResourceInternal</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type RegisterResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        inResource: *const Resource,
        effectContextId: UInt32,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Get an FfxResource from an FfxResourceInternal resource.\n\n At times it is necessary to create an FfxResource representation\n of an internally created resource in order to register it with a\n child effect context. This function sets up the FfxResource needed\n to register.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            The <c><i>FfxResourceInternal</i></c> for which to setup an FfxResource.\n\n @returns\n An FfxResource built from the internal resource\n\n @ingroup FfxInterface"]
pub type GetResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, resource: ResourceInternal) -> Resource,
>;
#[doc = " Unregister all temporary FfxResourceInternal from the backend.\n\n Unregister FfxResourceInternal referencing resources passed to\n a function as a parameter.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type UnregisterResourcesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        commandList: CommandList,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Retrieve a <c><i>FfxResourceDescription</i></c> matching a\n <c><i>FfxResource</i></c> structure.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @returns\n A description of the resource.\n\n @ingroup FfxInterface"]
pub type GetResourceDescriptionFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
    ) -> ResourceDescription,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Create a render pipeline.\n\n A rendering pipeline contains the shader as well as resource bindpoints\n and samplers.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] pass                                The identifier for the pass.\n @param [in] pipelineDescription                 A pointer to a <c><i>FfxPipelineDescription</i></c> describing the pipeline to be created.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] outPipeline                        A pointer to a <c><i>FfxPipelineState</i></c> structure which should be populated.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type CreatePipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        effect: Effect,
        pass: Pass,
        permutationOptions: u32,
        pipelineDescription: *const PipelineDescription,
        effectContextId: UInt32,
        outPipeline: *mut PipelineState,
    ) -> ErrorCode,
>;
pub type GetPermutationBlobByIndexFunc = ::std::option::Option<
    unsafe extern "C" fn(
        effectId: Effect,
        passId: Pass,
        bindStage: BindStage,
        permutationOptions: u32,
        outBlob: *mut ShaderBlob,
    ) -> ErrorCode,
>;
#[doc = " Destroy a render pipeline.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n @param [out] pipeline                           A pointer to a <c><i>FfxPipelineState</i></c> structure which should be released.\n @param [in] effectContextId                     The context space to be used for the effect in question.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type DestroyPipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        pipeline: *mut PipelineState,
        effectContextId: UInt32,
    ) -> ErrorCode,
>;
#[doc = " Schedule a render job to be executed on the next call of\n <c><i>FfxExecuteGpuJobsFunc</i></c>.\n\n Render jobs can perform one of three different tasks: clear, copy or\n compute dispatches.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] job                                 A pointer to a <c><i>FfxGpuJobDescription</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type ScheduleGpuJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        job: *const GpuJobDescription,
    ) -> ErrorCode,
>;
#[doc = " Execute scheduled render jobs on the <c><i>comandList</i></c> provided.\n\n The recording of the graphics API commands should take place in this\n callback function, the render jobs which were previously enqueued (via\n callbacks made to <c><i>FfxScheduleGpuJobFunc</i></c>) should be\n processed in the order they were received. Advanced users might choose to\n reorder the rendering jobs, but should do so with care to respect the\n resource dependencies.\n\n Depending on the precise contents of <c><i>FfxDispatchDescription</i></c> a\n different number of render jobs might have previously been enqueued (for\n example if sharpening is toggled on and off).\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FfxInterface"]
pub type ExecuteGpuJobsFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, commandList: CommandList) -> ErrorCode,
>;
pub type PresentCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(params: *const PresentCallbackDescription) -> ErrorCode,
>;
pub type FrameGenerationDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(params: *const FrameGenerationDispatchDescription) -> ErrorCode,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FrameGenerationConfig {
    pub swapChain: Swapchain,
    pub presentCallback: PresentCallbackFunc,
    pub frameGenerationCallback: FrameGenerationDispatchFunc,
    pub frameGenerationEnabled: bool,
    pub allowAsyncWorkloads: bool,
    pub HUDLessColor: Resource,
    pub flags: UInt32,
    pub onlyPresentInterpolated: bool,
}
impl Default for FrameGenerationConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SwapChainConfigureFrameGenerationFunc =
    ::std::option::Option<unsafe extern "C" fn(config: *const FrameGenerationConfig) -> ErrorCode>;
#[doc = " A structure encapsulating the interface between the core implementation of\n the FfxInterface and any graphics API that it should ultimately call.\n\n This set of functions serves as an abstraction layer between FfxInterfae and the\n API used to implement it. While the FidelityFX SDK ships with backends for DirectX12 and\n Vulkan, it is possible to implement your own backend for other platforms\n which sit on top of your engine's own abstraction layer. For details on the\n expectations of what each function should do you should refer the\n description of the following function pointer types:\n\n     <c><i>FfxCreateDeviceFunc</i></c>\n     <c><i>FfxGetDeviceCapabilitiesFunc</i></c>\n     <c><i>FfxDestroyDeviceFunc</i></c>\n     <c><i>FfxCreateResourceFunc</i></c>\n     <c><i>FfxRegisterResourceFunc</i></c>\n     <c><i>FfxGetResourceFunc</i></c>\n     <c><i>FfxUnregisterResourcesFunc</i></c>\n     <c><i>FfxGetResourceDescriptionFunc</i></c>\n     <c><i>FfxDestroyResourceFunc</i></c>\n     <c><i>FfxCreatePipelineFunc</i></c>\n     <c><i>FfxDestroyPipelineFunc</i></c>\n     <c><i>FfxScheduleGpuJobFunc</i></c>\n     <c><i>FfxExecuteGpuJobsFunc</i></c>\n\n Depending on the graphics API that is abstracted by the backend, it may be\n required that the backend is to some extent stateful. To ensure that\n applications retain full control to manage the memory used by the FidelityFX SDK, the\n <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields are\n provided. A backend should provide a means of specifying how much scratch\n memory is required for its internal implementation (e.g: via a function\n or constant value). The application is then responsible for allocating that\n memory and providing it when setting up the SDK backend. Backends provided\n with the FidelityFX SDK do not perform dynamic memory allocations, and instead\n sub-allocate all memory from the scratch buffers provided.\n\n The <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields\n should be populated according to the requirements of each backend. For\n example, if using the DirectX 12 backend you should call the\n <c><i>ffxGetScratchMemorySizeDX12</i></c> function. It is not required\n that custom backend implementations use a scratch buffer.\n\n Any functional addition to this interface mandates a version\n bump to ensure full functionality across effects and backends.\n\n @ingroup FfxInterface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Interface {
    #[doc = "< A callback function to query the SDK version."]
    pub fpGetSDKVersion: GetSDKVersionFunc,
    #[doc = "< A callback function to create and initialize the backend context."]
    pub fpCreateBackendContext: CreateBackendContextFunc,
    #[doc = "< A callback function to query device capabilities."]
    pub fpGetDeviceCapabilities: GetDeviceCapabilitiesFunc,
    #[doc = "< A callback function to destroy the backend context. This also dereferences the device."]
    pub fpDestroyBackendContext: DestroyBackendContextFunc,
    #[doc = "< A callback function to create a resource."]
    pub fpCreateResource: CreateResourceFunc,
    #[doc = "< A callback function to register an external resource."]
    pub fpRegisterResource: RegisterResourceFunc,
    #[doc = "< A callback function to convert an internal resource to external resource type"]
    pub fpGetResource: GetResourceFunc,
    #[doc = "< A callback function to unregister external resource."]
    pub fpUnregisterResources: UnregisterResourcesFunc,
    #[doc = "< A callback function to retrieve a resource description."]
    pub fpGetResourceDescription: GetResourceDescriptionFunc,
    #[doc = "< A callback function to destroy a resource."]
    pub fpDestroyResource: DestroyResourceFunc,
    #[doc = "< A callback function to create a render or compute pipeline."]
    pub fpCreatePipeline: CreatePipelineFunc,
    pub fpGetPermutationBlobByIndex: GetPermutationBlobByIndexFunc,
    #[doc = "< A callback function to destroy a render or compute pipeline."]
    pub fpDestroyPipeline: DestroyPipelineFunc,
    #[doc = "< A callback function to schedule a render job."]
    pub fpScheduleGpuJob: ScheduleGpuJobFunc,
    #[doc = "< A callback function to execute all queued render jobs."]
    pub fpExecuteGpuJobs: ExecuteGpuJobsFunc,
    #[doc = "< A callback function to configure swap chain present callback."]
    pub fpSwapChainConfigureFrameGeneration: SwapChainConfigureFrameGenerationFunc,
    #[doc = "< A preallocated buffer for memory utilized internally by the backend."]
    pub scratchBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the buffer pointed to by <c><i>scratchBuffer</i></c>."]
    pub scratchBufferSize: usize,
    #[doc = "< A backend specific device"]
    pub device: Device,
}
impl Default for Interface {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
