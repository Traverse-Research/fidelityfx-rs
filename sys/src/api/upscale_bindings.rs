/* automatically generated by rust-bindgen 0.72.1 */

pub const EFFECT_ID_UPSCALE: u32 = 65536;
pub const CREATE_CONTEXT_DESC_TYPE_UPSCALE: StructType_t = 65536;
pub const DISPATCH_DESC_TYPE_UPSCALE: StructType_t = 65537;
pub const QUERY_DESC_TYPE_UPSCALE_GETUPSCALERATIOFROMQUALITYMODE: StructType_t = 65538;
pub const QUERY_DESC_TYPE_UPSCALE_GETRENDERRESOLUTIONFROMQUALITYMODE: StructType_t = 65539;
pub const QUERY_DESC_TYPE_UPSCALE_GETJITTERPHASECOUNT: StructType_t = 65540;
pub const QUERY_DESC_TYPE_UPSCALE_GETJITTEROFFSET: StructType_t = 65541;
pub const DISPATCH_DESC_TYPE_UPSCALE_GENERATEREACTIVEMASK: StructType_t = 65542;
pub const CONFIGURE_DESC_TYPE_UPSCALE_KEYVALUE: StructType_t = 65543;
pub const QUERY_DESC_TYPE_UPSCALE_GPU_MEMORY_USAGE: StructType_t = 65544;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UpscaleQualityMode {
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.0x."]
    NATIVEAA = 0,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
    QUALITY = 1,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
    BALANCED = 2,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
    PERFORMANCE = 3,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
    ULTRA_PERFORMANCE = 4,
}
impl CreateContextUpscaleFlags {
    #[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
    pub const HIGH_DYNAMIC_RANGE: CreateContextUpscaleFlags = CreateContextUpscaleFlags(1);
    #[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
    pub const DISPLAY_RESOLUTION_MOTION_VECTORS: CreateContextUpscaleFlags =
        CreateContextUpscaleFlags(2);
    #[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
    pub const MOTION_VECTORS_JITTER_CANCELLATION: CreateContextUpscaleFlags =
        CreateContextUpscaleFlags(4);
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const DEPTH_INVERTED: CreateContextUpscaleFlags = CreateContextUpscaleFlags(8);
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const DEPTH_INFINITE: CreateContextUpscaleFlags = CreateContextUpscaleFlags(16);
    #[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
    pub const AUTO_EXPOSURE: CreateContextUpscaleFlags = CreateContextUpscaleFlags(32);
    #[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
    pub const DYNAMIC_RESOLUTION: CreateContextUpscaleFlags = CreateContextUpscaleFlags(64);
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const DEBUG_CHECKING: CreateContextUpscaleFlags = CreateContextUpscaleFlags(128);
    #[doc = "< A bit indicating that the color resource contains perceptual (gamma corrected) colors"]
    pub const NON_LINEAR_COLORSPACE: CreateContextUpscaleFlags = CreateContextUpscaleFlags(256);
}
impl ::std::ops::BitOr<CreateContextUpscaleFlags> for CreateContextUpscaleFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        CreateContextUpscaleFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for CreateContextUpscaleFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: CreateContextUpscaleFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<CreateContextUpscaleFlags> for CreateContextUpscaleFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        CreateContextUpscaleFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for CreateContextUpscaleFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: CreateContextUpscaleFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CreateContextUpscaleFlags(pub ::std::os::raw::c_int);
impl DispatchFsrUpscaleFlags {
    #[doc = "< A bit indicating that the output resource will contain debug views with relevant information."]
    pub const DRAW_DEBUG_VIEW: DispatchFsrUpscaleFlags = DispatchFsrUpscaleFlags(1);
    #[doc = "< A bit indicating that the input color resource contains perceptual sRGB colors"]
    pub const NON_LINEAR_COLOR_SRGB: DispatchFsrUpscaleFlags = DispatchFsrUpscaleFlags(2);
    #[doc = "< A bit indicating that the input color resource contains perceptual PQ colors"]
    pub const NON_LINEAR_COLOR_PQ: DispatchFsrUpscaleFlags = DispatchFsrUpscaleFlags(4);
}
impl ::std::ops::BitOr<DispatchFsrUpscaleFlags> for DispatchFsrUpscaleFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        DispatchFsrUpscaleFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for DispatchFsrUpscaleFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: DispatchFsrUpscaleFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<DispatchFsrUpscaleFlags> for DispatchFsrUpscaleFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        DispatchFsrUpscaleFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for DispatchFsrUpscaleFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: DispatchFsrUpscaleFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DispatchFsrUpscaleFlags(pub ::std::os::raw::c_int);
impl DispatchUpscaleAutoreactiveFlags {
    pub const APPLY_TONEMAP: DispatchUpscaleAutoreactiveFlags = DispatchUpscaleAutoreactiveFlags(1);
    pub const APPLY_INVERSETONEMAP: DispatchUpscaleAutoreactiveFlags =
        DispatchUpscaleAutoreactiveFlags(2);
    pub const APPLY_THRESHOLD: DispatchUpscaleAutoreactiveFlags =
        DispatchUpscaleAutoreactiveFlags(4);
    pub const USE_COMPONENTS_MAX: DispatchUpscaleAutoreactiveFlags =
        DispatchUpscaleAutoreactiveFlags(8);
}
impl ::std::ops::BitOr<DispatchUpscaleAutoreactiveFlags> for DispatchUpscaleAutoreactiveFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        DispatchUpscaleAutoreactiveFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for DispatchUpscaleAutoreactiveFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: DispatchUpscaleAutoreactiveFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<DispatchUpscaleAutoreactiveFlags> for DispatchUpscaleAutoreactiveFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        DispatchUpscaleAutoreactiveFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for DispatchUpscaleAutoreactiveFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: DispatchUpscaleAutoreactiveFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DispatchUpscaleAutoreactiveFlags(pub ::std::os::raw::c_int);
#[repr(C)]
pub struct CreateContextDescUpscale {
    pub header: CreateContextDescHeader,
    #[doc = "< Zero or a combination of values from FfxApiCreateContextFsrFlags."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub maxUpscaleSize: Dimensions2D,
    #[doc = "< A pointer to a function that can receive messages from the runtime. May be null."]
    pub fpMessage: Message,
}
#[repr(C)]
pub struct DispatchDescUpscale {
    pub header: DispatchDescHeader,
    #[doc = "< Command list to record upscaling rendering commands into."]
    pub commandList: *mut ::std::os::raw::c_void,
    #[doc = "< Color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< Optional resource containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< Optional resource containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< Optional resource containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< Output color buffer for the current frame (at presentation resolution)."]
    pub output: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< The resolution that the upscaler will upscale to (optional, assumed maxUpscaleSize otherwise)."]
    pub upscaleSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< Zero or a combination of values from FfxApiDispatchFsrUpscaleFlags."]
    pub flags: u32,
}
#[repr(C)]
pub struct QueryDescUpscaleGetUpscaleRatioFromQualityMode {
    pub header: QueryDescHeader,
    #[doc = "< The desired quality mode for FSR upscaling."]
    pub qualityMode: u32,
    #[doc = "< A pointer to a <c>float</c> which will hold the upscaling the per-dimension upscaling ratio."]
    pub pOutUpscaleRatio: *mut f32,
}
#[repr(C)]
pub struct QueryDescUpscaleGetRenderResolutionFromQualityMode {
    pub header: QueryDescHeader,
    #[doc = "< The target display resolution width."]
    pub displayWidth: u32,
    #[doc = "< The target display resolution height."]
    pub displayHeight: u32,
    #[doc = "< The desired quality mode for FSR upscaling."]
    pub qualityMode: u32,
    #[doc = "< A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width."]
    pub pOutRenderWidth: *mut u32,
    #[doc = "< A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height."]
    pub pOutRenderHeight: *mut u32,
}
#[repr(C)]
pub struct QueryDescUpscaleGetJitterPhaseCount {
    pub header: QueryDescHeader,
    #[doc = "< The render resolution width."]
    pub renderWidth: u32,
    #[doc = "< The output resolution width."]
    pub displayWidth: u32,
    #[doc = "< A pointer to a <c>int32_t</c> which will hold the jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>."]
    pub pOutPhaseCount: *mut i32,
}
#[repr(C)]
pub struct QueryDescUpscaleGetJitterOffset {
    pub header: QueryDescHeader,
    #[doc = "< The index within the jitter sequence."]
    pub index: i32,
    #[doc = "< The length of jitter phase. See <c><i>ffxQueryDescFsrGetJitterPhaseCount</i></c>."]
    pub phaseCount: i32,
    #[doc = "< A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension."]
    pub pOutX: *mut f32,
    #[doc = "< A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension."]
    pub pOutY: *mut f32,
}
#[repr(C)]
pub struct DispatchDescUpscaleGenerateReactiveMask {
    pub header: DispatchDescHeader,
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSRUPSCALE rendering commands into."]
    pub commandList: *mut ::std::os::raw::c_void,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
#[repr(C)]
pub struct ConfigureDescUpscaleKeyValue {
    pub header: ConfigureDescHeader,
    #[doc = "< Configuration key, member of the FfxApiConfigureUpscaleKey enumeration."]
    pub key: u64,
    #[doc = "< Integer value or enum value to set."]
    pub u64_: u64,
    #[doc = "< Pointer to set or pointer to value to set."]
    pub ptr: *mut ::std::os::raw::c_void,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ConfigureUpscaleKey {
    FVELOCITYFACTOR = 0,
    FREACTIVENESSSCALE = 1,
    FSHADINGCHANGESCALE = 2,
    FACCUMULATIONADDEDPERFRAME = 3,
    FMINDISOCCLUSIONACCUMULATION = 4,
}
#[repr(C)]
pub struct QueryDescUpscaleGetGPUMemoryUsage {
    pub header: QueryDescHeader,
    pub gpuMemoryUsageUpscaler: *mut EffectMemoryUsage,
}

unsafe impl TaggedStructure for CreateContextDescUpscale {
    const TAG: StructType_t = CREATE_CONTEXT_DESC_TYPE_UPSCALE;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for DispatchDescUpscale {
    const TAG: StructType_t = DISPATCH_DESC_TYPE_UPSCALE;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for QueryDescUpscaleGetUpscaleRatioFromQualityMode {
    const TAG: StructType_t = QUERY_DESC_TYPE_UPSCALE_GETUPSCALERATIOFROMQUALITYMODE;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for QueryDescUpscaleGetRenderResolutionFromQualityMode {
    const TAG: StructType_t = QUERY_DESC_TYPE_UPSCALE_GETRENDERRESOLUTIONFROMQUALITYMODE;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for QueryDescUpscaleGetJitterPhaseCount {
    const TAG: StructType_t = QUERY_DESC_TYPE_UPSCALE_GETJITTERPHASECOUNT;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for QueryDescUpscaleGetJitterOffset {
    const TAG: StructType_t = QUERY_DESC_TYPE_UPSCALE_GETJITTEROFFSET;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for DispatchDescUpscaleGenerateReactiveMask {
    const TAG: StructType_t = DISPATCH_DESC_TYPE_UPSCALE_GENERATEREACTIVEMASK;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for ConfigureDescUpscaleKeyValue {
    const TAG: StructType_t = CONFIGURE_DESC_TYPE_UPSCALE_KEYVALUE;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for QueryDescUpscaleGetGPUMemoryUsage {
    const TAG: StructType_t = QUERY_DESC_TYPE_UPSCALE_GPU_MEMORY_USAGE;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}
