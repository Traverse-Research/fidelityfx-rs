/* automatically generated by rust-bindgen 0.72.1 */

pub const API_EFFECT_ID_UPSCALE: u32 = 65536;
pub const API_CREATE_CONTEXT_DESC_TYPE_UPSCALE: u32 = 65536;
pub const API_DISPATCH_DESC_TYPE_UPSCALE: u32 = 65537;
pub const API_QUERY_DESC_TYPE_UPSCALE_GETUPSCALERATIOFROMQUALITYMODE: u32 = 65538;
pub const API_QUERY_DESC_TYPE_UPSCALE_GETRENDERRESOLUTIONFROMQUALITYMODE: u32 = 65539;
pub const API_QUERY_DESC_TYPE_UPSCALE_GETJITTERPHASECOUNT: u32 = 65540;
pub const API_QUERY_DESC_TYPE_UPSCALE_GETJITTEROFFSET: u32 = 65541;
pub const API_DISPATCH_DESC_TYPE_UPSCALE_GENERATEREACTIVEMASK: u32 = 65542;
pub const API_CONFIGURE_DESC_TYPE_UPSCALE_KEYVALUE: u32 = 65543;
pub const API_QUERY_DESC_TYPE_UPSCALE_GPU_MEMORY_USAGE: u32 = 65544;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ApiUpscaleQualityMode {
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.0x."]
    NATIVEAA = 0,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
    QUALITY = 1,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
    BALANCED = 2,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
    PERFORMANCE = 3,
    #[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
    ULTRA_PERFORMANCE = 4,
}
impl ApiCreateContextUpscaleFlags {
    #[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
    pub const HIGH_DYNAMIC_RANGE: ApiCreateContextUpscaleFlags = ApiCreateContextUpscaleFlags(1);
    #[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
    pub const DISPLAY_RESOLUTION_MOTION_VECTORS: ApiCreateContextUpscaleFlags =
        ApiCreateContextUpscaleFlags(2);
    #[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
    pub const MOTION_VECTORS_JITTER_CANCELLATION: ApiCreateContextUpscaleFlags =
        ApiCreateContextUpscaleFlags(4);
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const DEPTH_INVERTED: ApiCreateContextUpscaleFlags = ApiCreateContextUpscaleFlags(8);
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const DEPTH_INFINITE: ApiCreateContextUpscaleFlags = ApiCreateContextUpscaleFlags(16);
    #[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
    pub const AUTO_EXPOSURE: ApiCreateContextUpscaleFlags = ApiCreateContextUpscaleFlags(32);
    #[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
    pub const DYNAMIC_RESOLUTION: ApiCreateContextUpscaleFlags = ApiCreateContextUpscaleFlags(64);
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const DEBUG_CHECKING: ApiCreateContextUpscaleFlags = ApiCreateContextUpscaleFlags(128);
    #[doc = "< A bit indicating that the color resource contains perceptual (gamma corrected) colors"]
    pub const NON_LINEAR_COLORSPACE: ApiCreateContextUpscaleFlags =
        ApiCreateContextUpscaleFlags(256);
}
impl ::std::ops::BitOr<ApiCreateContextUpscaleFlags> for ApiCreateContextUpscaleFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ApiCreateContextUpscaleFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ApiCreateContextUpscaleFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ApiCreateContextUpscaleFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ApiCreateContextUpscaleFlags> for ApiCreateContextUpscaleFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ApiCreateContextUpscaleFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ApiCreateContextUpscaleFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ApiCreateContextUpscaleFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ApiCreateContextUpscaleFlags(pub ::std::os::raw::c_int);
impl ApiDispatchFsrUpscaleFlags {
    #[doc = "< A bit indicating that the output resource will contain debug views with relevant information."]
    pub const DRAW_DEBUG_VIEW: ApiDispatchFsrUpscaleFlags = ApiDispatchFsrUpscaleFlags(1);
    #[doc = "< A bit indicating that the input color resource contains perceptual sRGB colors"]
    pub const NON_LINEAR_COLOR_SRGB: ApiDispatchFsrUpscaleFlags = ApiDispatchFsrUpscaleFlags(2);
    #[doc = "< A bit indicating that the input color resource contains perceptual PQ colors"]
    pub const NON_LINEAR_COLOR_PQ: ApiDispatchFsrUpscaleFlags = ApiDispatchFsrUpscaleFlags(4);
}
impl ::std::ops::BitOr<ApiDispatchFsrUpscaleFlags> for ApiDispatchFsrUpscaleFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ApiDispatchFsrUpscaleFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ApiDispatchFsrUpscaleFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ApiDispatchFsrUpscaleFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ApiDispatchFsrUpscaleFlags> for ApiDispatchFsrUpscaleFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ApiDispatchFsrUpscaleFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ApiDispatchFsrUpscaleFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ApiDispatchFsrUpscaleFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ApiDispatchFsrUpscaleFlags(pub ::std::os::raw::c_int);
impl ApiDispatchUpscaleAutoreactiveFlags {
    pub const APPLY_TONEMAP: ApiDispatchUpscaleAutoreactiveFlags =
        ApiDispatchUpscaleAutoreactiveFlags(1);
    pub const APPLY_INVERSETONEMAP: ApiDispatchUpscaleAutoreactiveFlags =
        ApiDispatchUpscaleAutoreactiveFlags(2);
    pub const APPLY_THRESHOLD: ApiDispatchUpscaleAutoreactiveFlags =
        ApiDispatchUpscaleAutoreactiveFlags(4);
    pub const USE_COMPONENTS_MAX: ApiDispatchUpscaleAutoreactiveFlags =
        ApiDispatchUpscaleAutoreactiveFlags(8);
}
impl ::std::ops::BitOr<ApiDispatchUpscaleAutoreactiveFlags>
    for ApiDispatchUpscaleAutoreactiveFlags
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ApiDispatchUpscaleAutoreactiveFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ApiDispatchUpscaleAutoreactiveFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ApiDispatchUpscaleAutoreactiveFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ApiDispatchUpscaleAutoreactiveFlags>
    for ApiDispatchUpscaleAutoreactiveFlags
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ApiDispatchUpscaleAutoreactiveFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ApiDispatchUpscaleAutoreactiveFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ApiDispatchUpscaleAutoreactiveFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ApiDispatchUpscaleAutoreactiveFlags(pub ::std::os::raw::c_int);
#[repr(C)]
pub struct CreateContextDescUpscale {
    pub header: CreateContextDescHeader,
    #[doc = "< Zero or a combination of values from FfxApiCreateContextFsrFlags."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: ApiDimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub maxUpscaleSize: ApiDimensions2D,
    #[doc = "< A pointer to a function that can receive messages from the runtime. May be null."]
    pub fpMessage: ApiMessage,
}
impl Default for CreateContextDescUpscale {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct DispatchDescUpscale {
    pub header: DispatchDescHeader,
    #[doc = "< Command list to record upscaling rendering commands into."]
    pub commandList: *mut ::std::os::raw::c_void,
    #[doc = "< Color buffer for the current frame (at render resolution)."]
    pub color: ApiResource,
    #[doc = "< 32bit depth values for the current frame (at render resolution)."]
    pub depth: ApiResource,
    #[doc = "< 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: ApiResource,
    #[doc = "< Optional resource containing a 1x1 exposure value."]
    pub exposure: ApiResource,
    #[doc = "< Optional resource containing alpha value of reactive objects in the scene."]
    pub reactive: ApiResource,
    #[doc = "< Optional resource containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: ApiResource,
    #[doc = "< Output color buffer for the current frame (at presentation resolution)."]
    pub output: ApiResource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: ApiFloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: ApiFloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: ApiDimensions2D,
    #[doc = "< The resolution that the upscaler will upscale to (optional, assumed maxUpscaleSize otherwise)."]
    pub upscaleSize: ApiDimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< Zero or a combination of values from FfxApiDispatchFsrUpscaleFlags."]
    pub flags: u32,
}
impl Default for DispatchDescUpscale {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct QueryDescUpscaleGetUpscaleRatioFromQualityMode {
    pub header: QueryDescHeader,
    #[doc = "< The desired quality mode for FSR upscaling."]
    pub qualityMode: u32,
    #[doc = "< A pointer to a <c>float</c> which will hold the upscaling the per-dimension upscaling ratio."]
    pub pOutUpscaleRatio: *mut f32,
}
impl Default for QueryDescUpscaleGetUpscaleRatioFromQualityMode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct QueryDescUpscaleGetRenderResolutionFromQualityMode {
    pub header: QueryDescHeader,
    #[doc = "< The target display resolution width."]
    pub displayWidth: u32,
    #[doc = "< The target display resolution height."]
    pub displayHeight: u32,
    #[doc = "< The desired quality mode for FSR upscaling."]
    pub qualityMode: u32,
    #[doc = "< A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width."]
    pub pOutRenderWidth: *mut u32,
    #[doc = "< A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height."]
    pub pOutRenderHeight: *mut u32,
}
impl Default for QueryDescUpscaleGetRenderResolutionFromQualityMode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct QueryDescUpscaleGetJitterPhaseCount {
    pub header: QueryDescHeader,
    #[doc = "< The render resolution width."]
    pub renderWidth: u32,
    #[doc = "< The output resolution width."]
    pub displayWidth: u32,
    #[doc = "< A pointer to a <c>int32_t</c> which will hold the jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>."]
    pub pOutPhaseCount: *mut i32,
}
impl Default for QueryDescUpscaleGetJitterPhaseCount {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct QueryDescUpscaleGetJitterOffset {
    pub header: QueryDescHeader,
    #[doc = "< The index within the jitter sequence."]
    pub index: i32,
    #[doc = "< The length of jitter phase. See <c><i>ffxQueryDescFsrGetJitterPhaseCount</i></c>."]
    pub phaseCount: i32,
    #[doc = "< A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension."]
    pub pOutX: *mut f32,
    #[doc = "< A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension."]
    pub pOutY: *mut f32,
}
impl Default for QueryDescUpscaleGetJitterOffset {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct DispatchDescUpscaleGenerateReactiveMask {
    pub header: DispatchDescHeader,
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSRUPSCALE rendering commands into."]
    pub commandList: *mut ::std::os::raw::c_void,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: ApiResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: ApiResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: ApiResource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: ApiDimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for DispatchDescUpscaleGenerateReactiveMask {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ConfigureDescUpscaleKeyValue {
    pub header: ConfigureDescHeader,
    #[doc = "< Configuration key, member of the FfxApiConfigureUpscaleKey enumeration."]
    pub key: u64,
    #[doc = "< Integer value or enum value to set."]
    pub u64_: u64,
    #[doc = "< Pointer to set or pointer to value to set."]
    pub ptr: *mut ::std::os::raw::c_void,
}
impl Default for ConfigureDescUpscaleKeyValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ApiConfigureUpscaleKey {
    FVELOCITYFACTOR = 0,
    FREACTIVENESSSCALE = 1,
    FSHADINGCHANGESCALE = 2,
    FACCUMULATIONADDEDPERFRAME = 3,
    FMINDISOCCLUSIONACCUMULATION = 4,
}
#[repr(C)]
pub struct QueryDescUpscaleGetGPUMemoryUsage {
    pub header: QueryDescHeader,
    pub gpuMemoryUsageUpscaler: *mut ApiEffectMemoryUsage,
}
impl Default for QueryDescUpscaleGetGPUMemoryUsage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub struct Functions {
    __library: ::libloading::Library,
}
impl Functions {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        Ok(Functions { __library })
    }
}
