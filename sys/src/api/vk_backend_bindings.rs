/* automatically generated by rust-bindgen 0.72.1 */

pub const API_CREATE_CONTEXT_DESC_TYPE_BACKEND_VK: u32 = 3;
pub const API_EFFECT_ID_FGSC_VK: u32 = 262144;
pub const API_CREATE_CONTEXT_DESC_TYPE_FGSWAPCHAIN_VK: u32 = 262145;
pub const API_CONFIGURE_DESC_TYPE_FGSWAPCHAIN_REGISTERUIRESOURCE_VK: u32 = 262146;
pub const API_QUERY_DESC_TYPE_FGSWAPCHAIN_INTERPOLATIONCOMMANDLIST_VK: u32 = 262147;
pub const API_QUERY_DESC_TYPE_FGSWAPCHAIN_INTERPOLATIONTEXTURE_VK: u32 = 262148;
pub const API_DISPATCH_DESC_TYPE_FGSWAPCHAIN_WAIT_FOR_PRESENTS_VK: u32 = 262151;
pub const API_CONFIGURE_DESC_TYPE_FRAMEGENERATIONSWAPCHAIN_KEYVALUE_VK: u32 = 262152;
pub const API_QUERY_DESC_TYPE_FRAMEGENERATIONSWAPCHAIN_GPU_MEMORY_USAGE_VK: u32 = 262153;
pub const API_QUERY_DESC_TYPE_FGSWAPCHAIN_FUNCTIONS_VK: u32 = 262149;
pub const API_CREATE_CONTEXT_DESC_TYPE_FGSWAPCHAIN_MODE_VK: u32 = 262160;
#[doc = " FFX specific callback type when submitting a command buffer to a queue."]
pub type PFN_vkQueueSubmitFFXAPI = ::std::option::Option<
    unsafe extern "C" fn(
        submitCount: u32,
        pSubmits: *const VkSubmitInfo,
        fence: VkFence,
    ) -> VkResult,
>;
#[doc = " Helper stucture"]
#[repr(C)]
pub struct VkQueueInfoFFXAPI {
    #[doc = "< the vulkan queue"]
    pub queue: VkQueue,
    #[doc = "< the queue family index, that will be used to perform queue family ownership transfer"]
    pub familyIndex: u32,
    #[doc = "< an optional submit function in case there might be some concurrent submissions"]
    pub submitFunc: PFN_vkQueueSubmitFFXAPI,
}
impl Default for VkQueueInfoFFXAPI {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct CreateBackendVKDesc {
    pub header: CreateContextDescHeader,
    #[doc = "< the logical device used by the program."]
    pub vkDevice: VkDevice,
    #[doc = "< the physical device used by the program."]
    pub vkPhysicalDevice: VkPhysicalDevice,
    #[doc = "< function pointer to get device procedure addresses"]
    pub vkDeviceProcAddr: PFN_vkGetDeviceProcAddr,
}
impl Default for CreateBackendVKDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct CreateContextDescFrameGenerationSwapChainVK {
    pub header: CreateContextDescHeader,
    #[doc = "< the physicak device used by the program."]
    pub physicalDevice: VkPhysicalDevice,
    #[doc = "< the logical device used by the program."]
    pub device: VkDevice,
    #[doc = "< the current swapchain to be replaced. Will be destroyed when the context is created. This can be VK_NULL_HANDLE. Will contain the new swapchain on return."]
    pub swapchain: *mut VkSwapchainKHR,
    #[doc = "< optional allocation callbacks."]
    pub allocator: *mut VkAllocationCallbacks,
    #[doc = "< the description of the desired swapchain. If its VkSwapchainCreateInfoKHR::oldSwapchain field isn't VK_NULL_HANDLE, it should be the same as the ffxCreateContextDescFrameGenerationSwapChainVK::swapchain field above."]
    pub createInfo: VkSwapchainCreateInfoKHR,
    #[doc = "< the main graphics queue, where Present is called."]
    pub gameQueue: VkQueueInfoFFXAPI,
    #[doc = "< A queue with Compute capability."]
    pub asyncComputeQueue: VkQueueInfoFFXAPI,
    #[doc = "< A queue with Transfer and Present capabilities."]
    pub presentQueue: VkQueueInfoFFXAPI,
    #[doc = "< A queue with no capability required."]
    pub imageAcquireQueue: VkQueueInfoFFXAPI,
}
impl Default for CreateContextDescFrameGenerationSwapChainVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ConfigureDescFrameGenerationSwapChainRegisterUiResourceVK {
    pub header: ConfigureDescHeader,
    #[doc = "< Resource containing user interface for composition. May be empty."]
    pub uiResource: ApiResource,
    #[doc = "< Zero or combination of values from FfxApiUiCompositionFlags."]
    pub flags: u32,
}
impl Default for ConfigureDescFrameGenerationSwapChainRegisterUiResourceVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct QueryDescFrameGenerationSwapChainInterpolationCommandListVK {
    pub header: QueryDescHeader,
    #[doc = "< Output command nuffer (VkCommandBuffer) to be used for frame generation dispatch."]
    pub pOutCommandList: *mut *mut ::std::os::raw::c_void,
}
impl Default for QueryDescFrameGenerationSwapChainInterpolationCommandListVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct QueryDescFrameGenerationSwapChainInterpolationTextureVK {
    pub header: QueryDescHeader,
    #[doc = "< Output resource in which the frame interpolation result should be placed."]
    pub pOutTexture: *mut ApiResource,
}
impl Default for QueryDescFrameGenerationSwapChainInterpolationTextureVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct DispatchDescFrameGenerationSwapChainWaitForPresentsVK {
    pub header: DispatchDescHeader,
}
impl Default for DispatchDescFrameGenerationSwapChainWaitForPresentsVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ConfigureDescFrameGenerationSwapChainKeyValueVK {
    pub header: ConfigureDescHeader,
    #[doc = "< Configuration key, member of the FfxApiConfigureFrameGenerationSwapChainKeyVK enumeration."]
    pub key: u64,
    #[doc = "< Integer value or enum value to set."]
    pub u64_: u64,
    #[doc = "< Pointer to set or pointer to value to set."]
    pub ptr: *mut ::std::os::raw::c_void,
}
impl Default for ConfigureDescFrameGenerationSwapChainKeyValueVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ApiConfigureFrameGenerationSwapChainKeyVK {
    #[doc = "< Sets FfxWaitCallbackFunc"]
    WAITCALLBACK = 0,
    #[doc = "< Sets FfxApiSwapchainFramePacingTuning casted from ptr"]
    FRAMEPACINGTUNING = 2,
}
#[repr(C)]
pub struct QueryFrameGenerationSwapChainGetGPUMemoryUsageVK {
    pub header: QueryDescHeader,
    pub gpuMemoryUsageFrameGenerationSwapchain: *mut ApiEffectMemoryUsage,
}
impl Default for QueryFrameGenerationSwapChainGetGPUMemoryUsageVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Function to get the number of presents. This is useful when using frame interpolation"]
pub type PFN_getLastPresentCountFFXAPI =
    ::std::option::Option<unsafe extern "C" fn(arg1: VkSwapchainKHR) -> u64>;
#[doc = " FFX API specific functions to create and destroy a swapchain"]
pub type PFN_vkCreateSwapchainFFXAPI = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR,
        pContext: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkDestroySwapchainFFXAPI = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pAllocator: *const VkAllocationCallbacks,
        pContext: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
pub struct QueryDescSwapchainReplacementFunctionsVK {
    pub header: QueryDescHeader,
    #[doc = "< Replacement of vkCreateSwapchainKHR. Can be called when swapchain is recreated but swapchain context isn't (for example when toggling vsync)."]
    pub pOutCreateSwapchainFFXAPI: PFN_vkCreateSwapchainFFXAPI,
    #[doc = "< Replacement of vkDestroySwapchainKHR. Can be called when swapchain is destroyed but swapchain context isn't."]
    pub pOutDestroySwapchainFFXAPI: PFN_vkDestroySwapchainFFXAPI,
    #[doc = "< Replacement of vkGetSwapchainImagesKHR."]
    pub pOutGetSwapchainImagesKHR: PFN_vkGetSwapchainImagesKHR,
    #[doc = "< Replacement of vkAcquireNextImageKHR."]
    pub pOutAcquireNextImageKHR: PFN_vkAcquireNextImageKHR,
    #[doc = "< Replacement of vkQueuePresentKHR."]
    pub pOutQueuePresentKHR: PFN_vkQueuePresentKHR,
    #[doc = "< Replacement of vkSetHdrMetadataEXT."]
    pub pOutSetHdrMetadataEXT: PFN_vkSetHdrMetadataEXT,
    #[doc = "< Additional function to get the number of times present has been called since the swapchain creation."]
    pub pOutGetLastPresentCountFFXAPI: PFN_getLastPresentCountFFXAPI,
}
impl Default for QueryDescSwapchainReplacementFunctionsVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct CreateContextDescFrameGenerationSwapChainModeVK {
    pub header: CreateContextDescHeader,
    #[doc = "< flags indicating that composition will happen on the present queue"]
    pub composeOnPresentQueue: bool,
}
impl Default for CreateContextDescFrameGenerationSwapChainModeVK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub struct Functions {
    __library: ::libloading::Library,
}
impl Functions {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        Ok(Functions { __library })
    }
}
