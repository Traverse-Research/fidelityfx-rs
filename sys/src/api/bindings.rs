/* automatically generated by rust-bindgen 0.72.1 */

pub const API_EFFECT_MASK: u32 = 4294901760;
pub const API_EFFECT_ID_GENERAL: u32 = 0;
pub const API_CONFIGURE_GLOBALDEBUG_LEVEL_SILENCE: u32 = 0;
pub const API_CONFIGURE_GLOBALDEBUG_LEVEL_ERRORS: u32 = 1;
pub const API_CONFIGURE_GLOBALDEBUG_LEVEL_WARNINGS: u32 = 2;
pub const API_CONFIGURE_GLOBALDEBUG_LEVEL_VERBOSE: u32 = 268435455;
pub const API_CONFIGURE_DESC_TYPE_GLOBALDEBUG1: u32 = 1;
pub const API_QUERY_DESC_TYPE_GET_VERSIONS: u32 = 4;
pub const API_DESC_TYPE_OVERRIDE_VERSION: u32 = 5;
pub const API_QUERY_DESC_TYPE_GET_PROVIDER_VERSION: u32 = 6;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ApiReturnCodes {
    #[doc = "< The oparation was successful."]
    OK = 0,
    #[doc = "< An error occurred that is not further specified."]
    ERROR = 1,
    #[doc = "< The structure type given was not recognized for the function or context with which it was used. This is likely a programming error."]
    ERROR_UNKNOWN_DESCTYPE = 2,
    #[doc = "< The underlying runtime (e.g. D3D12, Vulkan) or effect returned an error code."]
    ERROR_RUNTIME_ERROR = 3,
    #[doc = "< No provider was found for the given structure type. This is likely a programming error."]
    NO_PROVIDER = 4,
    #[doc = "< A memory allocation failed."]
    ERROR_MEMORY = 5,
    #[doc = "< A parameter was invalid, e.g. a null pointer, empty resource or out-of-bounds enum value."]
    ERROR_PARAMETER = 6,
}
pub type Context = *mut ::std::os::raw::c_void;
pub type ReturnCode_t = u32;
pub type StructType_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ApiHeader {
    #[doc = "< The structure type. Must always be set to the corresponding value for any structure (found nearby with a similar name)."]
    pub type_: StructType_t,
    #[doc = "< Pointer to next structure, used for optional parameters and extensions. Can be null."]
    pub pNext: *mut ApiHeader,
}
impl Default for ApiHeader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CreateContextDescHeader = ApiHeader;
pub type ConfigureDescHeader = ApiHeader;
pub type QueryDescHeader = ApiHeader;
pub type DispatchDescHeader = ApiHeader;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ApiMsgType {
    ERROR = 0,
    WARNING = 1,
    COUNT = 2,
}
pub type ApiMessage = ::std::option::Option<unsafe extern "C" fn(type_: u32, message: *const u16)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfigureDescGlobalDebug1 {
    pub header: ConfigureDescHeader,
    pub fpMessage: ApiMessage,
    pub debugLevel: u32,
}
impl Default for ConfigureDescGlobalDebug1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryDescGetVersions {
    pub header: QueryDescHeader,
    #[doc = "< Create description for the effect whose versions should be enumerated."]
    pub createDescType: u64,
    #[doc = "< For DX12: pointer to ID3D12Device."]
    pub device: *mut ::std::os::raw::c_void,
    #[doc = "< Input capacity of id and name arrays. Output number of returned versions. If initially zero, output is number of available versions."]
    pub outputCount: *mut u64,
    #[doc = "< Output array of version ids to be used as version overrides. If null, only names and count are returned."]
    pub versionIds: *mut u64,
    #[doc = "< Output array of version names for display. If null, only ids and count are returned. If both this and versionIds are null, only count is returned."]
    pub versionNames: *mut *const ::std::os::raw::c_char,
}
impl Default for QueryDescGetVersions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OverrideVersion {
    pub header: ApiHeader,
    #[doc = "< Id of version to use. Must be a value returned from a query in ffxQueryDescGetVersions.versionIds array."]
    pub versionId: u64,
}
impl Default for OverrideVersion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryGetProviderVersion {
    pub header: QueryDescHeader,
    #[doc = "< Id of provider being used for queried context. 0 if invalid."]
    pub versionId: u64,
    #[doc = "< Version name for display. If nullptr, the query was invalid."]
    pub versionName: *const ::std::os::raw::c_char,
}
impl Default for QueryGetProviderVersion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Alloc = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: u64,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type Dealloc = ::std::option::Option<
    unsafe extern "C" fn(pUserData: *mut ::std::os::raw::c_void, pMem: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub alloc: Alloc,
    pub dealloc: Dealloc,
}
impl Default for AllocationCallbacks {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub struct Functions {
    __library: ::libloading::Library,
    pub CreateContext: unsafe extern "C" fn(
        context: *mut Context,
        desc: *mut CreateContextDescHeader,
        memCb: *const AllocationCallbacks,
    ) -> ReturnCode_t,
    pub DestroyContext: unsafe extern "C" fn(
        context: *mut Context,
        memCb: *const AllocationCallbacks,
    ) -> ReturnCode_t,
    pub Configure: unsafe extern "C" fn(
        context: *mut Context,
        desc: *const ConfigureDescHeader,
    ) -> ReturnCode_t,
    pub Query:
        unsafe extern "C" fn(context: *mut Context, desc: *mut QueryDescHeader) -> ReturnCode_t,
    pub Dispatch: unsafe extern "C" fn(
        context: *mut Context,
        desc: *const DispatchDescHeader,
    ) -> ReturnCode_t,
}
impl Functions {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let CreateContext = __library.get(b"ffxCreateContext\0").map(|sym| *sym)?;
        let DestroyContext = __library.get(b"ffxDestroyContext\0").map(|sym| *sym)?;
        let Configure = __library.get(b"ffxConfigure\0").map(|sym| *sym)?;
        let Query = __library.get(b"ffxQuery\0").map(|sym| *sym)?;
        let Dispatch = __library.get(b"ffxDispatch\0").map(|sym| *sym)?;
        Ok(Functions {
            __library,
            CreateContext,
            DestroyContext,
            Configure,
            Query,
            Dispatch,
        })
    }
    pub unsafe fn CreateContext(
        &self,
        context: *mut Context,
        desc: *mut CreateContextDescHeader,
        memCb: *const AllocationCallbacks,
    ) -> ReturnCode_t {
        (self.CreateContext)(context, desc, memCb)
    }
    pub unsafe fn DestroyContext(
        &self,
        context: *mut Context,
        memCb: *const AllocationCallbacks,
    ) -> ReturnCode_t {
        (self.DestroyContext)(context, memCb)
    }
    pub unsafe fn Configure(
        &self,
        context: *mut Context,
        desc: *const ConfigureDescHeader,
    ) -> ReturnCode_t {
        (self.Configure)(context, desc)
    }
    pub unsafe fn Query(&self, context: *mut Context, desc: *mut QueryDescHeader) -> ReturnCode_t {
        (self.Query)(context, desc)
    }
    pub unsafe fn Dispatch(
        &self,
        context: *mut Context,
        desc: *const DispatchDescHeader,
    ) -> ReturnCode_t {
        (self.Dispatch)(context, desc)
    }
}
