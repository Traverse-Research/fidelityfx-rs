/* automatically generated by rust-bindgen 0.72.1 */

pub const EFFECT_MASK: u32 = 4294901760;
pub const EFFECT_ID_GENERAL: u32 = 0;
pub const CONFIGURE_GLOBALDEBUG_LEVEL_SILENCE: u32 = 0;
pub const CONFIGURE_GLOBALDEBUG_LEVEL_ERRORS: u32 = 1;
pub const CONFIGURE_GLOBALDEBUG_LEVEL_WARNINGS: u32 = 2;
pub const CONFIGURE_GLOBALDEBUG_LEVEL_VERBOSE: u32 = 268435455;
pub const CONFIGURE_DESC_TYPE_GLOBALDEBUG1: StructType_t = 1;
pub const QUERY_DESC_TYPE_GET_VERSIONS: StructType_t = 4;
pub const DESC_TYPE_OVERRIDE_VERSION: StructType_t = 5;
pub const QUERY_DESC_TYPE_GET_PROVIDER_VERSION: StructType_t = 6;
impl ReturnCodes {
    #[doc = "< The oparation was successful."]
    pub const OK: ReturnCodes = ReturnCodes(0);
    #[doc = "< An error occurred that is not further specified."]
    pub const ERROR: ReturnCodes = ReturnCodes(1);
    #[doc = "< The structure type given was not recognized for the function or context with which it was used. This is likely a programming error."]
    pub const ERROR_UNKNOWN_DESCTYPE: ReturnCodes = ReturnCodes(2);
    #[doc = "< The underlying runtime (e.g. D3D12, Vulkan) or effect returned an error code."]
    pub const ERROR_RUNTIME_ERROR: ReturnCodes = ReturnCodes(3);
    #[doc = "< No provider was found for the given structure type. This is likely a programming error."]
    pub const NO_PROVIDER: ReturnCodes = ReturnCodes(4);
    #[doc = "< A memory allocation failed."]
    pub const ERROR_MEMORY: ReturnCodes = ReturnCodes(5);
    #[doc = "< A parameter was invalid, e.g. a null pointer, empty resource or out-of-bounds enum value."]
    pub const ERROR_PARAMETER: ReturnCodes = ReturnCodes(6);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ReturnCodes(pub ::std::os::raw::c_int);
pub type Context = *mut ::std::os::raw::c_void;
pub type StructType_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Header {
    #[doc = "< The structure type. Must always be set to the corresponding value for any structure (found nearby with a similar name)."]
    pub type_: StructType_t,
    #[doc = "< Pointer to next structure, used for optional parameters and extensions. Can be null."]
    pub pNext: *mut Header,
}
pub type CreateContextDescHeader = Header;
pub type ConfigureDescHeader = Header;
pub type QueryDescHeader = Header;
pub type DispatchDescHeader = Header;
impl MsgType {
    pub const ERROR: MsgType = MsgType(0);
    pub const WARNING: MsgType = MsgType(1);
    pub const COUNT: MsgType = MsgType(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MsgType(pub ::std::os::raw::c_int);
pub type Message = ::std::option::Option<unsafe extern "C" fn(type_: u32, message: *const u16)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfigureDescGlobalDebug1 {
    pub header: ConfigureDescHeader,
    pub fpMessage: Message,
    pub debugLevel: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryDescGetVersions {
    pub header: QueryDescHeader,
    #[doc = "< Create description for the effect whose versions should be enumerated."]
    pub createDescType: u64,
    #[doc = "< For DX12: pointer to ID3D12Device."]
    pub device: *mut ::std::os::raw::c_void,
    #[doc = "< Input capacity of id and name arrays. Output number of returned versions. If initially zero, output is number of available versions."]
    pub outputCount: *mut u64,
    #[doc = "< Output array of version ids to be used as version overrides. If null, only names and count are returned."]
    pub versionIds: *mut u64,
    #[doc = "< Output array of version names for display. If null, only ids and count are returned. If both this and versionIds are null, only count is returned."]
    pub versionNames: *mut *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OverrideVersion {
    pub header: Header,
    #[doc = "< Id of version to use. Must be a value returned from a query in ffxQueryDescGetVersions.versionIds array."]
    pub versionId: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryGetProviderVersion {
    pub header: QueryDescHeader,
    #[doc = "< Id of provider being used for queried context. 0 if invalid."]
    pub versionId: u64,
    #[doc = "< Version name for display. If nullptr, the query was invalid."]
    pub versionName: *const ::std::os::raw::c_char,
}
pub type Alloc = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: u64,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type Dealloc = ::std::option::Option<
    unsafe extern "C" fn(pUserData: *mut ::std::os::raw::c_void, pMem: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub alloc: Alloc,
    pub dealloc: Dealloc,
}
impl Default for AllocationCallbacks {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of surface formats. Needs to match enum FfxSurfaceFormat"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SurfaceFormat {
    #[doc = "< Unknown format"]
    UNKNOWN = 0,
    #[doc = "< 32 bit per channel, 4 channel typeless format"]
    R32G32B32A32_TYPELESS = 1,
    #[doc = "< 32 bit per channel, 4 channel uint format"]
    R32G32B32A32_UINT = 2,
    #[doc = "< 32 bit per channel, 4 channel float format"]
    R32G32B32A32_FLOAT = 3,
    #[doc = "< 16 bit per channel, 4 channel float format"]
    R16G16B16A16_FLOAT = 4,
    #[doc = "< 32 bit per channel, 3 channel float format"]
    R32G32B32_FLOAT = 5,
    #[doc = "< 32 bit per channel, 2 channel float format"]
    R32G32_FLOAT = 6,
    #[doc = "< 8 bit per channel, 1 channel float format"]
    R8_UINT = 7,
    #[doc = "< 32 bit per channel, 1 channel float format"]
    R32_UINT = 8,
    #[doc = "<  8 bit per channel, 4 channel typeless format"]
    R8G8B8A8_TYPELESS = 9,
    #[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
    R8G8B8A8_UNORM = 10,
    #[doc = "<  8 bit per channel, 4 channel signed normalized format"]
    R8G8B8A8_SNORM = 11,
    #[doc = "<  8 bit per channel, 4 channel srgb normalized"]
    R8G8B8A8_SRGB = 12,
    #[doc = "<  8 bit per channel, 4 channel typeless format"]
    B8G8R8A8_TYPELESS = 13,
    #[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
    B8G8R8A8_UNORM = 14,
    #[doc = "<  8 bit per channel, 4 channel srgb normalized"]
    B8G8R8A8_SRGB = 15,
    #[doc = "< 32 bit 3 channel float format"]
    R11G11B10_FLOAT = 16,
    #[doc = "< 10 bit per 3 channel, 2 bit for 1 channel normalized format"]
    R10G10B10A2_UNORM = 17,
    #[doc = "< 16 bit per channel, 2 channel float format"]
    R16G16_FLOAT = 18,
    #[doc = "< 16 bit per channel, 2 channel unsigned int format"]
    R16G16_UINT = 19,
    #[doc = "< 16 bit per channel, 2 channel signed int format"]
    R16G16_SINT = 20,
    #[doc = "< 16 bit per channel, 1 channel float format"]
    R16_FLOAT = 21,
    #[doc = "< 16 bit per channel, 1 channel unsigned int format"]
    R16_UINT = 22,
    #[doc = "< 16 bit per channel, 1 channel unsigned normalized format"]
    R16_UNORM = 23,
    #[doc = "< 16 bit per channel, 1 channel signed normalized format"]
    R16_SNORM = 24,
    #[doc = "<  8 bit per channel, 1 channel unsigned normalized format"]
    R8_UNORM = 25,
    #[doc = "<  8 bit per channel, 2 channel unsigned normalized format"]
    R8G8_UNORM = 26,
    #[doc = "<  8 bit per channel, 2 channel unsigned integer format"]
    R8G8_UINT = 27,
    #[doc = "< 32 bit per channel, 1 channel float format"]
    R32_FLOAT = 28,
    #[doc = "<  9 bit per channel, 5 bit exponent format"]
    R9G9B9E5_SHAREDEXP = 29,
    #[doc = "< 16 bit per channel, 4 channel typeless format"]
    R16G16B16A16_TYPELESS = 30,
    #[doc = "< 32 bit per channel, 2 channel typeless format"]
    R32G32_TYPELESS = 31,
    #[doc = "< 10 bit per 3 channel, 2 bit for 1 channel typeless format"]
    R10G10B10A2_TYPELESS = 32,
    #[doc = "< 16 bit per channel, 2 channel typless format"]
    R16G16_TYPELESS = 33,
    #[doc = "< 16 bit per channel, 1 channel typeless format"]
    R16_TYPELESS = 34,
    #[doc = "<  8 bit per channel, 1 channel typeless format"]
    R8_TYPELESS = 35,
    #[doc = "<  8 bit per channel, 2 channel typeless format"]
    R8G8_TYPELESS = 36,
    #[doc = "< 32 bit per channel, 1 channel typeless format"]
    R32_TYPELESS = 37,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of resource usage."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceUsage {
    #[doc = "< No usage flags indicate a resource is read only."]
    READ_ONLY = 0,
    #[doc = "< Indicates a resource will be used as render target."]
    RENDERTARGET = 1,
    #[doc = "< Indicates a resource will be used as UAV."]
    UAV = 2,
    #[doc = "< Indicates a resource will be used as depth target."]
    DEPTHTARGET = 4,
    #[doc = "< Indicates a resource will be used as indirect argument buffer"]
    INDIRECT = 8,
    #[doc = "< Indicates a resource that will generate array views. Works on 2D and cubemap textures"]
    ARRAYVIEW = 16,
    #[doc = "< Indicates a resource will be used as stencil target."]
    STENCILTARGET = 32,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of resource states."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceState {
    COMMON = 1,
    #[doc = "< Indicates a resource is in the state to be used as UAV."]
    UNORDERED_ACCESS = 2,
    #[doc = "< Indicates a resource is in the state to be read by compute shaders."]
    COMPUTE_READ = 4,
    #[doc = "< Indicates a resource is in the state to be read by pixel shaders."]
    PIXEL_READ = 8,
    #[doc = "< Indicates a resource is in the state to be read by pixel or compute shaders."]
    PIXEL_COMPUTE_READ = 12,
    #[doc = "< Indicates a resource is in the state to be used as source in a copy command."]
    COPY_SRC = 16,
    #[doc = "< Indicates a resource is in the state to be used as destination in a copy command."]
    COPY_DEST = 32,
    #[doc = "< Indicates a resource is in generic (slow) read state."]
    GENERIC_READ = 20,
    #[doc = "< Indicates a resource is in the state to be used as an indirect command argument"]
    INDIRECT_ARGUMENT = 64,
    #[doc = "< Indicates a resource is in the state to be used to present to the swap chain"]
    PRESENT = 128,
    #[doc = "< Indicates a resource is in the state to be used as render target"]
    RENDER_TARGET = 256,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of surface dimensions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceDimension {
    #[doc = "< A resource with a single dimension."]
    TEXTURE_1D = 0,
    #[doc = "< A resource with two dimensions."]
    TEXTURE_2D = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " An enumeration of resource flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceFlags {
    #[doc = "< No flags."]
    NONE = 0,
    #[doc = "< A bit indicating a resource does not need to persist across frames."]
    ALIASABLE = 1,
    #[doc = "< Special case flag used internally when importing resources that require additional setup"]
    UNDEFINED = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceType {
    #[doc = "< The resource is a buffer."]
    BUFFER = 0,
    #[doc = "< The resource is a 1-dimensional texture."]
    TEXTURE1D = 1,
    #[doc = "< The resource is a 2-dimensional texture."]
    TEXTURE2D = 2,
    #[doc = "< The resource is a cube map."]
    TEXTURE_CUBE = 3,
    #[doc = "< The resource is a 3-dimensional texture."]
    TEXTURE3D = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BackbufferTransferFunction {
    SRGB = 0,
    PQ = 1,
    SCRGB = 2,
}
#[doc = " A structure encapsulating a 2-dimensional point, using 32bit unsigned integers."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Dimensions2D {
    #[doc = "< The width of a 2-dimensional range."]
    pub width: u32,
    #[doc = "< The height of a 2-dimensional range."]
    pub height: u32,
}
#[doc = " A structure encapsulating a 2-dimensional set of floating point coordinates."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FloatCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: f32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: f32,
}
#[doc = " A structure encapsulating a 2-dimensional rect."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Rect2D {
    pub left: i32,
    pub top: i32,
    pub width: i32,
    pub height: i32,
}
#[doc = " A structure describing a resource.\n\n @ingroup SDKTypes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ResourceDescription {
    #[doc = "< The type of the resource."]
    pub type_: u32,
    #[doc = "< The surface format."]
    pub format: u32,
    pub __bindgen_anon_1: ResourceDescription__bindgen_ty_1,
    pub __bindgen_anon_2: ResourceDescription__bindgen_ty_2,
    pub __bindgen_anon_3: ResourceDescription__bindgen_ty_3,
    #[doc = "< Number of mips (or 0 for full mipchain)."]
    pub mipCount: u32,
    #[doc = "< A set of resource flags."]
    pub flags: u32,
    #[doc = "< Resource usage flags."]
    pub usage: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_1 {
    #[doc = "< The width of the texture resource."]
    pub width: u32,
    #[doc = "< The size of the buffer resource."]
    pub size: u32,
}
impl Default for ResourceDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_2 {
    #[doc = "< The height of the texture resource."]
    pub height: u32,
    #[doc = "< The stride of the buffer resource."]
    pub stride: u32,
}
impl Default for ResourceDescription__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ResourceDescription__bindgen_ty_3 {
    #[doc = "< The depth of the texture resource."]
    pub depth: u32,
    #[doc = "< The alignment of the buffer resource."]
    pub alignment: u32,
}
impl Default for ResourceDescription__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Resource {
    pub resource: *mut ::std::os::raw::c_void,
    pub description: ResourceDescription,
    pub state: u32,
}
impl Default for Resource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EffectMemoryUsage {
    pub totalUsageInBytes: u64,
    pub aliasableUsageInBytes: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SwapchainFramePacingTuning {
    pub safetyMarginInMs: f32,
    pub varianceFactor: f32,
    pub allowHybridSpin: bool,
    pub hybridSpinTime: u32,
    pub allowWaitForSingleObjectOnFence: bool,
}
pub struct Functions {
    __library: ::libloading::Library,
    pub CreateContext: unsafe extern "C" fn(
        context: *mut Context,
        desc: *mut CreateContextDescHeader,
        memCb: *const AllocationCallbacks,
    ) -> ReturnCode_t,
    pub DestroyContext: unsafe extern "C" fn(
        context: *mut Context,
        memCb: *const AllocationCallbacks,
    ) -> ReturnCode_t,
    pub Configure: unsafe extern "C" fn(
        context: *mut Context,
        desc: *const ConfigureDescHeader,
    ) -> ReturnCode_t,
    pub Query:
        unsafe extern "C" fn(context: *mut Context, desc: *mut QueryDescHeader) -> ReturnCode_t,
    pub Dispatch: unsafe extern "C" fn(
        context: *mut Context,
        desc: *const DispatchDescHeader,
    ) -> ReturnCode_t,
}
impl Functions {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let CreateContext = __library.get(b"ffxCreateContext\0").map(|sym| *sym)?;
        let DestroyContext = __library.get(b"ffxDestroyContext\0").map(|sym| *sym)?;
        let Configure = __library.get(b"ffxConfigure\0").map(|sym| *sym)?;
        let Query = __library.get(b"ffxQuery\0").map(|sym| *sym)?;
        let Dispatch = __library.get(b"ffxDispatch\0").map(|sym| *sym)?;
        Ok(Functions {
            __library,
            CreateContext,
            DestroyContext,
            Configure,
            Query,
            Dispatch,
        })
    }
    pub unsafe fn CreateContext(
        &self,
        context: *mut Context,
        desc: *mut CreateContextDescHeader,
        memCb: *const AllocationCallbacks,
    ) -> ReturnCode_t {
        (self.CreateContext)(context, desc, memCb)
    }
    pub unsafe fn DestroyContext(
        &self,
        context: *mut Context,
        memCb: *const AllocationCallbacks,
    ) -> ReturnCode_t {
        (self.DestroyContext)(context, memCb)
    }
    pub unsafe fn Configure(
        &self,
        context: *mut Context,
        desc: *const ConfigureDescHeader,
    ) -> ReturnCode_t {
        (self.Configure)(context, desc)
    }
    pub unsafe fn Query(&self, context: *mut Context, desc: *mut QueryDescHeader) -> ReturnCode_t {
        (self.Query)(context, desc)
    }
    pub unsafe fn Dispatch(
        &self,
        context: *mut Context,
        desc: *const DispatchDescHeader,
    ) -> ReturnCode_t {
        (self.Dispatch)(context, desc)
    }
}

unsafe impl TaggedStructure for ConfigureDescGlobalDebug1 {
    const TAG: StructType_t = CONFIGURE_DESC_TYPE_GLOBALDEBUG1;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for QueryDescGetVersions {
    const TAG: StructType_t = QUERY_DESC_TYPE_GET_VERSIONS;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}
