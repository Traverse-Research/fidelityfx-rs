/* automatically generated by rust-bindgen 0.72.1 */

pub const API_EFFECT_ID_FRAMEGENERATION: u32 = 131072;
pub const API_CREATE_CONTEXT_DESC_TYPE_FRAMEGENERATION: u32 = 131073;
pub const API_CALLBACK_DESC_TYPE_FRAMEGENERATION_PRESENT: u32 = 131077;
pub const API_DISPATCH_DESC_TYPE_FRAMEGENERATION: u32 = 131075;
pub const API_CONFIGURE_DESC_TYPE_FRAMEGENERATION: u32 = 131074;
pub const API_DISPATCH_DESC_TYPE_FRAMEGENERATION_PREPARE: u32 = 131076;
pub const API_CONFIGURE_DESC_TYPE_FRAMEGENERATION_KEYVALUE: u32 = 131078;
pub const API_QUERY_DESC_TYPE_FRAMEGENERATION_GPU_MEMORY_USAGE: u32 = 131079;
pub const API_CONFIGURE_DESC_TYPE_FRAMEGENERATION_REGISTERDISTORTIONRESOURCE: u32 = 131080;
pub const API_CREATE_CONTEXT_DESC_TYPE_FRAMEGENERATION_HUDLESS: u32 = 131081;
pub const API_DISPATCH_DESC_TYPE_FRAMEGENERATION_PREPARE_CAMERAINFO: u32 = 131082;
#[repr(C)]
pub struct CreateContextDescFrameGeneration {
    pub header: CreateContextDescHeader,
    #[doc = "< A combination of zero or more values from FfxApiCreateContextFramegenerationFlags."]
    pub flags: u32,
    #[doc = "< The resolution at which both rendered and generated frames will be displayed."]
    pub displaySize: ApiDimensions2D,
    #[doc = "< The maximum rendering resolution."]
    pub maxRenderSize: ApiDimensions2D,
    #[doc = "< The surface format for the backbuffer. One of the values from FfxApiSurfaceFormat."]
    pub backBufferFormat: u32,
}
impl Default for CreateContextDescFrameGeneration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct CallbackDescFrameGenerationPresent {
    pub header: DispatchDescHeader,
    #[doc = "< The device passed in (from a backend description) during context creation."]
    pub device: *mut ::std::os::raw::c_void,
    #[doc = "< A command list that will be executed before presentation."]
    pub commandList: *mut ::std::os::raw::c_void,
    #[doc = "< Backbuffer image either rendered or generated."]
    pub currentBackBuffer: ApiResource,
    #[doc = "< UI image for composition if passed. Otherwise empty."]
    pub currentUI: ApiResource,
    #[doc = "< Output image that will be presented."]
    pub outputSwapChainBuffer: ApiResource,
    #[doc = "< true if this frame is generated, false if rendered."]
    pub isGeneratedFrame: bool,
    #[doc = "< Identifier used to select internal resources when async support is enabled. Must increment by exactly one (1) for each frame. Any non-exactly-one difference will reset the frame generation logic."]
    pub frameID: u64,
}
impl Default for CallbackDescFrameGenerationPresent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct DispatchDescFrameGeneration {
    pub header: DispatchDescHeader,
    #[doc = "< The command list on which to register render commands."]
    pub commandList: *mut ::std::os::raw::c_void,
    #[doc = "< The current presentation color, this will be used as source data."]
    pub presentColor: ApiResource,
    #[doc = "< Destination targets (1 for each frame in numGeneratedFrames)."]
    pub outputs: [ApiResource; 4usize],
    #[doc = "< The number of frames to generate from the passed in color target."]
    pub numGeneratedFrames: u32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The transfer function use to convert frame generation source color data to linear RGB. One of the values from FfxApiBackbufferTransferFunction."]
    pub backbufferTransferFunction: u32,
    #[doc = "< Min and max luminance values, used when converting HDR colors to linear RGB."]
    pub minMaxLuminance: [f32; 2usize],
    #[doc = "< The area of the backbuffer that should be used for generation in case only a part of the screen is used e.g. due to movie bars."]
    pub generationRect: ApiRect2D,
    #[doc = "< Identifier used to select internal resources when async support is enabled. Must increment by exactly one (1) for each frame. Any non-exactly-one difference will reset the frame generation logic."]
    pub frameID: u64,
}
impl Default for DispatchDescFrameGeneration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ApiPresentCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut CallbackDescFrameGenerationPresent,
        pUserCtx: *mut ::std::os::raw::c_void,
    ) -> ReturnCode_t,
>;
pub type ApiFrameGenerationDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut DispatchDescFrameGeneration,
        pUserCtx: *mut ::std::os::raw::c_void,
    ) -> ReturnCode_t,
>;
#[repr(C)]
pub struct ConfigureDescFrameGeneration {
    pub header: ConfigureDescHeader,
    #[doc = "< The swapchain to use with frame generation."]
    pub swapChain: *mut ::std::os::raw::c_void,
    #[doc = "< A UI composition callback to call when finalizing the frame image."]
    pub presentCallback: ApiPresentCallbackFunc,
    #[doc = "< A pointer to be passed to the UI composition callback."]
    pub presentCallbackUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< The frame generation callback to use to generate a frame."]
    pub frameGenerationCallback: ApiFrameGenerationDispatchFunc,
    #[doc = "< A pointer to be passed to the frame generation callback."]
    pub frameGenerationCallbackUserContext: *mut ::std::os::raw::c_void,
    #[doc = "< Sets the state of frame generation. Set to false to disable frame generation."]
    pub frameGenerationEnabled: bool,
    #[doc = "< Sets the state of async workloads. Set to true to enable generation work on async compute."]
    pub allowAsyncWorkloads: bool,
    #[doc = "< The hudless back buffer image to use for UI extraction from backbuffer resource. May be empty."]
    pub HUDLessColor: ApiResource,
    #[doc = "< Zero or combination of flags from FfxApiDispatchFrameGenerationFlags."]
    pub flags: u32,
    #[doc = "< Set to true to only present generated frames."]
    pub onlyPresentGenerated: bool,
    #[doc = "< The area of the backbuffer that should be used for generation in case only a part of the screen is used e.g. due to movie bars"]
    pub generationRect: ApiRect2D,
    #[doc = "< Identifier used to select internal resources when async support is enabled. Must increment by exactly one (1) for each frame. Any non-exactly-one difference will reset the frame generation logic."]
    pub frameID: u64,
}
impl Default for ConfigureDescFrameGeneration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct DispatchDescFrameGenerationPrepare {
    pub header: DispatchDescHeader,
    #[doc = "< Identifier used to select internal resources when async support is enabled. Must increment by exactly one (1) for each frame. Any non-exactly-one difference will reset the frame generation logic."]
    pub frameID: u64,
    #[doc = "< Zero or combination of values from FfxApiDispatchFrameGenerationFlags."]
    pub flags: u32,
    #[doc = "< A command list to record frame generation commands into."]
    pub commandList: *mut ::std::os::raw::c_void,
    #[doc = "< The dimensions used to render game content, dilatedDepth, dilatedMotionVectors are expected to be of ths size."]
    pub renderSize: ApiDimensions2D,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: ApiFloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: ApiFloatCoords2D,
    #[doc = "< Time elapsed in milliseconds since the last frame."]
    pub frameTimeDelta: f32,
    #[doc = "< A (currently unused) boolean value which when set to true, indicates FrameGeneration will be called in reset mode"]
    pub unused_reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< The depth buffer data"]
    pub depth: ApiResource,
    #[doc = "< The motion vector data"]
    pub motionVectors: ApiResource,
}
impl Default for DispatchDescFrameGenerationPrepare {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ConfigureDescFrameGenerationKeyValue {
    pub header: ConfigureDescHeader,
    #[doc = "< Configuration key, member of the FfxApiConfigureFrameGenerationKey enumeration."]
    pub key: u64,
    #[doc = "< Integer value or enum value to set."]
    pub u64_: u64,
    #[doc = "< Pointer to set or pointer to value to set."]
    pub ptr: *mut ::std::os::raw::c_void,
}
impl Default for ConfigureDescFrameGenerationKeyValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ApiConfigureFrameGenerationKey {
    __bindgen_cannot_repr_c_on_empty_enum = 0,
}
#[repr(C)]
pub struct QueryDescFrameGenerationGetGPUMemoryUsage {
    pub header: QueryDescHeader,
    pub gpuMemoryUsageFrameGeneration: *mut ApiEffectMemoryUsage,
}
impl Default for QueryDescFrameGenerationGetGPUMemoryUsage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct ConfigureDescFrameGenerationRegisterDistortionFieldResource {
    pub header: ConfigureDescHeader,
    #[doc = "< A resource containing distortion offset data. Needs to be 2-component (ie. RG). Read by FG shaders via Sample. Resource's xy components encodes [UV coordinate of pixel after lens distortion effect- UV coordinate of pixel before lens distortion]."]
    pub distortionField: ApiResource,
}
impl Default for ConfigureDescFrameGenerationRegisterDistortionFieldResource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct CreateContextDescFrameGenerationHudless {
    pub header: CreateContextDescHeader,
    #[doc = "< The surface format for the hudless back buffer. One of the values from FfxApiSurfaceFormat."]
    pub hudlessBackBufferFormat: u32,
}
impl Default for CreateContextDescFrameGenerationHudless {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct DispatchDescFrameGenerationPrepareCameraInfo {
    pub header: ConfigureDescHeader,
    #[doc = "< The camera position in world space"]
    pub cameraPosition: [f32; 3usize],
    #[doc = "< The camera up normalized vector in world space."]
    pub cameraUp: [f32; 3usize],
    #[doc = "< The camera right normalized vector in world space."]
    pub cameraRight: [f32; 3usize],
    #[doc = "< The camera forward normalized vector in world space."]
    pub cameraForward: [f32; 3usize],
}
impl Default for DispatchDescFrameGenerationPrepareCameraInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub struct Functions {
    __library: ::libloading::Library,
}
impl Functions {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        Ok(Functions { __library })
    }
}
