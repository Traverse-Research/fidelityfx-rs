/* automatically generated by rust-bindgen 0.72.1 */

pub const EFFECT_ID_NSS: u32 = 983040;
pub const CREATE_CONTEXT_DESC_TYPE_NSS: StructType_t = 983040;
pub const DISPATCH_DESC_TYPE_NSS: StructType_t = 983041;
pub const QUERY_DESC_TYPE_NSS_GETJITTERPHASECOUNT: StructType_t = 983044;
pub const QUERY_DESC_TYPE_NSS_GETJITTEROFFSET: StructType_t = 983045;
#[repr(i32)]
#[non_exhaustive]
#[doc = " @ingroup ffxNss"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NssShaderQualityMode {
    #[doc = "< Perform upscaling with a shader quality mode of 'Quality'"]
    QUALITY = 1,
    #[doc = "< Perform upscaling with a shader quality mode of 'Balanced'"]
    BALANCED = 2,
    #[doc = "< Perform upscaling with a shader quality mode of 'Performance'"]
    PERFORMANCE = 3,
}
impl CreateContextNssFlags {
    #[doc = "< Use a quantized data graph. Resources will be quantized to 8 bits."]
    pub const QUANTIZED: CreateContextNssFlags = CreateContextNssFlags(1);
    #[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
    pub const HIGH_DYNAMIC_RANGE: CreateContextNssFlags = CreateContextNssFlags(2);
    #[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
    pub const DEPTH_INVERTED: CreateContextNssFlags = CreateContextNssFlags(4);
    #[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
    pub const DEPTH_INFINITE: CreateContextNssFlags = CreateContextNssFlags(8);
    #[doc = "< A bit indicating sample using Bicubic filtering"]
    pub const RESAMPLE_BICUBIC: CreateContextNssFlags = CreateContextNssFlags(16);
    #[doc = "< A bit indicating tensor image aliasing is enable."]
    pub const READ_TENSORS_AS_IMAGES: CreateContextNssFlags = CreateContextNssFlags(32);
    #[doc = "< A bit indicating that the runtime should allow 16bit resources to be used."]
    pub const ALLOW_16BIT: CreateContextNssFlags = CreateContextNssFlags(64);
    #[doc = "< A bit indicating that the runtime should check some API values and report issues."]
    pub const ENABLE_DEBUG_CHECKING: CreateContextNssFlags = CreateContextNssFlags(128);
}
impl ::std::ops::BitOr<CreateContextNssFlags> for CreateContextNssFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        CreateContextNssFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for CreateContextNssFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: CreateContextNssFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<CreateContextNssFlags> for CreateContextNssFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        CreateContextNssFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for CreateContextNssFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: CreateContextNssFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @ingroup ffxNss"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CreateContextNssFlags(pub ::std::os::raw::c_int);
impl DispatchNssFlags {
    #[doc = "< A bit indicating that the output resource will contain debug views with relevant information."]
    pub const DEBUG_VIEW: DispatchNssFlags = DispatchNssFlags(1);
}
impl ::std::ops::BitOr<DispatchNssFlags> for DispatchNssFlags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        DispatchNssFlags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for DispatchNssFlags {
    #[inline]
    fn bitor_assign(&mut self, rhs: DispatchNssFlags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<DispatchNssFlags> for DispatchNssFlags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        DispatchNssFlags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for DispatchNssFlags {
    #[inline]
    fn bitand_assign(&mut self, rhs: DispatchNssFlags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @ingroup ffxNss"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DispatchNssFlags(pub ::std::os::raw::c_int);
#[doc = " @ingroup ffxNss"]
#[repr(C)]
pub struct CreateContextDescNss {
    pub header: CreateContextDescHeader,
    #[doc = "< Zero or a combination of values from FfxApiCreateContextNssFlags."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub maxUpscaleSize: Dimensions2D,
    #[doc = "< A pointer to a function that can receive messages from the runtime. May be null."]
    pub fpMessage: Message,
    #[doc = "< The desired quality mode for the upscaling process."]
    pub qualityMode: NssShaderQualityMode,
}
impl Default for CreateContextDescNss {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @ingroup ffxNss"]
#[repr(C)]
pub struct DispatchDescNss {
    pub header: DispatchDescHeader,
    #[doc = "< Command list to record upscaling rendering commands into."]
    pub commandList: *mut ::std::os::raw::c_void,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the previous frame (at render resolution)."]
    pub depthTm1: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_NSS_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the previous frame (at presentation resolution)."]
    pub outputTm1: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub output: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the debug views if DRAW_DEBUG_VIEW dispatch flag is turned on. Can be left nullptr if not using it.\n< Necessary because we will pollute the colour history if we render debug views directly in the output buffer.\n< (We could also use an internally FFX managed colour history, but that would imply doing an extra blit every frame to copy the input colour into history!)"]
    pub debugViews: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the output resources."]
    pub upscaleSize: Dimensions2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The exposure value"]
    pub exposure: f32,
    #[doc = "< The scale applied to the motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< Zero or a combination of values from FfxApiDispatchNssFlags."]
    pub flags: u32,
}
impl Default for DispatchDescNss {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @ingroup ffxNss"]
#[repr(C)]
pub struct QueryDescNssGetJitterPhaseCount {
    pub header: QueryDescHeader,
    #[doc = "< The render resolution width."]
    pub renderWidth: u32,
    #[doc = "< The output resolution width."]
    pub displayWidth: u32,
    #[doc = "< A pointer to a <c>int32_t</c> which will hold the jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>."]
    pub pOutPhaseCount: *mut i32,
}
impl Default for QueryDescNssGetJitterPhaseCount {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @ingroup ffxNss"]
#[repr(C)]
pub struct QueryDescNssGetJitterOffset {
    pub header: QueryDescHeader,
    #[doc = "< The index within the jitter sequence."]
    pub index: i32,
    #[doc = "< The length of jitter phase. See <c><i>ffxQueryDescFsrGetJitterPhaseCount</i></c>."]
    pub phaseCount: i32,
    #[doc = "< A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension."]
    pub pOutX: *mut f32,
    #[doc = "< A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension."]
    pub pOutY: *mut f32,
}
impl Default for QueryDescNssGetJitterOffset {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

unsafe impl TaggedStructure for CreateContextDescNss {
    const TAG: StructType_t = CREATE_CONTEXT_DESC_TYPE_NSS;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for DispatchDescNss {
    const TAG: StructType_t = DISPATCH_DESC_TYPE_NSS;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for QueryDescNssGetJitterPhaseCount {
    const TAG: StructType_t = QUERY_DESC_TYPE_NSS_GETJITTERPHASECOUNT;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}

unsafe impl TaggedStructure for QueryDescNssGetJitterOffset {
    const TAG: StructType_t = QUERY_DESC_TYPE_NSS_GETJITTEROFFSET;
    fn header_mut(&mut self) -> &mut Header {
        &mut self.header
    }
}
